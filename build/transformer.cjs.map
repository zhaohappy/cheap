{"version":3,"file":"transformer.cjs","sources":["../src/transformer/function/getFilePath.ts","../src/transformer/function/parseImports.ts","../src/transformer/function/pushImport.ts","../src/transformer/constant.ts","../src/transformer/visitor/function/addImportStatements.ts","../src/transformer/function/relativePath.ts","../../../node_modules/.pnpm/@isaacs+balanced-match@4.0.1/node_modules/@isaacs/balanced-match/dist/esm/index.js","../../../node_modules/.pnpm/@isaacs+brace-expansion@5.0.0/node_modules/@isaacs/brace-expansion/dist/esm/index.js","../../../node_modules/.pnpm/minimatch@10.1.1/node_modules/minimatch/dist/esm/assert-valid-pattern.js","../../../node_modules/.pnpm/minimatch@10.1.1/node_modules/minimatch/dist/esm/brace-expressions.js","../../../node_modules/.pnpm/minimatch@10.1.1/node_modules/minimatch/dist/esm/unescape.js","../../../node_modules/.pnpm/minimatch@10.1.1/node_modules/minimatch/dist/esm/ast.js","../../../node_modules/.pnpm/minimatch@10.1.1/node_modules/minimatch/dist/esm/escape.js","../../../node_modules/.pnpm/minimatch@10.1.1/node_modules/minimatch/dist/esm/index.js","../src/transformer/function/reportError.ts","../src/transformer/statement.ts","../src/transformer/defined.ts","../src/typedef.ts","../src/symbol.ts","../src/cstruct.ts","../src/transformer/struct.ts","../src/transformer/util/typeutil.ts","../src/transformer/util/nodeutil.ts","../src/transformer/visitor/blockVisitor.ts","../src/transformer/visitor/identifierVisitor.ts","../src/transformer/visitor/decoratorVisitor.ts","../src/transformer/visitor/function/generateStruct.ts","../src/transformer/visitor/classDeclarationVisitor.ts","../src/transformer/visitor/ifStatementVisitor.ts","../src/transformer/visitor/parameterVisitor.ts","../src/transformer/error.ts","../src/transformer/visitor/variableDeclarationVisitor.ts","../src/transformer/visitor/functionDeclarationVisitor.ts","../src/transformer/visitor/expressionStatementVisitor.ts","../src/transformer/visitor/bigIntLiteralVisitor.ts","../src/transformer/function/getStructMeta.ts","../src/transformer/visitor/callVisitor.ts","../src/transformer/visitor/propertyAccessExpressionVisitor.ts","../src/transformer/function/isMergeOperator.ts","../src/transformer/function/mergeOperator2Operator.ts","../src/transformer/function/compute.ts","../src/transformer/visitor/binaryExpressionVisitor.ts","../src/transformer/visitor/unaryExpressionVisitor.ts","../src/transformer/visitor/elementAccessExpressionVisitor.ts","../src/transformer/visitor/function/processAsm.ts","../src/transformer/visitor/taggedTemplateExpressionVisitor.ts","../src/transformer/visitor/conditionalExpressionVisitor.ts","../src/transformer/visitor/expressionVisitor.ts","../src/transformer/visitor/propertyDeclarationVisitor.ts","../src/transformer/visitor/propertyAssignmentVisitor.ts","../src/transformer/visitor/bindingElementVisitor.ts","../src/transformer/function/getDirname.ts","../src/transformer/index.ts"],"sourcesContent":["import ts from 'typescript'\n\nexport default function getFilePath(program: ts.Program, current: string, target: string) {\n  const path = ts.resolveModuleName(\n    target,\n    current,\n    program.getCompilerOptions(),\n    ts.sys\n  )\n  return path.resolvedModule?.resolvedFileName\n}\n","import ts from 'typescript'\nimport path from 'path'\nimport getFilePath from './getFilePath'\n\nexport default function parseImports(file: ts.SourceFile, program: ts.Program, typeChecker: ts.TypeChecker, locals: Map<string, ts.Symbol>) {\n  const map: Map<string, {\n    map: Map<string, string>\n    specifier: string\n  }> = new Map()\n\n  file.statements.forEach((node) => {\n    if (ts.isImportDeclaration(node)) {\n      const ext = path.extname((node.moduleSpecifier as ts.StringLiteral).text)\n      if (!ext || ext === '.ts') {\n        const specifier = (node.moduleSpecifier as ts.StringLiteral).text.split('!').pop()\n        const filePath = getFilePath(program, file.fileName, specifier)\n        if (filePath) {\n          const m = map.get(filePath) || {\n            map: new Map(),\n            specifier\n          }\n          if (node.importClause && ts.isImportClause(node.importClause)) {\n            if (node.importClause.isTypeOnly\n              || node.importClause.phaseModifier === ts.SyntaxKind.TypeKeyword\n            ) {\n              return\n            }\n            if (node.importClause.name && ts.isIdentifier(node.importClause.name)) {\n              m.map.set('default', node.importClause.name.escapedText as string)\n              locals.set(node.importClause.name.escapedText as string, typeChecker.getSymbolAtLocation(node.importClause.name))\n            }\n            if (node.importClause.namedBindings) {\n              if (ts.isNamedImports(node.importClause.namedBindings)) {\n                node.importClause.namedBindings.elements.forEach((element) => {\n                  if (element.isTypeOnly) {\n                    return\n                  }\n                  if (element.propertyName && ts.isIdentifier(element.propertyName)) {\n                    m.map.set(element.propertyName.escapedText as string, element.name.escapedText as string)\n                    locals.set(element.propertyName.escapedText as string, typeChecker.getSymbolAtLocation(element.propertyName))\n                  }\n                  else {\n                    m.map.set(element.name.escapedText as string, element.name.escapedText as string)\n                    locals.set(element.name.escapedText as string, typeChecker.getSymbolAtLocation(element.name))\n                  }\n                })\n              }\n              else if (ts.isNamespaceImport(node.importClause.namedBindings)) {\n                m.map.set('all', node.importClause.namedBindings.name.escapedText as string)\n              }\n            }\n          }\n          map.set(filePath, m)\n        }\n      }\n    }\n  })\n\n  return map\n}\n","import type { ImportData, RequireData } from '../type'\n\nexport function pushImport(\n  keys: ImportData[],\n  name: string,\n  path: string,\n  formatName: string,\n  defaultExport: boolean\n) {\n  for (let i = 0; i < keys.length; i++) {\n    if (keys[i].name === name && keys[i].path === path) {\n      return keys[i]\n    }\n  }\n\n  const item = {\n    name,\n    path,\n    default: defaultExport,\n    formatName\n  }\n\n  keys.push(item)\n\n  return item as ImportData\n}\n\nexport function pushRequire(\n  keys: RequireData[],\n  formatName: string,\n  path: string,\n  defaultExport: boolean,\n  esModule: boolean\n) {\n  for (let i = 0; i < keys.length; i++) {\n    if (keys[i].path === path && keys[i].default === defaultExport) {\n      return keys[i]\n    }\n  }\n\n  const item = {\n    formatName,\n    path,\n    default: defaultExport,\n    esModule\n  }\n\n  keys.push(item)\n\n  return item as RequireData\n}\n","export const accessof = 'accessof'\nexport const addressof = 'addressof'\nexport const offsetof = 'offsetof'\nexport const memcpy = 'memcpy'\nexport const sizeof = 'sizeof'\nexport const move = 'move'\nexport const staticCast = 'static_cast'\nexport const assert = 'assert'\nexport const indexOf = 'indexOf'\nexport const reinterpretCast = 'reinterpret_cast'\nexport const sharedPtr = 'SharedPtr'\n\nexport const structAccess = 'mapStruct'\nexport const writePointer = 'writePointer'\nexport const ctypeEnumWrite = 'CTypeEnumWrite'\nexport const ctypeEnumRead = 'CTypeEnumRead'\nexport const definedMetaProperty = 'definedMetaProperty'\n\nexport const symbolStructAddress = 'symbolStructAddress'\nexport const symbolStruct = 'symbolStruct'\nexport const symbolStructMaxBaseTypeByteLength = 'symbolStructMaxBaseTypeByteLength'\nexport const symbolStructLength = 'symbolStructLength'\nexport const symbolStructKeysMeta = 'symbolStructKeysMeta'\n\nexport const createThreadFromClass = 'createThreadFromClass'\nexport const createThreadFromFunction = 'createThreadFromFunction'\nexport const createThreadFromModule = 'createThreadFromModule'\n\nexport const typeArray = 'array'\nexport const typeBit = 'bit'\nexport const typePointer = 'pointer'\nexport const typeSize = 'size'\nexport const typeAnyptr = 'anyptr'\nexport const typeNullptr = 'nullptr'\nexport const typeMultiPointer = 'multiPointer'\nexport const typeUnion = 'union'\nexport const typeStruct = 'struct'\nexport const defined = 'defined'\nexport const args = 'args'\nexport const enableArgs = 'enableArgs'\n\nexport const enumPointer = 'typeptr'\n\nexport const tagAsm = 'asm'\nexport const tagAsm64 = 'asm64'\n\nexport const prototype = 'prototype'\n\nexport const cstruct = 'struct'\nexport const cunion = 'union'\nexport const ctype = 'type'\nexport const cpointer = 'pointer'\nexport const carray = 'array'\nexport const cbitField = 'bit'\nexport const cignore = 'ignore'\nexport const cinline = 'inline'\nexport const cdeasync = 'deasync'\n\nexport const make = 'make'\nexport const unmake = 'unmake'\nexport const malloc = 'malloc'\nexport const calloc = 'calloc'\nexport const realloc = 'realloc'\nexport const alignedAlloc = 'aligned_alloc'\nexport const free = 'free'\nexport const Allocator = 'Allocator'\nexport const makeSharedPtr = 'make_shared_ptr'\n\nexport const makeSharedPtrImportName = 'makeSharedPtr'\nexport const smartPointerProperty = ['get', 'reset', 'unique', 'useCount', 'has', 'transferable', 'clone']\n\nexport const typeProperty = 'zzztype__'\nexport const levelProperty = 'zzzlevel__'\nexport const structProperty = 'zzzstruct__'\n\nexport const LINE = '___LINE__'\nexport const LINE_2 = '__LINE__'\nexport const FILE = '___FILE__'\nexport const FILE_2 = '__FILE__'\nexport const MODULE = '___MODULE__'\nexport const MODULE_2 = '__MODULE__'\n\nexport const importStar = '__importStar'\nexport const importDefault = '__importDefault'\nexport const symbolIsPointer = Symbol('symbolIsPointer')\n\nexport let PACKET_NAME = ''\n\nexport let RootPath = ''\nexport let InternalPath = ''\nexport let AllocatorPath = ''\nexport let makePath = ''\nexport let unmakePath = ''\nexport let makeSharedPtrPath = ''\nexport let atomicsPath = ''\nexport let sizeofPath = ''\nexport let definedMetaPropertyPath = ''\nexport let memoryPath = ''\nexport let symbolPath = ''\nexport let structAccessPath = ''\nexport let ctypeEnumReadPath = ''\nexport let ctypeEnumWritePath = ''\nexport let cheapThreadPath = ''\n\nexport function setPacketName(name: string) {\n  PACKET_NAME = name\n  RootPath = PACKET_NAME\n  InternalPath = PACKET_NAME + '/internal'\n  AllocatorPath = PACKET_NAME + '/heap'\n  makePath = PACKET_NAME + '/std/make'\n  unmakePath = PACKET_NAME + '/std/unmake'\n  makeSharedPtrPath = PACKET_NAME + '/std/smartPtr/SharedPtr'\n  atomicsPath = PACKET_NAME + '/thread/atomics'\n  sizeofPath = PACKET_NAME + '/std/sizeof'\n  definedMetaPropertyPath = PACKET_NAME + '/function/definedMetaProperty'\n  memoryPath = PACKET_NAME + '/std/memory'\n  symbolPath = PACKET_NAME + '/symbol'\n  structAccessPath = PACKET_NAME + '/std/mapStruct'\n  ctypeEnumReadPath = PACKET_NAME + '/ctypeEnumRead'\n  ctypeEnumWritePath = PACKET_NAME + '/ctypeEnumWrite'\n  cheapThreadPath = PACKET_NAME + '/thread/thread'\n}\n","import type { ImportData } from '../../type'\nimport statement from '../../statement'\n\nexport default function addImportStatements(imports: ImportData[], path: string, updatedStatements: any[]) {\n  if (imports.length) {\n    const importElements = []\n\n    imports.forEach((item) => {\n      importElements.push(statement.context.factory.createImportSpecifier(\n        false,\n        statement.context.factory.createIdentifier(item.name),\n        statement.context.factory.createIdentifier(item.formatName)\n      ))\n    })\n\n    const importDeclaration = statement.context.factory.createImportDeclaration(\n      undefined,\n      statement.context.factory.createImportClause(\n        false,\n        undefined,\n        statement.context.factory.createNamedImports(importElements)\n      ),\n      statement.context.factory.createStringLiteral(path)\n    )\n\n    updatedStatements.push(importDeclaration)\n  }\n}\n","import path from 'path'\n\nexport default function relativePath(a: string, b: string) {\n  let p = path.relative(path.dirname(a), b)\n\n  // 去掉 d.ts .ts .js 后缀\n  p = p.replace(/(\\.d)?\\.[t|j]s$/, '')\n\n  if (path.isAbsolute(p)) {\n    return p\n  }\n  else if (/\\.\\.\\//.test(p)) {\n    return p\n  }\n  return './' + p\n}\n","export const balanced = (a, b, str) => {\n    const ma = a instanceof RegExp ? maybeMatch(a, str) : a;\n    const mb = b instanceof RegExp ? maybeMatch(b, str) : b;\n    const r = ma !== null && mb != null && range(ma, mb, str);\n    return (r && {\n        start: r[0],\n        end: r[1],\n        pre: str.slice(0, r[0]),\n        body: str.slice(r[0] + ma.length, r[1]),\n        post: str.slice(r[1] + mb.length),\n    });\n};\nconst maybeMatch = (reg, str) => {\n    const m = str.match(reg);\n    return m ? m[0] : null;\n};\nexport const range = (a, b, str) => {\n    let begs, beg, left, right = undefined, result;\n    let ai = str.indexOf(a);\n    let bi = str.indexOf(b, ai + 1);\n    let i = ai;\n    if (ai >= 0 && bi > 0) {\n        if (a === b) {\n            return [ai, bi];\n        }\n        begs = [];\n        left = str.length;\n        while (i >= 0 && !result) {\n            if (i === ai) {\n                begs.push(i);\n                ai = str.indexOf(a, i + 1);\n            }\n            else if (begs.length === 1) {\n                const r = begs.pop();\n                if (r !== undefined)\n                    result = [r, bi];\n            }\n            else {\n                beg = begs.pop();\n                if (beg !== undefined && beg < left) {\n                    left = beg;\n                    right = bi;\n                }\n                bi = str.indexOf(b, i + 1);\n            }\n            i = ai < bi && ai >= 0 ? ai : bi;\n        }\n        if (begs.length && right !== undefined) {\n            result = [left, right];\n        }\n    }\n    return result;\n};\n//# sourceMappingURL=index.js.map","import { balanced } from '@isaacs/balanced-match';\nconst escSlash = '\\0SLASH' + Math.random() + '\\0';\nconst escOpen = '\\0OPEN' + Math.random() + '\\0';\nconst escClose = '\\0CLOSE' + Math.random() + '\\0';\nconst escComma = '\\0COMMA' + Math.random() + '\\0';\nconst escPeriod = '\\0PERIOD' + Math.random() + '\\0';\nconst escSlashPattern = new RegExp(escSlash, 'g');\nconst escOpenPattern = new RegExp(escOpen, 'g');\nconst escClosePattern = new RegExp(escClose, 'g');\nconst escCommaPattern = new RegExp(escComma, 'g');\nconst escPeriodPattern = new RegExp(escPeriod, 'g');\nconst slashPattern = /\\\\\\\\/g;\nconst openPattern = /\\\\{/g;\nconst closePattern = /\\\\}/g;\nconst commaPattern = /\\\\,/g;\nconst periodPattern = /\\\\./g;\nfunction numeric(str) {\n    return !isNaN(str) ? parseInt(str, 10) : str.charCodeAt(0);\n}\nfunction escapeBraces(str) {\n    return str\n        .replace(slashPattern, escSlash)\n        .replace(openPattern, escOpen)\n        .replace(closePattern, escClose)\n        .replace(commaPattern, escComma)\n        .replace(periodPattern, escPeriod);\n}\nfunction unescapeBraces(str) {\n    return str\n        .replace(escSlashPattern, '\\\\')\n        .replace(escOpenPattern, '{')\n        .replace(escClosePattern, '}')\n        .replace(escCommaPattern, ',')\n        .replace(escPeriodPattern, '.');\n}\n/**\n * Basically just str.split(\",\"), but handling cases\n * where we have nested braced sections, which should be\n * treated as individual members, like {a,{b,c},d}\n */\nfunction parseCommaParts(str) {\n    if (!str) {\n        return [''];\n    }\n    const parts = [];\n    const m = balanced('{', '}', str);\n    if (!m) {\n        return str.split(',');\n    }\n    const { pre, body, post } = m;\n    const p = pre.split(',');\n    p[p.length - 1] += '{' + body + '}';\n    const postParts = parseCommaParts(post);\n    if (post.length) {\n        ;\n        p[p.length - 1] += postParts.shift();\n        p.push.apply(p, postParts);\n    }\n    parts.push.apply(parts, p);\n    return parts;\n}\nexport function expand(str) {\n    if (!str) {\n        return [];\n    }\n    // I don't know why Bash 4.3 does this, but it does.\n    // Anything starting with {} will have the first two bytes preserved\n    // but *only* at the top level, so {},a}b will not expand to anything,\n    // but a{},b}c will be expanded to [a}c,abc].\n    // One could argue that this is a bug in Bash, but since the goal of\n    // this module is to match Bash's rules, we escape a leading {}\n    if (str.slice(0, 2) === '{}') {\n        str = '\\\\{\\\\}' + str.slice(2);\n    }\n    return expand_(escapeBraces(str), true).map(unescapeBraces);\n}\nfunction embrace(str) {\n    return '{' + str + '}';\n}\nfunction isPadded(el) {\n    return /^-?0\\d/.test(el);\n}\nfunction lte(i, y) {\n    return i <= y;\n}\nfunction gte(i, y) {\n    return i >= y;\n}\nfunction expand_(str, isTop) {\n    /** @type {string[]} */\n    const expansions = [];\n    const m = balanced('{', '}', str);\n    if (!m)\n        return [str];\n    // no need to expand pre, since it is guaranteed to be free of brace-sets\n    const pre = m.pre;\n    const post = m.post.length ? expand_(m.post, false) : [''];\n    if (/\\$$/.test(m.pre)) {\n        for (let k = 0; k < post.length; k++) {\n            const expansion = pre + '{' + m.body + '}' + post[k];\n            expansions.push(expansion);\n        }\n    }\n    else {\n        const isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n        const isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n        const isSequence = isNumericSequence || isAlphaSequence;\n        const isOptions = m.body.indexOf(',') >= 0;\n        if (!isSequence && !isOptions) {\n            // {a},b}\n            if (m.post.match(/,(?!,).*\\}/)) {\n                str = m.pre + '{' + m.body + escClose + m.post;\n                return expand_(str);\n            }\n            return [str];\n        }\n        let n;\n        if (isSequence) {\n            n = m.body.split(/\\.\\./);\n        }\n        else {\n            n = parseCommaParts(m.body);\n            if (n.length === 1 && n[0] !== undefined) {\n                // x{{a,b}}y ==> x{a}y x{b}y\n                n = expand_(n[0], false).map(embrace);\n                //XXX is this necessary? Can't seem to hit it in tests.\n                /* c8 ignore start */\n                if (n.length === 1) {\n                    return post.map(p => m.pre + n[0] + p);\n                }\n                /* c8 ignore stop */\n            }\n        }\n        // at this point, n is the parts, and we know it's not a comma set\n        // with a single entry.\n        let N;\n        if (isSequence && n[0] !== undefined && n[1] !== undefined) {\n            const x = numeric(n[0]);\n            const y = numeric(n[1]);\n            const width = Math.max(n[0].length, n[1].length);\n            let incr = n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1;\n            let test = lte;\n            const reverse = y < x;\n            if (reverse) {\n                incr *= -1;\n                test = gte;\n            }\n            const pad = n.some(isPadded);\n            N = [];\n            for (let i = x; test(i, y); i += incr) {\n                let c;\n                if (isAlphaSequence) {\n                    c = String.fromCharCode(i);\n                    if (c === '\\\\') {\n                        c = '';\n                    }\n                }\n                else {\n                    c = String(i);\n                    if (pad) {\n                        const need = width - c.length;\n                        if (need > 0) {\n                            const z = new Array(need + 1).join('0');\n                            if (i < 0) {\n                                c = '-' + z + c.slice(1);\n                            }\n                            else {\n                                c = z + c;\n                            }\n                        }\n                    }\n                }\n                N.push(c);\n            }\n        }\n        else {\n            N = [];\n            for (let j = 0; j < n.length; j++) {\n                N.push.apply(N, expand_(n[j], false));\n            }\n        }\n        for (let j = 0; j < N.length; j++) {\n            for (let k = 0; k < post.length; k++) {\n                const expansion = pre + N[j] + post[k];\n                if (!isTop || isSequence || expansion) {\n                    expansions.push(expansion);\n                }\n            }\n        }\n    }\n    return expansions;\n}\n//# sourceMappingURL=index.js.map","const MAX_PATTERN_LENGTH = 1024 * 64;\nexport const assertValidPattern = (pattern) => {\n    if (typeof pattern !== 'string') {\n        throw new TypeError('invalid pattern');\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError('pattern is too long');\n    }\n};\n//# sourceMappingURL=assert-valid-pattern.js.map","// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n    '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n    '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n    '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n    '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n    '[:cntrl:]': ['\\\\p{Cc}', true],\n    '[:digit:]': ['\\\\p{Nd}', true],\n    '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n    '[:lower:]': ['\\\\p{Ll}', true],\n    '[:print:]': ['\\\\p{C}', true],\n    '[:punct:]': ['\\\\p{P}', true],\n    '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n    '[:upper:]': ['\\\\p{Lu}', true],\n    '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n    '[:xdigit:]': ['A-Fa-f0-9', false],\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s) => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges) => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (glob, position) => {\n    const pos = position;\n    /* c8 ignore start */\n    if (glob.charAt(pos) !== '[') {\n        throw new Error('not in a brace expression');\n    }\n    /* c8 ignore stop */\n    const ranges = [];\n    const negs = [];\n    let i = pos + 1;\n    let sawStart = false;\n    let uflag = false;\n    let escaping = false;\n    let negate = false;\n    let endPos = pos;\n    let rangeStart = '';\n    WHILE: while (i < glob.length) {\n        const c = glob.charAt(i);\n        if ((c === '!' || c === '^') && i === pos + 1) {\n            negate = true;\n            i++;\n            continue;\n        }\n        if (c === ']' && sawStart && !escaping) {\n            endPos = i + 1;\n            break;\n        }\n        sawStart = true;\n        if (c === '\\\\') {\n            if (!escaping) {\n                escaping = true;\n                i++;\n                continue;\n            }\n            // escaped \\ char, fall through and treat like normal char\n        }\n        if (c === '[' && !escaping) {\n            // either a posix class, a collation equivalent, or just a [\n            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n                if (glob.startsWith(cls, i)) {\n                    // invalid, [a-[] is fine, but not [a-[:alpha]]\n                    if (rangeStart) {\n                        return ['$.', false, glob.length - pos, true];\n                    }\n                    i += cls.length;\n                    if (neg)\n                        negs.push(unip);\n                    else\n                        ranges.push(unip);\n                    uflag = uflag || u;\n                    continue WHILE;\n                }\n            }\n        }\n        // now it's just a normal character, effectively\n        escaping = false;\n        if (rangeStart) {\n            // throw this range away if it's not valid, but others\n            // can still match.\n            if (c > rangeStart) {\n                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n            }\n            else if (c === rangeStart) {\n                ranges.push(braceEscape(c));\n            }\n            rangeStart = '';\n            i++;\n            continue;\n        }\n        // now might be the start of a range.\n        // can be either c-d or c-] or c<more...>] or c] at this point\n        if (glob.startsWith('-]', i + 1)) {\n            ranges.push(braceEscape(c + '-'));\n            i += 2;\n            continue;\n        }\n        if (glob.startsWith('-', i + 1)) {\n            rangeStart = c;\n            i += 2;\n            continue;\n        }\n        // not the start of a range, just a single character\n        ranges.push(braceEscape(c));\n        i++;\n    }\n    if (endPos < i) {\n        // didn't see the end of the class, not a valid class,\n        // but might still be valid as a literal match.\n        return ['', false, 0, false];\n    }\n    // if we got no ranges and no negates, then we have a range that\n    // cannot possibly match anything, and that poisons the whole glob\n    if (!ranges.length && !negs.length) {\n        return ['$.', false, glob.length - pos, true];\n    }\n    // if we got one positive range, and it's a single character, then that's\n    // not actually a magic pattern, it's just that one literal character.\n    // we should not treat that as \"magic\", we should just return the literal\n    // character. [_] is a perfectly valid way to escape glob magic chars.\n    if (negs.length === 0 &&\n        ranges.length === 1 &&\n        /^\\\\?.$/.test(ranges[0]) &&\n        !negate) {\n        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n        return [regexpEscape(r), false, endPos - pos, false];\n    }\n    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n    const comb = ranges.length && negs.length\n        ? '(' + sranges + '|' + snegs + ')'\n        : ranges.length\n            ? sranges\n            : snegs;\n    return [comb, uflag, endPos - pos, true];\n};\n//# sourceMappingURL=brace-expressions.js.map","/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link MinimatchOptions.windowsPathsNoEscape} option is used, then\n * square-bracket escapes are removed, but not backslash escapes.\n *\n * For example, it will turn the string `'[*]'` into `*`, but it will not\n * turn `'\\\\*'` into `'*'`, because `\\` is a path separator in\n * `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both square-bracket escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n *\n * When `magicalBraces` is not set, escapes of braces (`{` and `}`) will not be\n * unescaped.\n */\nexport const unescape = (s, { windowsPathsNoEscape = false, magicalBraces = true, } = {}) => {\n    if (magicalBraces) {\n        return windowsPathsNoEscape\n            ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n            : s\n                .replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2')\n                .replace(/\\\\([^\\/])/g, '$1');\n    }\n    return windowsPathsNoEscape\n        ? s.replace(/\\[([^\\/\\\\{}])\\]/g, '$1')\n        : s\n            .replace(/((?!\\\\).|^)\\[([^\\/\\\\{}])\\]/g, '$1$2')\n            .replace(/\\\\([^\\/{}])/g, '$1');\n};\n//# sourceMappingURL=unescape.js.map","// parse a single path portion\nimport { parseClass } from './brace-expressions.js';\nimport { unescape } from './unescape.js';\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = (c) => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nexport class AST {\n    type;\n    #root;\n    #hasMagic;\n    #uflag = false;\n    #parts = [];\n    #parent;\n    #parentIndex;\n    #negs;\n    #filledNegs = false;\n    #options;\n    #toString;\n    // set to true if it's an extglob with no children\n    // (which really means one child of '')\n    #emptyExt = false;\n    constructor(type, parent, options = {}) {\n        this.type = type;\n        // extglobs are inherently magical\n        if (type)\n            this.#hasMagic = true;\n        this.#parent = parent;\n        this.#root = this.#parent ? this.#parent.#root : this;\n        this.#options = this.#root === this ? options : this.#root.#options;\n        this.#negs = this.#root === this ? [] : this.#root.#negs;\n        if (type === '!' && !this.#root.#filledNegs)\n            this.#negs.push(this);\n        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n    }\n    get hasMagic() {\n        /* c8 ignore start */\n        if (this.#hasMagic !== undefined)\n            return this.#hasMagic;\n        /* c8 ignore stop */\n        for (const p of this.#parts) {\n            if (typeof p === 'string')\n                continue;\n            if (p.type || p.hasMagic)\n                return (this.#hasMagic = true);\n        }\n        // note: will be undefined until we generate the regexp src and find out\n        return this.#hasMagic;\n    }\n    // reconstructs the pattern\n    toString() {\n        if (this.#toString !== undefined)\n            return this.#toString;\n        if (!this.type) {\n            return (this.#toString = this.#parts.map(p => String(p)).join(''));\n        }\n        else {\n            return (this.#toString =\n                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');\n        }\n    }\n    #fillNegs() {\n        /* c8 ignore start */\n        if (this !== this.#root)\n            throw new Error('should only call on root');\n        if (this.#filledNegs)\n            return this;\n        /* c8 ignore stop */\n        // call toString() once to fill this out\n        this.toString();\n        this.#filledNegs = true;\n        let n;\n        while ((n = this.#negs.pop())) {\n            if (n.type !== '!')\n                continue;\n            // walk up the tree, appending everthing that comes AFTER parentIndex\n            let p = n;\n            let pp = p.#parent;\n            while (pp) {\n                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n                    for (const part of n.#parts) {\n                        /* c8 ignore start */\n                        if (typeof part === 'string') {\n                            throw new Error('string part in extglob AST??');\n                        }\n                        /* c8 ignore stop */\n                        part.copyIn(pp.#parts[i]);\n                    }\n                }\n                p = pp;\n                pp = p.#parent;\n            }\n        }\n        return this;\n    }\n    push(...parts) {\n        for (const p of parts) {\n            if (p === '')\n                continue;\n            /* c8 ignore start */\n            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n                throw new Error('invalid part: ' + p);\n            }\n            /* c8 ignore stop */\n            this.#parts.push(p);\n        }\n    }\n    toJSON() {\n        const ret = this.type === null\n            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n            : [this.type, ...this.#parts.map(p => p.toJSON())];\n        if (this.isStart() && !this.type)\n            ret.unshift([]);\n        if (this.isEnd() &&\n            (this === this.#root ||\n                (this.#root.#filledNegs && this.#parent?.type === '!'))) {\n            ret.push({});\n        }\n        return ret;\n    }\n    isStart() {\n        if (this.#root === this)\n            return true;\n        // if (this.type) return !!this.#parent?.isStart()\n        if (!this.#parent?.isStart())\n            return false;\n        if (this.#parentIndex === 0)\n            return true;\n        // if everything AHEAD of this is a negation, then it's still the \"start\"\n        const p = this.#parent;\n        for (let i = 0; i < this.#parentIndex; i++) {\n            const pp = p.#parts[i];\n            if (!(pp instanceof AST && pp.type === '!')) {\n                return false;\n            }\n        }\n        return true;\n    }\n    isEnd() {\n        if (this.#root === this)\n            return true;\n        if (this.#parent?.type === '!')\n            return true;\n        if (!this.#parent?.isEnd())\n            return false;\n        if (!this.type)\n            return this.#parent?.isEnd();\n        // if not root, it'll always have a parent\n        /* c8 ignore start */\n        const pl = this.#parent ? this.#parent.#parts.length : 0;\n        /* c8 ignore stop */\n        return this.#parentIndex === pl - 1;\n    }\n    copyIn(part) {\n        if (typeof part === 'string')\n            this.push(part);\n        else\n            this.push(part.clone(this));\n    }\n    clone(parent) {\n        const c = new AST(this.type, parent);\n        for (const p of this.#parts) {\n            c.copyIn(p);\n        }\n        return c;\n    }\n    static #parseAST(str, ast, pos, opt) {\n        let escaping = false;\n        let inBrace = false;\n        let braceStart = -1;\n        let braceNeg = false;\n        if (ast.type === null) {\n            // outside of a extglob, append until we find a start\n            let i = pos;\n            let acc = '';\n            while (i < str.length) {\n                const c = str.charAt(i++);\n                // still accumulate escapes at this point, but we do ignore\n                // starts that are escaped\n                if (escaping || c === '\\\\') {\n                    escaping = !escaping;\n                    acc += c;\n                    continue;\n                }\n                if (inBrace) {\n                    if (i === braceStart + 1) {\n                        if (c === '^' || c === '!') {\n                            braceNeg = true;\n                        }\n                    }\n                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                        inBrace = false;\n                    }\n                    acc += c;\n                    continue;\n                }\n                else if (c === '[') {\n                    inBrace = true;\n                    braceStart = i;\n                    braceNeg = false;\n                    acc += c;\n                    continue;\n                }\n                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n                    ast.push(acc);\n                    acc = '';\n                    const ext = new AST(c, ast);\n                    i = AST.#parseAST(str, ext, i, opt);\n                    ast.push(ext);\n                    continue;\n                }\n                acc += c;\n            }\n            ast.push(acc);\n            return i;\n        }\n        // some kind of extglob, pos is at the (\n        // find the next | or )\n        let i = pos + 1;\n        let part = new AST(null, ast);\n        const parts = [];\n        let acc = '';\n        while (i < str.length) {\n            const c = str.charAt(i++);\n            // still accumulate escapes at this point, but we do ignore\n            // starts that are escaped\n            if (escaping || c === '\\\\') {\n                escaping = !escaping;\n                acc += c;\n                continue;\n            }\n            if (inBrace) {\n                if (i === braceStart + 1) {\n                    if (c === '^' || c === '!') {\n                        braceNeg = true;\n                    }\n                }\n                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n                    inBrace = false;\n                }\n                acc += c;\n                continue;\n            }\n            else if (c === '[') {\n                inBrace = true;\n                braceStart = i;\n                braceNeg = false;\n                acc += c;\n                continue;\n            }\n            if (isExtglobType(c) && str.charAt(i) === '(') {\n                part.push(acc);\n                acc = '';\n                const ext = new AST(c, part);\n                part.push(ext);\n                i = AST.#parseAST(str, ext, i, opt);\n                continue;\n            }\n            if (c === '|') {\n                part.push(acc);\n                acc = '';\n                parts.push(part);\n                part = new AST(null, ast);\n                continue;\n            }\n            if (c === ')') {\n                if (acc === '' && ast.#parts.length === 0) {\n                    ast.#emptyExt = true;\n                }\n                part.push(acc);\n                acc = '';\n                ast.push(...parts, part);\n                return i;\n            }\n            acc += c;\n        }\n        // unfinished extglob\n        // if we got here, it was a malformed extglob! not an extglob, but\n        // maybe something else in there.\n        ast.type = null;\n        ast.#hasMagic = undefined;\n        ast.#parts = [str.substring(pos - 1)];\n        return i;\n    }\n    static fromGlob(pattern, options = {}) {\n        const ast = new AST(null, undefined, options);\n        AST.#parseAST(pattern, ast, 0, options);\n        return ast;\n    }\n    // returns the regular expression if there's magic, or the unescaped\n    // string if not.\n    toMMPattern() {\n        // should only be called on root\n        /* c8 ignore start */\n        if (this !== this.#root)\n            return this.#root.toMMPattern();\n        /* c8 ignore stop */\n        const glob = this.toString();\n        const [re, body, hasMagic, uflag] = this.toRegExpSource();\n        // if we're in nocase mode, and not nocaseMagicOnly, then we do\n        // still need a regular expression if we have to case-insensitively\n        // match capital/lowercase characters.\n        const anyMagic = hasMagic ||\n            this.#hasMagic ||\n            (this.#options.nocase &&\n                !this.#options.nocaseMagicOnly &&\n                glob.toUpperCase() !== glob.toLowerCase());\n        if (!anyMagic) {\n            return body;\n        }\n        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n        return Object.assign(new RegExp(`^${re}$`, flags), {\n            _src: re,\n            _glob: glob,\n        });\n    }\n    get options() {\n        return this.#options;\n    }\n    // returns the string match, the regexp source, whether there's magic\n    // in the regexp (so a regular expression is required) and whether or\n    // not the uflag is needed for the regular expression (for posix classes)\n    // TODO: instead of injecting the start/end at this point, just return\n    // the BODY of the regexp, along with the start/end portions suitable\n    // for binding the start/end in either a joined full-path makeRe context\n    // (where we bind to (^|/), or a standalone matchPart context (where\n    // we bind to ^, and not /).  Otherwise slashes get duped!\n    //\n    // In part-matching mode, the start is:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n    // - if dots allowed or not possible: ^\n    // - if dots possible and not allowed: ^(?!\\.)\n    // end is:\n    // - if not isEnd(): nothing\n    // - else: $\n    //\n    // In full-path matching mode, we put the slash at the START of the\n    // pattern, so start is:\n    // - if first pattern: same as part-matching mode\n    // - if not isStart(): nothing\n    // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n    // - if dots allowed or not possible: /\n    // - if dots possible and not allowed: /(?!\\.)\n    // end is:\n    // - if last pattern, same as part-matching mode\n    // - else nothing\n    //\n    // Always put the (?:$|/) on negated tails, though, because that has to be\n    // there to bind the end of the negated pattern portion, and it's easier to\n    // just stick it in now rather than try to inject it later in the middle of\n    // the pattern.\n    //\n    // We can just always return the same end, and leave it up to the caller\n    // to know whether it's going to be used joined or in parts.\n    // And, if the start is adjusted slightly, can do the same there:\n    // - if not isStart: nothing\n    // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n    // - if dots allowed or not possible: (?:/|^)\n    // - if dots possible and not allowed: (?:/|^)(?!\\.)\n    //\n    // But it's better to have a simpler binding without a conditional, for\n    // performance, so probably better to return both start options.\n    //\n    // Then the caller just ignores the end if it's not the first pattern,\n    // and the start always gets applied.\n    //\n    // But that's always going to be $ if it's the ending pattern, or nothing,\n    // so the caller can just attach $ at the end of the pattern when building.\n    //\n    // So the todo is:\n    // - better detect what kind of start is needed\n    // - return both flavors of starting pattern\n    // - attach $ at the end of the pattern when creating the actual RegExp\n    //\n    // Ah, but wait, no, that all only applies to the root when the first pattern\n    // is not an extglob. If the first pattern IS an extglob, then we need all\n    // that dot prevention biz to live in the extglob portions, because eg\n    // +(*|.x*) can match .xy but not .yx.\n    //\n    // So, return the two flavors if it's #root and the first child is not an\n    // AST, otherwise leave it to the child AST to handle it, and there,\n    // use the (?:^|/) style of start binding.\n    //\n    // Even simplified further:\n    // - Since the start for a join is eg /(?!\\.) and the start for a part\n    // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n    // or start or whatever) and prepend ^ or / at the Regexp construction.\n    toRegExpSource(allowDot) {\n        const dot = allowDot ?? !!this.#options.dot;\n        if (this.#root === this)\n            this.#fillNegs();\n        if (!this.type) {\n            const noEmpty = this.isStart() &&\n                this.isEnd() &&\n                !this.#parts.some(s => typeof s !== 'string');\n            const src = this.#parts\n                .map(p => {\n                const [re, _, hasMagic, uflag] = typeof p === 'string'\n                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n                    : p.toRegExpSource(allowDot);\n                this.#hasMagic = this.#hasMagic || hasMagic;\n                this.#uflag = this.#uflag || uflag;\n                return re;\n            })\n                .join('');\n            let start = '';\n            if (this.isStart()) {\n                if (typeof this.#parts[0] === 'string') {\n                    // this is the string that will match the start of the pattern,\n                    // so we need to protect against dots and such.\n                    // '.' and '..' cannot match unless the pattern is that exactly,\n                    // even if it starts with . or dot:true is set.\n                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n                    if (!dotTravAllowed) {\n                        const aps = addPatternStart;\n                        // check if we have a possibility of matching . or ..,\n                        // and prevent that.\n                        const needNoTrav = \n                        // dots are allowed, and the pattern starts with [ or .\n                        (dot && aps.has(src.charAt(0))) ||\n                            // the pattern starts with \\., and then [ or .\n                            (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n                            // the pattern starts with \\.\\., and then [ or .\n                            (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)));\n                        // no need to prevent dots if it can't match a dot, or if a\n                        // sub-pattern will be preventing it anyway.\n                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n                    }\n                }\n            }\n            // append the \"end of path portion\" pattern to negation tails\n            let end = '';\n            if (this.isEnd() &&\n                this.#root.#filledNegs &&\n                this.#parent?.type === '!') {\n                end = '(?:$|\\\\/)';\n            }\n            const final = start + src + end;\n            return [\n                final,\n                unescape(src),\n                (this.#hasMagic = !!this.#hasMagic),\n                this.#uflag,\n            ];\n        }\n        // We need to calculate the body *twice* if it's a repeat pattern\n        // at the start, once in nodot mode, then again in dot mode, so a\n        // pattern like *(?) can match 'x.y'\n        const repeated = this.type === '*' || this.type === '+';\n        // some kind of extglob\n        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n        let body = this.#partsToRegExp(dot);\n        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n            // invalid extglob, has to at least be *something* present, if it's\n            // the entire path portion.\n            const s = this.toString();\n            this.#parts = [s];\n            this.type = null;\n            this.#hasMagic = undefined;\n            return [s, unescape(this.toString()), false, false];\n        }\n        // XXX abstract out this map method\n        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot\n            ? ''\n            : this.#partsToRegExp(true);\n        if (bodyDotAllowed === body) {\n            bodyDotAllowed = '';\n        }\n        if (bodyDotAllowed) {\n            body = `(?:${body})(?:${bodyDotAllowed})*?`;\n        }\n        // an empty !() is exactly equivalent to a starNoEmpty\n        let final = '';\n        if (this.type === '!' && this.#emptyExt) {\n            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n        }\n        else {\n            const close = this.type === '!'\n                ? // !() must match something,but !(x) can match ''\n                    '))' +\n                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n                        star +\n                        ')'\n                : this.type === '@'\n                    ? ')'\n                    : this.type === '?'\n                        ? ')?'\n                        : this.type === '+' && bodyDotAllowed\n                            ? ')'\n                            : this.type === '*' && bodyDotAllowed\n                                ? `)?`\n                                : `)${this.type}`;\n            final = start + body + close;\n        }\n        return [\n            final,\n            unescape(body),\n            (this.#hasMagic = !!this.#hasMagic),\n            this.#uflag,\n        ];\n    }\n    #partsToRegExp(dot) {\n        return this.#parts\n            .map(p => {\n            // extglob ASTs should only contain parent ASTs\n            /* c8 ignore start */\n            if (typeof p === 'string') {\n                throw new Error('string type in extglob ast??');\n            }\n            /* c8 ignore stop */\n            // can ignore hasMagic, because extglobs are already always magic\n            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n            this.#uflag = this.#uflag || uflag;\n            return re;\n        })\n            .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n            .join('|');\n    }\n    static #parseGlob(glob, hasMagic, noEmpty = false) {\n        let escaping = false;\n        let re = '';\n        let uflag = false;\n        for (let i = 0; i < glob.length; i++) {\n            const c = glob.charAt(i);\n            if (escaping) {\n                escaping = false;\n                re += (reSpecials.has(c) ? '\\\\' : '') + c;\n                continue;\n            }\n            if (c === '\\\\') {\n                if (i === glob.length - 1) {\n                    re += '\\\\\\\\';\n                }\n                else {\n                    escaping = true;\n                }\n                continue;\n            }\n            if (c === '[') {\n                const [src, needUflag, consumed, magic] = parseClass(glob, i);\n                if (consumed) {\n                    re += src;\n                    uflag = uflag || needUflag;\n                    i += consumed - 1;\n                    hasMagic = hasMagic || magic;\n                    continue;\n                }\n            }\n            if (c === '*') {\n                re += noEmpty && glob === '*' ? starNoEmpty : star;\n                hasMagic = true;\n                continue;\n            }\n            if (c === '?') {\n                re += qmark;\n                hasMagic = true;\n                continue;\n            }\n            re += regExpEscape(c);\n        }\n        return [re, unescape(glob), !!hasMagic, uflag];\n    }\n}\n//# sourceMappingURL=ast.js.map","/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link MinimatchOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n *\n * If the {@link MinimatchOptions.magicalBraces} option is used,\n * then braces (`{` and `}`) will be escaped.\n */\nexport const escape = (s, { windowsPathsNoEscape = false, magicalBraces = false, } = {}) => {\n    // don't need to escape +@! because we escape the parens\n    // that make those magic, and escaping ! as [!] isn't valid,\n    // because [!]] is a valid glob class meaning not ']'.\n    if (magicalBraces) {\n        return windowsPathsNoEscape\n            ? s.replace(/[?*()[\\]{}]/g, '[$&]')\n            : s.replace(/[?*()[\\]\\\\{}]/g, '\\\\$&');\n    }\n    return windowsPathsNoEscape\n        ? s.replace(/[?*()[\\]]/g, '[$&]')\n        : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&');\n};\n//# sourceMappingURL=escape.js.map","import { expand } from '@isaacs/brace-expansion';\nimport { assertValidPattern } from './assert-valid-pattern.js';\nimport { AST } from './ast.js';\nimport { escape } from './escape.js';\nimport { unescape } from './unescape.js';\nexport const minimatch = (p, pattern, options = {}) => {\n    assertValidPattern(pattern);\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n};\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = (ext) => (f) => f.endsWith(ext);\nconst starDotExtTestNocase = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = (ext) => {\n    ext = ext.toLowerCase();\n    return (f) => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = (f) => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    if (!ext)\n        return noext;\n    ext = ext.toLowerCase();\n    return (f) => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExtDot([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n    const noext = qmarksTestNoExt([$0]);\n    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n    const len = $0.length;\n    return (f) => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = (typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n        process.platform\n    : 'posix');\nconst path = {\n    win32: { sep: '\\\\' },\n    posix: { sep: '/' },\n};\n/* c8 ignore stop */\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nminimatch.sep = sep;\nexport const GLOBSTAR = Symbol('globstar **');\nminimatch.GLOBSTAR = GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nexport const filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);\nminimatch.filter = filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nexport const defaults = (def) => {\n    if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n        return minimatch;\n    }\n    const orig = minimatch;\n    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n    return Object.assign(m, {\n        Minimatch: class Minimatch extends orig.Minimatch {\n            constructor(pattern, options = {}) {\n                super(pattern, ext(def, options));\n            }\n            static defaults(options) {\n                return orig.defaults(ext(def, options)).Minimatch;\n            }\n        },\n        AST: class AST extends orig.AST {\n            /* c8 ignore start */\n            constructor(type, parent, options = {}) {\n                super(type, parent, ext(def, options));\n            }\n            /* c8 ignore stop */\n            static fromGlob(pattern, options = {}) {\n                return orig.AST.fromGlob(pattern, ext(def, options));\n            }\n        },\n        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n        escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n        defaults: (options) => orig.defaults(ext(def, options)),\n        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n        sep: orig.sep,\n        GLOBSTAR: GLOBSTAR,\n    });\n};\nminimatch.defaults = defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (pattern, options = {}) => {\n    assertValidPattern(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [pattern];\n    }\n    return expand(pattern);\n};\nminimatch.braceExpand = braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nexport const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nminimatch.makeRe = makeRe;\nexport const match = (list, pattern, options = {}) => {\n    const mm = new Minimatch(pattern, options);\n    list = list.filter(f => mm.match(f));\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nminimatch.match = match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = (s) => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nexport class Minimatch {\n    options;\n    set;\n    pattern;\n    windowsPathsNoEscape;\n    nonegate;\n    negate;\n    comment;\n    empty;\n    preserveMultipleSlashes;\n    partial;\n    globSet;\n    globParts;\n    nocase;\n    isWindows;\n    platform;\n    windowsNoMagicRoot;\n    regexp;\n    constructor(pattern, options = {}) {\n        assertValidPattern(pattern);\n        options = options || {};\n        this.options = options;\n        this.pattern = pattern;\n        this.platform = options.platform || defaultPlatform;\n        this.isWindows = this.platform === 'win32';\n        this.windowsPathsNoEscape =\n            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n        if (this.windowsPathsNoEscape) {\n            this.pattern = this.pattern.replace(/\\\\/g, '/');\n        }\n        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n        this.regexp = null;\n        this.negate = false;\n        this.nonegate = !!options.nonegate;\n        this.comment = false;\n        this.empty = false;\n        this.partial = !!options.partial;\n        this.nocase = !!this.options.nocase;\n        this.windowsNoMagicRoot =\n            options.windowsNoMagicRoot !== undefined\n                ? options.windowsNoMagicRoot\n                : !!(this.isWindows && this.nocase);\n        this.globSet = [];\n        this.globParts = [];\n        this.set = [];\n        // make the set of regexps etc.\n        this.make();\n    }\n    hasMagic() {\n        if (this.options.magicalBraces && this.set.length > 1) {\n            return true;\n        }\n        for (const pattern of this.set) {\n            for (const part of pattern) {\n                if (typeof part !== 'string')\n                    return true;\n            }\n        }\n        return false;\n    }\n    debug(..._) { }\n    make() {\n        const pattern = this.pattern;\n        const options = this.options;\n        // empty patterns and comments match nothing.\n        if (!options.nocomment && pattern.charAt(0) === '#') {\n            this.comment = true;\n            return;\n        }\n        if (!pattern) {\n            this.empty = true;\n            return;\n        }\n        // step 1: figure out negation, etc.\n        this.parseNegate();\n        // step 2: expand braces\n        this.globSet = [...new Set(this.braceExpand())];\n        if (options.debug) {\n            this.debug = (...args) => console.error(...args);\n        }\n        this.debug(this.pattern, this.globSet);\n        // step 3: now we have a set, so turn each one into a series of\n        // path-portion matching patterns.\n        // These will be regexps, except in the case of \"**\", which is\n        // set to the GLOBSTAR object for globstar behavior,\n        // and will not contain any / characters\n        //\n        // First, we preprocess to make the glob pattern sets a bit simpler\n        // and deduped.  There are some perf-killing patterns that can cause\n        // problems with a glob walk, but we can simplify them down a bit.\n        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n        this.globParts = this.preprocess(rawGlobParts);\n        this.debug(this.pattern, this.globParts);\n        // glob --> regexps\n        let set = this.globParts.map((s, _, __) => {\n            if (this.isWindows && this.windowsNoMagicRoot) {\n                // check if it's a drive or unc path.\n                const isUNC = s[0] === '' &&\n                    s[1] === '' &&\n                    (s[2] === '?' || !globMagic.test(s[2])) &&\n                    !globMagic.test(s[3]);\n                const isDrive = /^[a-z]:/i.test(s[0]);\n                if (isUNC) {\n                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n                }\n                else if (isDrive) {\n                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n                }\n            }\n            return s.map(ss => this.parse(ss));\n        });\n        this.debug(this.pattern, set);\n        // filter out everything that didn't compile properly.\n        this.set = set.filter(s => s.indexOf(false) === -1);\n        // do not treat the ? in UNC paths as magic\n        if (this.isWindows) {\n            for (let i = 0; i < this.set.length; i++) {\n                const p = this.set[i];\n                if (p[0] === '' &&\n                    p[1] === '' &&\n                    this.globParts[i][2] === '?' &&\n                    typeof p[3] === 'string' &&\n                    /^[a-z]:$/i.test(p[3])) {\n                    p[2] = '?';\n                }\n            }\n        }\n        this.debug(this.pattern, this.set);\n    }\n    // various transforms to equivalent pattern sets that are\n    // faster to process in a filesystem walk.  The goal is to\n    // eliminate what we can, and push all ** patterns as far\n    // to the right as possible, even if it increases the number\n    // of patterns that we have to process.\n    preprocess(globParts) {\n        // if we're not in globstar mode, then turn all ** into *\n        if (this.options.noglobstar) {\n            for (let i = 0; i < globParts.length; i++) {\n                for (let j = 0; j < globParts[i].length; j++) {\n                    if (globParts[i][j] === '**') {\n                        globParts[i][j] = '*';\n                    }\n                }\n            }\n        }\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            // aggressive optimization for the purpose of fs walking\n            globParts = this.firstPhasePreProcess(globParts);\n            globParts = this.secondPhasePreProcess(globParts);\n        }\n        else if (optimizationLevel >= 1) {\n            // just basic optimizations to remove some .. parts\n            globParts = this.levelOneOptimize(globParts);\n        }\n        else {\n            // just collapse multiple ** portions into one\n            globParts = this.adjascentGlobstarOptimize(globParts);\n        }\n        return globParts;\n    }\n    // just get rid of adjascent ** portions\n    adjascentGlobstarOptimize(globParts) {\n        return globParts.map(parts => {\n            let gs = -1;\n            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                let i = gs;\n                while (parts[i + 1] === '**') {\n                    i++;\n                }\n                if (i !== gs) {\n                    parts.splice(gs, i - gs);\n                }\n            }\n            return parts;\n        });\n    }\n    // get rid of adjascent ** and resolve .. portions\n    levelOneOptimize(globParts) {\n        return globParts.map(parts => {\n            parts = parts.reduce((set, part) => {\n                const prev = set[set.length - 1];\n                if (part === '**' && prev === '**') {\n                    return set;\n                }\n                if (part === '..') {\n                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n                        set.pop();\n                        return set;\n                    }\n                }\n                set.push(part);\n                return set;\n            }, []);\n            return parts.length === 0 ? [''] : parts;\n        });\n    }\n    levelTwoFileOptimize(parts) {\n        if (!Array.isArray(parts)) {\n            parts = this.slashSplit(parts);\n        }\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/<e>/<rest> -> <pre>/<rest>\n            if (!this.preserveMultipleSlashes) {\n                for (let i = 1; i < parts.length - 1; i++) {\n                    const p = parts[i];\n                    // don't squeeze out UNC patterns\n                    if (i === 1 && p === '' && parts[0] === '')\n                        continue;\n                    if (p === '.' || p === '') {\n                        didSomething = true;\n                        parts.splice(i, 1);\n                        i--;\n                    }\n                }\n                if (parts[0] === '.' &&\n                    parts.length === 2 &&\n                    (parts[1] === '.' || parts[1] === '')) {\n                    didSomething = true;\n                    parts.pop();\n                }\n            }\n            // <pre>/<p>/../<rest> -> <pre>/<rest>\n            let dd = 0;\n            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                const p = parts[dd - 1];\n                if (p && p !== '.' && p !== '..' && p !== '**') {\n                    didSomething = true;\n                    parts.splice(dd - 1, 2);\n                    dd -= 2;\n                }\n            }\n        } while (didSomething);\n        return parts.length === 0 ? [''] : parts;\n    }\n    // First phase: single-pattern processing\n    // <pre> is 1 or more portions\n    // <rest> is 1 or more portions\n    // <p> is any portion other than ., .., '', or **\n    // <e> is . or ''\n    //\n    // **/.. is *brutal* for filesystem walking performance, because\n    // it effectively resets the recursive walk each time it occurs,\n    // and ** cannot be reduced out by a .. pattern part like a regexp\n    // or most strings (other than .., ., and '') can be.\n    //\n    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n    // <pre>/<e>/<rest> -> <pre>/<rest>\n    // <pre>/<p>/../<rest> -> <pre>/<rest>\n    // **/**/<rest> -> **/<rest>\n    //\n    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n    // this WOULD be allowed if ** did follow symlinks, or * didn't\n    firstPhasePreProcess(globParts) {\n        let didSomething = false;\n        do {\n            didSomething = false;\n            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n            for (let parts of globParts) {\n                let gs = -1;\n                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n                    let gss = gs;\n                    while (parts[gss + 1] === '**') {\n                        // <pre>/**/**/<rest> -> <pre>/**/<rest>\n                        gss++;\n                    }\n                    // eg, if gs is 2 and gss is 4, that means we have 3 **\n                    // parts, and can remove 2 of them.\n                    if (gss > gs) {\n                        parts.splice(gs + 1, gss - gs);\n                    }\n                    let next = parts[gs + 1];\n                    const p = parts[gs + 2];\n                    const p2 = parts[gs + 3];\n                    if (next !== '..')\n                        continue;\n                    if (!p ||\n                        p === '.' ||\n                        p === '..' ||\n                        !p2 ||\n                        p2 === '.' ||\n                        p2 === '..') {\n                        continue;\n                    }\n                    didSomething = true;\n                    // edit parts in place, and push the new one\n                    parts.splice(gs, 1);\n                    const other = parts.slice(0);\n                    other[gs] = '**';\n                    globParts.push(other);\n                    gs--;\n                }\n                // <pre>/<e>/<rest> -> <pre>/<rest>\n                if (!this.preserveMultipleSlashes) {\n                    for (let i = 1; i < parts.length - 1; i++) {\n                        const p = parts[i];\n                        // don't squeeze out UNC patterns\n                        if (i === 1 && p === '' && parts[0] === '')\n                            continue;\n                        if (p === '.' || p === '') {\n                            didSomething = true;\n                            parts.splice(i, 1);\n                            i--;\n                        }\n                    }\n                    if (parts[0] === '.' &&\n                        parts.length === 2 &&\n                        (parts[1] === '.' || parts[1] === '')) {\n                        didSomething = true;\n                        parts.pop();\n                    }\n                }\n                // <pre>/<p>/../<rest> -> <pre>/<rest>\n                let dd = 0;\n                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n                    const p = parts[dd - 1];\n                    if (p && p !== '.' && p !== '..' && p !== '**') {\n                        didSomething = true;\n                        const needDot = dd === 1 && parts[dd + 1] === '**';\n                        const splin = needDot ? ['.'] : [];\n                        parts.splice(dd - 1, 2, ...splin);\n                        if (parts.length === 0)\n                            parts.push('');\n                        dd -= 2;\n                    }\n                }\n            }\n        } while (didSomething);\n        return globParts;\n    }\n    // second phase: multi-pattern dedupes\n    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n    //\n    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n    // ^-- not valid because ** doens't follow symlinks\n    secondPhasePreProcess(globParts) {\n        for (let i = 0; i < globParts.length - 1; i++) {\n            for (let j = i + 1; j < globParts.length; j++) {\n                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n                if (matched) {\n                    globParts[i] = [];\n                    globParts[j] = matched;\n                    break;\n                }\n            }\n        }\n        return globParts.filter(gs => gs.length);\n    }\n    partsMatch(a, b, emptyGSMatch = false) {\n        let ai = 0;\n        let bi = 0;\n        let result = [];\n        let which = '';\n        while (ai < a.length && bi < b.length) {\n            if (a[ai] === b[bi]) {\n                result.push(which === 'b' ? b[bi] : a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n                result.push(a[ai]);\n                ai++;\n            }\n            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n                result.push(b[bi]);\n                bi++;\n            }\n            else if (a[ai] === '*' &&\n                b[bi] &&\n                (this.options.dot || !b[bi].startsWith('.')) &&\n                b[bi] !== '**') {\n                if (which === 'b')\n                    return false;\n                which = 'a';\n                result.push(a[ai]);\n                ai++;\n                bi++;\n            }\n            else if (b[bi] === '*' &&\n                a[ai] &&\n                (this.options.dot || !a[ai].startsWith('.')) &&\n                a[ai] !== '**') {\n                if (which === 'a')\n                    return false;\n                which = 'b';\n                result.push(b[bi]);\n                ai++;\n                bi++;\n            }\n            else {\n                return false;\n            }\n        }\n        // if we fall out of the loop, it means they two are identical\n        // as long as their lengths match\n        return a.length === b.length && result;\n    }\n    parseNegate() {\n        if (this.nonegate)\n            return;\n        const pattern = this.pattern;\n        let negate = false;\n        let negateOffset = 0;\n        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n            negate = !negate;\n            negateOffset++;\n        }\n        if (negateOffset)\n            this.pattern = pattern.slice(negateOffset);\n        this.negate = negate;\n    }\n    // set partial to true to test if, for example,\n    // \"/a/b\" matches the start of \"/*/b/*/d\"\n    // Partial means, if you run out of file before you run\n    // out of pattern, then that's fine, as long as all\n    // the parts match.\n    matchOne(file, pattern, partial = false) {\n        const options = this.options;\n        // UNC paths like //?/X:/... can match X:/... and vice versa\n        // Drive letters in absolute drive or unc paths are always compared\n        // case-insensitively.\n        if (this.isWindows) {\n            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n            const fileUNC = !fileDrive &&\n                file[0] === '' &&\n                file[1] === '' &&\n                file[2] === '?' &&\n                /^[a-z]:$/i.test(file[3]);\n            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n            const patternUNC = !patternDrive &&\n                pattern[0] === '' &&\n                pattern[1] === '' &&\n                pattern[2] === '?' &&\n                typeof pattern[3] === 'string' &&\n                /^[a-z]:$/i.test(pattern[3]);\n            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n            if (typeof fdi === 'number' && typeof pdi === 'number') {\n                const [fd, pd] = [file[fdi], pattern[pdi]];\n                if (fd.toLowerCase() === pd.toLowerCase()) {\n                    pattern[pdi] = fd;\n                    if (pdi > fdi) {\n                        pattern = pattern.slice(pdi);\n                    }\n                    else if (fdi > pdi) {\n                        file = file.slice(fdi);\n                    }\n                }\n            }\n        }\n        // resolve and reduce . and .. portions in the file as well.\n        // don't need to do the second phase, because it's only one string[]\n        const { optimizationLevel = 1 } = this.options;\n        if (optimizationLevel >= 2) {\n            file = this.levelTwoFileOptimize(file);\n        }\n        this.debug('matchOne', this, { file, pattern });\n        this.debug('matchOne', file.length, pattern.length);\n        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n            this.debug('matchOne loop');\n            var p = pattern[pi];\n            var f = file[fi];\n            this.debug(pattern, p, f);\n            // should be impossible.\n            // some invalid regexp stuff in the set.\n            /* c8 ignore start */\n            if (p === false) {\n                return false;\n            }\n            /* c8 ignore stop */\n            if (p === GLOBSTAR) {\n                this.debug('GLOBSTAR', [pattern, p, f]);\n                // \"**\"\n                // a/**/b/**/c would match the following:\n                // a/b/x/y/z/c\n                // a/x/y/z/b/c\n                // a/b/x/b/x/c\n                // a/b/c\n                // To do this, take the rest of the pattern after\n                // the **, and see if it would match the file remainder.\n                // If so, return success.\n                // If not, the ** \"swallows\" a segment, and try again.\n                // This is recursively awful.\n                //\n                // a/**/b/**/c matching a/b/x/y/z/c\n                // - a matches a\n                // - doublestar\n                //   - matchOne(b/x/y/z/c, b/**/c)\n                //     - b matches b\n                //     - doublestar\n                //       - matchOne(x/y/z/c, c) -> no\n                //       - matchOne(y/z/c, c) -> no\n                //       - matchOne(z/c, c) -> no\n                //       - matchOne(c, c) yes, hit\n                var fr = fi;\n                var pr = pi + 1;\n                if (pr === pl) {\n                    this.debug('** at the end');\n                    // a ** at the end will just swallow the rest.\n                    // We have found a match.\n                    // however, it will not swallow /.x, unless\n                    // options.dot is set.\n                    // . and .. are *never* matched by **, for explosively\n                    // exponential reasons.\n                    for (; fi < fl; fi++) {\n                        if (file[fi] === '.' ||\n                            file[fi] === '..' ||\n                            (!options.dot && file[fi].charAt(0) === '.'))\n                            return false;\n                    }\n                    return true;\n                }\n                // ok, let's see if we can swallow whatever we can.\n                while (fr < fl) {\n                    var swallowee = file[fr];\n                    this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n                    // XXX remove this slice.  Just pass the start index.\n                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                        this.debug('globstar found match!', fr, fl, swallowee);\n                        // found a match.\n                        return true;\n                    }\n                    else {\n                        // can't swallow \".\" or \"..\" ever.\n                        // can only swallow \".foo\" when explicitly asked.\n                        if (swallowee === '.' ||\n                            swallowee === '..' ||\n                            (!options.dot && swallowee.charAt(0) === '.')) {\n                            this.debug('dot detected!', file, fr, pattern, pr);\n                            break;\n                        }\n                        // ** swallows a segment, and continue.\n                        this.debug('globstar swallow a segment, and continue');\n                        fr++;\n                    }\n                }\n                // no match was found.\n                // However, in partial mode, we can't say this is necessarily over.\n                /* c8 ignore start */\n                if (partial) {\n                    // ran out of file\n                    this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n                    if (fr === fl) {\n                        return true;\n                    }\n                }\n                /* c8 ignore stop */\n                return false;\n            }\n            // something other than **\n            // non-magic patterns just have to match exactly\n            // patterns with magic have been turned into regexps.\n            let hit;\n            if (typeof p === 'string') {\n                hit = f === p;\n                this.debug('string match', p, f, hit);\n            }\n            else {\n                hit = p.test(f);\n                this.debug('pattern match', p, f, hit);\n            }\n            if (!hit)\n                return false;\n        }\n        // Note: ending in / means that we'll get a final \"\"\n        // at the end of the pattern.  This can only match a\n        // corresponding \"\" at the end of the file.\n        // If the file ends in /, then it can only match a\n        // a pattern that ends in /, unless the pattern just\n        // doesn't have any more for it. But, a/b/ should *not*\n        // match \"a/b/*\", even though \"\" matches against the\n        // [^/]*? pattern, except in partial mode, where it might\n        // simply not be reached yet.\n        // However, a/b/ should still satisfy a/*\n        // now either we fell off the end of the pattern, or we're done.\n        if (fi === fl && pi === pl) {\n            // ran out of pattern and filename at the same time.\n            // an exact hit!\n            return true;\n        }\n        else if (fi === fl) {\n            // ran out of file, but still had pattern left.\n            // this is ok if we're doing the match as part of\n            // a glob fs traversal.\n            return partial;\n        }\n        else if (pi === pl) {\n            // ran out of pattern, still have file left.\n            // this is only acceptable if we're on the very last\n            // empty segment of a file with a trailing slash.\n            // a/* should match a/b/\n            return fi === fl - 1 && file[fi] === '';\n            /* c8 ignore start */\n        }\n        else {\n            // should be unreachable.\n            throw new Error('wtf?');\n        }\n        /* c8 ignore stop */\n    }\n    braceExpand() {\n        return braceExpand(this.pattern, this.options);\n    }\n    parse(pattern) {\n        assertValidPattern(pattern);\n        const options = this.options;\n        // shortcuts\n        if (pattern === '**')\n            return GLOBSTAR;\n        if (pattern === '')\n            return '';\n        // far and away, the most common glob pattern parts are\n        // *, *.*, and *.<ext>  Add a fast check method for those.\n        let m;\n        let fastTest = null;\n        if ((m = pattern.match(starRE))) {\n            fastTest = options.dot ? starTestDot : starTest;\n        }\n        else if ((m = pattern.match(starDotExtRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? starDotExtTestNocaseDot\n                    : starDotExtTestNocase\n                : options.dot\n                    ? starDotExtTestDot\n                    : starDotExtTest)(m[1]);\n        }\n        else if ((m = pattern.match(qmarksRE))) {\n            fastTest = (options.nocase\n                ? options.dot\n                    ? qmarksTestNocaseDot\n                    : qmarksTestNocase\n                : options.dot\n                    ? qmarksTestDot\n                    : qmarksTest)(m);\n        }\n        else if ((m = pattern.match(starDotStarRE))) {\n            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n        }\n        else if ((m = pattern.match(dotStarRE))) {\n            fastTest = dotStarTest;\n        }\n        const re = AST.fromGlob(pattern, this.options).toMMPattern();\n        if (fastTest && typeof re === 'object') {\n            // Avoids overriding in frozen environments\n            Reflect.defineProperty(re, 'test', { value: fastTest });\n        }\n        return re;\n    }\n    makeRe() {\n        if (this.regexp || this.regexp === false)\n            return this.regexp;\n        // at this point, this.set is a 2d array of partial\n        // pattern strings, or \"**\".\n        //\n        // It's better to use .match().  This function shouldn't\n        // be used, really, but it's pretty convenient sometimes,\n        // when you just want to work with a regex.\n        const set = this.set;\n        if (!set.length) {\n            this.regexp = false;\n            return this.regexp;\n        }\n        const options = this.options;\n        const twoStar = options.noglobstar\n            ? star\n            : options.dot\n                ? twoStarDot\n                : twoStarNoDot;\n        const flags = new Set(options.nocase ? ['i'] : []);\n        // regexpify non-globstar patterns\n        // if ** is only item, then we just do one twoStar\n        // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n        // if ** is last, append (\\/twoStar|) to previous\n        // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n        // then filter out GLOBSTAR symbols\n        let re = set\n            .map(pattern => {\n            const pp = pattern.map(p => {\n                if (p instanceof RegExp) {\n                    for (const f of p.flags.split(''))\n                        flags.add(f);\n                }\n                return typeof p === 'string'\n                    ? regExpEscape(p)\n                    : p === GLOBSTAR\n                        ? GLOBSTAR\n                        : p._src;\n            });\n            pp.forEach((p, i) => {\n                const next = pp[i + 1];\n                const prev = pp[i - 1];\n                if (p !== GLOBSTAR || prev === GLOBSTAR) {\n                    return;\n                }\n                if (prev === undefined) {\n                    if (next !== undefined && next !== GLOBSTAR) {\n                        pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n                    }\n                    else {\n                        pp[i] = twoStar;\n                    }\n                }\n                else if (next === undefined) {\n                    pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + ')?';\n                }\n                else if (next !== GLOBSTAR) {\n                    pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n                    pp[i + 1] = GLOBSTAR;\n                }\n            });\n            const filtered = pp.filter(p => p !== GLOBSTAR);\n            // For partial matches, we need to make the pattern match\n            // any prefix of the full path. We do this by generating\n            // alternative patterns that match progressively longer prefixes.\n            if (this.partial && filtered.length >= 1) {\n                const prefixes = [];\n                for (let i = 1; i <= filtered.length; i++) {\n                    prefixes.push(filtered.slice(0, i).join('/'));\n                }\n                return '(?:' + prefixes.join('|') + ')';\n            }\n            return filtered.join('/');\n        })\n            .join('|');\n        // need to wrap in parens if we had more than one thing with |,\n        // otherwise only the first will be anchored to ^ and the last to $\n        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n        // must match entire pattern\n        // ending in a * or ** will make it less strict.\n        re = '^' + open + re + close + '$';\n        // In partial mode, '/' should always match as it's a valid prefix for any pattern\n        if (this.partial) {\n            re = '^(?:\\\\/|' + open + re.slice(1, -1) + close + ')$';\n        }\n        // can match anything, as long as it's not this.\n        if (this.negate)\n            re = '^(?!' + re + ').+$';\n        try {\n            this.regexp = new RegExp(re, [...flags].join(''));\n            /* c8 ignore start */\n        }\n        catch (ex) {\n            // should be impossible\n            this.regexp = false;\n        }\n        /* c8 ignore stop */\n        return this.regexp;\n    }\n    slashSplit(p) {\n        // if p starts with // on windows, we preserve that\n        // so that UNC paths aren't broken.  Otherwise, any number of\n        // / characters are coalesced into one, unless\n        // preserveMultipleSlashes is set to true.\n        if (this.preserveMultipleSlashes) {\n            return p.split('/');\n        }\n        else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n            // add an extra '' for the one we lose\n            return ['', ...p.split(/\\/+/)];\n        }\n        else {\n            return p.split(/\\/+/);\n        }\n    }\n    match(f, partial = this.partial) {\n        this.debug('match', f, this.pattern);\n        // short-circuit in the case of busted things.\n        // comments, etc.\n        if (this.comment) {\n            return false;\n        }\n        if (this.empty) {\n            return f === '';\n        }\n        if (f === '/' && partial) {\n            return true;\n        }\n        const options = this.options;\n        // windows: need to use /, not \\\n        if (this.isWindows) {\n            f = f.split('\\\\').join('/');\n        }\n        // treat the test path as a set of pathparts.\n        const ff = this.slashSplit(f);\n        this.debug(this.pattern, 'split', ff);\n        // just ONE of the pattern sets in this.set needs to match\n        // in order for it to be valid.  If negating, then just one\n        // match means that we have failed.\n        // Either way, return on the first hit.\n        const set = this.set;\n        this.debug(this.pattern, 'set', set);\n        // Find the basename of the path by looking for the last non-empty segment\n        let filename = ff[ff.length - 1];\n        if (!filename) {\n            for (let i = ff.length - 2; !filename && i >= 0; i--) {\n                filename = ff[i];\n            }\n        }\n        for (let i = 0; i < set.length; i++) {\n            const pattern = set[i];\n            let file = ff;\n            if (options.matchBase && pattern.length === 1) {\n                file = [filename];\n            }\n            const hit = this.matchOne(file, pattern, partial);\n            if (hit) {\n                if (options.flipNegate) {\n                    return true;\n                }\n                return !this.negate;\n            }\n        }\n        // didn't get any hits.  this is success if it's a negative\n        // pattern, failure otherwise.\n        if (options.flipNegate) {\n            return false;\n        }\n        return this.negate;\n    }\n    static defaults(def) {\n        return minimatch.defaults(def).Minimatch;\n    }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js';\nexport { escape } from './escape.js';\nexport { unescape } from './unescape.js';\n/* c8 ignore stop */\nminimatch.AST = AST;\nminimatch.Minimatch = Minimatch;\nminimatch.escape = escape;\nminimatch.unescape = unescape;\n//# sourceMappingURL=index.js.map","import ts from 'typescript'\nimport statement from '../statement'\n\nexport default function reportError(\n  file: ts.SourceFile,\n  node: ts.Node,\n  message: string,\n  code: number = 9000,\n  startPos: number = 0,\n  endPos: number = 0\n) {\n\n  if (!startPos && node.pos > -1) {\n    startPos = node.getStart()\n  }\n  if (!endPos && node.end > -1) {\n    endPos = node.getEnd()\n  }\n\n  const format = ts.formatDiagnostic(\n    {\n      file: file,\n      start: startPos,\n      length: endPos - startPos,\n      category: ts.DiagnosticCategory.Error,\n      code,\n      messageText: message\n    },\n    {\n      getCurrentDirectory: ts.sys.getCurrentDirectory,\n      getCanonicalFileName: function (fileName: string): string {\n        return fileName\n      },\n      getNewLine: function (): string {\n        return ts.sys.newLine\n      }\n    }\n  )\n  if (statement.options.reportError) {\n    const start = file.getLineAndCharacterOfPosition(startPos)\n    const end = file.getLineAndCharacterOfPosition(endPos)\n    statement.options.reportError({\n      file: file.fileName,\n      loc: {\n        start: {\n          line: start.line + 1,\n          column: start.character + 1\n        },\n        end: {\n          line: end.line + 1,\n          column: end.character + 1\n        }\n      },\n      code,\n      message: format\n    })\n  }\n  else {\n    console.error('\\x1b[31m%s\\x1b[0m', format)\n  }\n}\n","\nimport ts from 'typescript'\nimport path from 'path'\nimport fs from 'fs'\nimport { array, object } from '@libmedia/common'\nimport parseImports from './function/parseImports'\nimport type { DeclarationData, ImportData, RequireData, TransformerOptions } from './type'\nimport { pushImport, pushRequire } from './function/pushImport'\nimport * as constant from './constant'\nimport addImportStatements from './visitor/function/addImportStatements'\nimport relativePath from './function/relativePath'\nimport { minimatch } from 'minimatch'\nimport getFilePath from './function/getFilePath'\nimport reportError from './function/reportError'\n\ninterface PackageJsonResult {\n  path: string;\n  content: any;\n}\n\nconst packageJsonCache = new Map<string, PackageJsonResult | null>()\n\nfunction formatIdentifier(identifier: string, index: number) {\n  return `cheap__${identifier}__${index}`\n}\n\nfunction isIdentifier(name: string, identifier: string) {\n  return name === identifier || name.indexOf(`cheap__${identifier}__`) === 0\n}\n\nexport enum StageStatus {\n  NONE,\n  CALL,\n  EqualLeft,\n  EqualRight,\n  SingleArrowRight,\n  PointerPlusMinusIgnore,\n  AddressOf,\n  Parameter,\n  VariableDeclaration\n}\n\nexport enum BlockType {\n  UNKNOWN,\n  FUNCTION,\n  IF,\n  LOOP\n}\n\ninterface StageBase {}\n\nexport interface CallStage extends StageBase {\n  name: string\n}\n\nclass Stage<T> {\n  stage: StageStatus\n  data: T\n}\n\ntype StageMap<T> = T extends StageStatus.CALL ? CallStage : StageBase\n\nclass BlockStack {\n\n  type: BlockType = BlockType.UNKNOWN\n\n  topDeclaration: DeclarationData[] = []\n  definedStruct: string[] = []\n\n  stages: Stage<StageBase>[] = []\n\n  locals: Map<string, ts.Symbol> = new Map()\n  funcs: Map<string, ts.Node> = new Map()\n\n  synchronize: boolean = false\n\n  constructor(type: BlockType = BlockType.UNKNOWN) {\n    this.type = type\n  }\n\n  pushStage(stage: StageStatus, data: StageBase) {\n    const s = new Stage()\n    s.stage = stage\n    s.data = data\n    this.stages.push(s)\n  }\n\n  popStage() {\n    this.stages.pop()\n  }\n\n  lookupStage<T extends StageStatus>(stage: T) {\n    for (let i = this.stages.length - 1; i >= 0; i--) {\n      if (this.stages[i].stage === stage) {\n        return this.stages[i] as any as StageMap<T>\n      }\n    }\n  }\n\n  getCurrentStage() {\n    return this.stages[this.stages.length - 1]\n  }\n\n  hasStruct(name: string) {\n    return array.has(this.definedStruct, name)\n  }\n\n  getDeclaration(name: string) {\n    return this.topDeclaration.find((item) => {\n      return item.name === name\n    })\n  }\n}\n\nclass Statement {\n  options: TransformerOptions\n  compilerOptions: ts.CompilerOptions\n  cheapCompilerOptions: {\n    defined: Record<string, any>\n    structPaths: Record<string, string>\n  }\n  program: ts.Program\n  context: ts.TransformationContext\n  typeChecker: ts.TypeChecker\n  visitor: ts.Visitor\n\n  currentFile: ts.SourceFile\n  currentFilePath: string\n  imports: Map<string, {\n    map: Map<string, string>\n    specifier: string\n  }>\n  memoryImports: ImportData[]\n  symbolImports: ImportData[]\n  stdImports: ImportData[]\n  identifierImports: ImportData[]\n  requires: RequireData[]\n\n  stacks: BlockStack[]\n\n  identifierIndex: number\n\n  packageModule?: string\n  moduleType: ts.ModuleKind\n  esModuleInterop: boolean\n\n  isCheapSource: boolean\n\n  start(file: ts.SourceFile) {\n    this.currentFile = file\n    this.identifierIndex = 0\n    this.memoryImports = []\n    this.symbolImports = []\n    this.stdImports = []\n    this.identifierImports = []\n    this.requires = []\n    this.isCheapSource = false\n\n    this.stacks = []\n\n    this.pushStack()\n\n    this.imports = parseImports(file, this.program, this.typeChecker, this.getCurrentStack().locals)\n    this.currentFilePath = path.relative(this.options.projectPath, file.fileName)\n    if (this.options.cheapSourcePath) {\n      const relative = path.relative(this.options.cheapSourcePath, file.fileName)\n      this.isCheapSource = !!relative && !relative.startsWith('..') && !path.isAbsolute(relative)\n    }\n    if (this.moduleType === ts.ModuleKind.Node16\n      || this.moduleType === ts.ModuleKind.Node18\n      || this.moduleType === ts.ModuleKind.Node20\n      || this.moduleType === ts.ModuleKind.NodeNext\n    ) {\n      const jsonInfo = this.findNearestPackageJson(this.currentFile.fileName)\n      if (jsonInfo?.content.type) {\n        this.packageModule = jsonInfo.content.type\n      }\n    }\n  }\n\n  isOutputCJS() {\n    return this.moduleType === ts.ModuleKind.CommonJS\n      || this.moduleType === ts.ModuleKind.UMD\n      || this.moduleType === ts.ModuleKind.AMD\n      || this.options.module === 'commonjs'\n      || (this.moduleType === ts.ModuleKind.Node16\n        || this.moduleType === ts.ModuleKind.Node18\n        || this.moduleType === ts.ModuleKind.Node20\n        || this.moduleType === ts.ModuleKind.NodeNext\n      )\n        && this.packageModule === 'commonjs'\n  }\n\n  end(newFile: ts.SourceFile) {\n    const stack = this.getCurrentStack()\n\n    const updatedStatements = []\n\n    array.each(stack.topDeclaration, (item) => {\n      updatedStatements.push(this.context.factory.createVariableStatement(\n        undefined,\n        this.context.factory.createVariableDeclarationList(\n          [\n            this.context.factory.createVariableDeclaration(item.formatName, undefined, undefined, item.initializer)\n          ],\n          ts.NodeFlags.Const\n        )\n      ))\n    })\n\n    if (this.memoryImports.length) {\n      addImportStatements(this.memoryImports, this.isCheapSource ? this.memoryImports[0].path : constant.RootPath, updatedStatements)\n    }\n    if (this.symbolImports.length) {\n      addImportStatements(this.symbolImports, this.isCheapSource ? this.symbolImports[0].path : constant.InternalPath, updatedStatements)\n    }\n\n    const cheapReg = new RegExp(`^\\\\S*/node_modules/${constant.PACKET_NAME}/dist/((esm|cjs)/)?`)\n\n    if (this.identifierImports.length) {\n      this.identifierImports.forEach((item) => {\n        let p = item.path.replace(/(\\.d)?\\.[t|j]s$/, '')\n        p = p.replace(cheapReg, constant.PACKET_NAME + '/')\n        if (this.options.importPath) {\n          p = this.options.importPath(p)\n        }\n        const importDeclaration = this.context.factory.createImportDeclaration(\n          undefined,\n          this.context.factory.createImportClause(\n            false,\n            item.default\n              ? this.context.factory.createIdentifier(item.formatName)\n              : undefined,\n            item.default\n              ? undefined\n              : this.context.factory.createNamedImports([\n                this.context.factory.createImportSpecifier(\n                  false,\n                  this.context.factory.createIdentifier(item.name),\n                  this.context.factory.createIdentifier(item.formatName)\n                )\n              ])\n          ),\n          this.context.factory.createStringLiteral(p)\n        )\n        updatedStatements.push(importDeclaration)\n      })\n    }\n\n    if (this.requires.length) {\n      this.requires.forEach((item) => {\n        let p = item.path.replace(/(\\.d)?\\.[t|j]s$/, '')\n        p = p.replace(cheapReg, constant.PACKET_NAME + '/')\n        if (this.options.importPath) {\n          p = this.options.importPath(p)\n        }\n\n        const requireValue = this.context.factory.createCallExpression(\n          this.context.factory.createIdentifier('require'),\n          undefined,\n          [\n            this.context.factory.createStringLiteral(p)\n          ]\n        )\n\n        const requireDeclaration = this.context.factory.createVariableStatement(\n          undefined,\n          this.context.factory.createVariableDeclarationList(\n            [\n              this.context.factory.createVariableDeclaration(\n                this.context.factory.createIdentifier(item.formatName),\n                undefined,\n                undefined,\n                this.esModuleInterop && !item.esModule\n                  ? this.context.factory.createCallExpression(\n                    this.context.factory.createIdentifier(item.default ? constant.importDefault : constant.importStar),\n                    undefined,\n                    [\n                      requireValue\n                    ]\n                  )\n                  : requireValue\n              )\n            ],\n            ts.NodeFlags.Const\n          )\n        )\n        updatedStatements.push(requireDeclaration)\n      })\n    }\n\n    if (updatedStatements.length) {\n      newFile = this.context.factory.updateSourceFile(newFile, [...updatedStatements, ...newFile.statements])\n    }\n\n    this.popStack()\n\n    this.program = null\n    this.typeChecker = null\n    this.context = null\n    this.currentFile = null\n    this.visitor = null\n\n    this.memoryImports = []\n    this.symbolImports = []\n    this.stdImports = []\n    this.identifierImports = []\n    this.requires = []\n    this.stacks = []\n\n    return newFile\n  }\n\n  pushStack(type?: BlockType) {\n    this.stacks.push(new BlockStack(type))\n  }\n\n  popStack() {\n    this.stacks.pop()\n  }\n\n  getCurrentStack() {\n    return this.stacks[this.stacks.length - 1]\n  }\n\n  pushStage(status: StageStatus, data: StageBase = {}) {\n    this.getCurrentStack()?.pushStage(status, data)\n  }\n\n  popStage() {\n    this.getCurrentStack()?.popStage()\n  }\n\n  getCurrentStage() {\n    return this.getCurrentStack()?.getCurrentStage()\n  }\n\n  lookupStage<T extends StageStatus>(stage: T) {\n    for (let i = this.stacks.length - 1; i >= 0; i--) {\n      const stack = this.stacks[i]\n      const s = stack.lookupStage(stage)\n      if (s) {\n        return s\n      }\n    }\n  }\n\n  hasStruct(name: string) {\n    for (let i = this.stacks.length - 1; i >= 0; i--) {\n      const stack = this.stacks[i]\n      const s = stack.hasStruct(name)\n      if (s) {\n        return s\n      }\n    }\n    return false\n  }\n\n  addStruct(name: string) {\n    this.getCurrentStack().definedStruct.push(name)\n  }\n\n  getDeclaration(name: string) {\n    return this.getCurrentStack()?.getDeclaration(name)\n  }\n\n  addDeclaration(name: string, initializer?: ts.Expression) {\n    const stack = this.getCurrentStack()\n    for (let i = 0; i < stack.topDeclaration.length; i++) {\n      if (stack.topDeclaration[i].name === name) {\n        return stack.topDeclaration[i]\n      }\n    }\n    const item = {\n      name,\n      formatName: formatIdentifier(name, this.identifierIndex++),\n      initializer\n    }\n    stack.topDeclaration.push(item)\n    return item\n  }\n\n  addModuleDeclaration(name: string, initializer?: ts.Expression) {\n    const stack = this.stacks[0]\n    for (let i = 0; i < stack.topDeclaration.length; i++) {\n      if (stack.topDeclaration[i].name === name) {\n        return stack.topDeclaration[i]\n      }\n    }\n    const item = {\n      name,\n      formatName: formatIdentifier(name, this.identifierIndex++),\n      initializer\n    }\n    stack.topDeclaration.push(item)\n    return item\n  }\n\n  relativePath(file: string) {\n    if (file.indexOf(constant.PACKET_NAME) === 0) {\n      file = file.replace(constant.PACKET_NAME + '/', '')\n    }\n    return relativePath(this.currentFile.fileName, path.resolve(this.options.cheapSourcePath, file))\n  }\n\n  modulePath2RelativePath(name: string, modulePath: string, defaultExport: boolean) {\n    if (modulePath === constant.InternalPath) {\n      if (name === constant.ctypeEnumRead) {\n        modulePath = this.relativePath(constant.ctypeEnumReadPath)\n        defaultExport = false\n      }\n      else if (name === constant.ctypeEnumWrite) {\n        modulePath = this.relativePath(constant.ctypeEnumWritePath)\n        defaultExport = false\n      }\n      else if (name === constant.Allocator) {\n        modulePath = this.relativePath(constant.AllocatorPath)\n        defaultExport = false\n      }\n      else if (name === constant.makeSharedPtr) {\n        modulePath = this.relativePath(constant.makeSharedPtrPath)\n        defaultExport = false\n      }\n      else if (name === constant.definedMetaProperty) {\n        modulePath = this.relativePath(constant.definedMetaPropertyPath)\n        defaultExport = true\n      }\n    }\n    else if (modulePath === constant.RootPath) {\n      if (name === constant.make) {\n        modulePath = this.relativePath(constant.makePath)\n        defaultExport = true\n      }\n      else if (name === constant.unmake) {\n        modulePath = this.relativePath(constant.unmakePath)\n        defaultExport = true\n      }\n      else if (name === constant.sizeof) {\n        modulePath = this.relativePath(constant.sizeofPath)\n        defaultExport = true\n      }\n      else if (name === constant.structAccess) {\n        modulePath = this.relativePath(constant.structAccessPath)\n        defaultExport = true\n      }\n    }\n    return {\n      modulePath,\n      defaultExport\n    }\n  }\n\n  addMemoryImport(name: string) {\n    if (name === constant.ctypeEnumRead) {\n      return this.addIdentifierImport(name, constant.InternalPath, false)\n    }\n    else if (name === constant.ctypeEnumWrite) {\n      return this.addIdentifierImport(name, constant.InternalPath, false)\n    }\n\n    if (this.isOutputCJS()) {\n      let { formatName } = pushRequire(\n        this.requires,\n        formatIdentifier('identifier', this.identifierIndex++),\n        this.isCheapSource\n          ? this.relativePath(constant.memoryPath)\n          : constant.RootPath,\n        false,\n        true\n      )\n      return this.context.factory.createPropertyAccessExpression(\n        this.context.factory.createIdentifier(formatName),\n        this.context.factory.createIdentifier(name)\n      )\n    }\n    else {\n      let { formatName } = pushImport(\n        this.memoryImports,\n        name,\n        this.isCheapSource\n          ? this.relativePath(constant.memoryPath)\n          : constant.RootPath,\n        this.options.formatIdentifier === false ? name : formatIdentifier(name, this.identifierIndex++), false\n      )\n      return this.context.factory.createIdentifier(formatName)\n    }\n  }\n\n  addSymbolImport(name: string) {\n    if (this.isOutputCJS()) {\n      let { formatName } = pushRequire(\n        this.requires,\n        formatIdentifier('identifier', this.identifierIndex++),\n        this.isCheapSource\n          ? this.relativePath(constant.symbolPath)\n          : constant.InternalPath,\n        false,\n        true\n      )\n      return this.context.factory.createPropertyAccessExpression(\n        this.context.factory.createIdentifier(formatName),\n        this.context.factory.createIdentifier(name)\n      )\n    }\n    else {\n      let { formatName } = pushImport(\n        this.symbolImports,\n        name,\n        this.isCheapSource\n          ? this.relativePath(constant.symbolPath)\n          : constant.InternalPath,\n        this.options.formatIdentifier === false ? name : formatIdentifier(name, this.identifierIndex++),\n        false\n      )\n      return this.context.factory.createIdentifier(formatName)\n    }\n  }\n\n  addIdentifierImport(name: string, modulePath: string, defaultExport: boolean, esModule: boolean = true) {\n\n    if (this.isCheapSource) {\n      const result = this.modulePath2RelativePath(name, modulePath, defaultExport)\n      modulePath = result.modulePath\n      defaultExport = result.defaultExport\n    }\n\n    if (this.isOutputCJS()) {\n      let item = pushRequire(\n        this.requires,\n        formatIdentifier('identifier', this.identifierIndex++),\n        modulePath,\n        defaultExport,\n        true\n      )\n      if (defaultExport) {\n        item.defaultName = name\n      }\n      if (defaultExport && !esModule) {\n        return this.context.factory.createIdentifier(item.formatName)\n      }\n      else {\n        return this.context.factory.createPropertyAccessExpression(\n          this.context.factory.createIdentifier(item.formatName),\n          this.context.factory.createIdentifier(defaultExport ? 'default' : name)\n        )\n      }\n    }\n    else {\n      let { formatName } = pushImport(\n        this.identifierImports,\n        name,\n        modulePath,\n        this.options.formatIdentifier === false ? name : formatIdentifier(name, this.identifierIndex++),\n        defaultExport\n      )\n      return this.context.factory.createIdentifier(formatName)\n    }\n  }\n\n  resolveSourceSymbol(symbol: ts.Symbol): ts.Symbol {\n    let current = symbol\n    while (current.flags & ts.SymbolFlags.Alias) {\n      current = this.typeChecker.getAliasedSymbol(current)\n    }\n    return current\n  }\n\n  getAliasedNameFromModule(module: string, symbol: ts.Symbol, name: string) {\n    const fileName = getFilePath(this.program, this.currentFile.fileName, module)\n    if (fileName) {\n      const sf = this.program.getSourceFile(fileName)\n      if (sf) {\n        const ss = this.typeChecker.getSymbolAtLocation(sf)\n        if (ss?.exports) {\n          if (ss.exports.has(name as ts.__String)) {\n            if (this.resolveSourceSymbol(ss.exports.get(name as ts.__String)) === symbol) {\n              return name\n            }\n          }\n          if (ss.exports.has('default' as ts.__String)) {\n            if (this.resolveSourceSymbol(ss.exports.get('default' as ts.__String)) === symbol) {\n              return 'default'\n            }\n          }\n          for (let en of ss.exports) {\n            if (this.resolveSourceSymbol(en[1]) === symbol) {\n              return en[0] as string\n            }\n          }\n        }\n      }\n    }\n  }\n\n  addStructImport(symbol: ts.Symbol, target: ts.SourceFile) {\n    // if (!this.isOutputCJS()) {\n    //   let local = this.lookupLocalSymbol(symbol)\n    //   if (local) {\n    //     return this.context.factory.createIdentifier(local)\n    //   }\n    // }\n    let pathString = relativePath(this.currentFile.fileName, target.fileName)\n    let name: string = symbol.escapedName as string\n    object.each(this.cheapCompilerOptions.structPaths, (value, key) => {\n      if (minimatch(target.fileName, key) && !minimatch(this.currentFile.fileName, key)) {\n        let importName = this.getAliasedNameFromModule(value, symbol, name)\n        if (importName) {\n          pathString = value\n          name = importName\n        }\n        else {\n          reportError(\n            statement.currentFile,\n            this.currentFile,\n            `not found struct ${name} from module ${value}`\n          )\n        }\n        return false\n      }\n    })\n    if (/[\\\\/]node_modules[\\\\/]/.test(target.fileName)) {\n      const match = target.fileName.match(/[\\\\/]node_modules[\\\\/](?:@[^\\\\/]+[\\\\/][^\\\\/]+|[^\\\\/]+)/)\n      if (match) {\n        let packageName = match[0].replace(/.*node_modules[\\\\/]/, '')\n        let importName = this.getAliasedNameFromModule(packageName, symbol, name)\n        if (importName) {\n          pathString = packageName\n          name = importName\n        }\n      }\n    }\n    return this.addIdentifierImport(\n      name,\n      pathString,\n      name === 'default'\n    )\n  }\n\n  isIdentifier(name: ts.Identifier | ts.PropertyAccessExpression, identifier: string, path: string, importPath: string) {\n    if (this.isCheapSource) {\n      const result = this.modulePath2RelativePath(identifier, importPath, false)\n      importPath = result.modulePath\n    }\n    if (ts.isIdentifier(name)) {\n      if (name.escapedText === identifier) {\n        const symbol = this.typeChecker.getSymbolAtLocation(name)\n        if (symbol) {\n          const targetSource = symbol.valueDeclaration?.getSourceFile()\n          if (targetSource) {\n            if (targetSource.fileName.indexOf(path) >= 0\n              || targetSource.fileName.indexOf(constant.PACKET_NAME) >= 0\n                && targetSource.fileName.indexOf(path.replace(constant.PACKET_NAME, '')) >= 0\n            ) {\n              return true\n            }\n          }\n        }\n      }\n      return isIdentifier(name.escapedText as string, identifier) && this.identifierImports.some((item) => {\n        return item.formatName === name.escapedText\n          && item.name === identifier\n          && item.path === importPath\n      })\n      || isIdentifier(name.escapedText as string, 'identifier') && this.requires.some((item) => {\n        return item.defaultName === identifier\n          && item.path === importPath\n      })\n    }\n    else {\n      if (name.name.escapedText === identifier) {\n        const symbol = this.typeChecker.getSymbolAtLocation(name)\n        if (symbol) {\n          const targetSource = symbol.valueDeclaration?.getSourceFile()\n          if (targetSource) {\n            if (targetSource.fileName.indexOf(path) >= 0\n              || targetSource.fileName.indexOf(constant.PACKET_NAME) >= 0\n                && targetSource.fileName.indexOf(path.replace(constant.PACKET_NAME, '')) >= 0\n            ) {\n              return true\n            }\n          }\n        }\n        else if (ts.isIdentifier(name.expression)\n          && isIdentifier(name.expression.escapedText as string, 'identifier')\n        ) {\n          return this.requires.some((item) => {\n            return item.formatName === (name.expression as ts.Identifier).escapedText\n              && item.path === importPath\n          })\n        }\n      }\n      else if (name.name.escapedText === 'default'\n        && ts.isIdentifier(name.expression)\n        && isIdentifier(name.expression.escapedText as string, 'identifier')\n      ) {\n        return this.requires.some((item) => {\n          return item.defaultName === identifier\n          && item.path === importPath\n        })\n      }\n    }\n    return false\n  }\n\n  addLocal(name: string, symbol: ts.Symbol) {\n    this.getCurrentStack()?.locals.set(name, symbol)\n  }\n\n  addFunc(name: string, node: ts.Node) {\n    this.getCurrentStack()?.funcs.set(name, node)\n  }\n\n  lookupLocal(name: string) {\n    for (let i = this.stacks.length - 1; i >= 0; i--) {\n      const stack = this.stacks[i]\n      const s = stack.locals.get(name)\n      if (s) {\n        return s\n      }\n    }\n  }\n\n  lookupLocalSymbol(symbol: ts.Symbol) {\n    for (let i = this.stacks.length - 1; i >= 0; i--) {\n      const stack = this.stacks[i]\n      let s: string\n      for (let entry of stack.locals) {\n        if (this.resolveSourceSymbol(entry[1]) === symbol) {\n          return entry[0]\n        }\n      }\n    }\n  }\n\n  lookupFunc(name: string) {\n    for (let i = this.stacks.length - 1; i >= 0; i--) {\n      const stack = this.stacks[i]\n      const s = stack.funcs.get(name)\n      if (s) {\n        return s\n      }\n    }\n  }\n\n  lookupSynchronized() {\n    for (let i = this.stacks.length - 1; i >= 0; i--) {\n      const stack = this.stacks[i]\n      if (stack.type === BlockType.FUNCTION) {\n        return stack.synchronize\n      }\n    }\n    return false\n  }\n\n  findNearestPackageJson(filePath: string): PackageJsonResult | null {\n    const absPath = path.resolve(filePath)\n\n    // 检查缓存\n    if (packageJsonCache.has(absPath)) {\n      return packageJsonCache.get(absPath)!\n    }\n\n    let dir = path.dirname(absPath)\n\n    while (true) {\n      const pkgPath = path.join(dir, 'package.json')\n      if (packageJsonCache.get(pkgPath)) {\n        return packageJsonCache.get(pkgPath)\n      }\n      if (!packageJsonCache.has(pkgPath) && fs.existsSync(pkgPath)) {\n        try {\n          const content = JSON.parse(fs.readFileSync(pkgPath, 'utf8'))\n          const result = { path: pkgPath, content }\n          packageJsonCache.set(pkgPath, result)\n          return result\n        }\n        catch (e) {\n          // 忽略解析错误，继续往上查找\n          packageJsonCache.set(pkgPath, null)\n        }\n      }\n      const parent = path.dirname(dir)\n      if (parent === dir) {\n        break\n      }\n      dir = parent\n    }\n    // 找不到\n    packageJsonCache.set(absPath, null)\n    return null\n  }\n}\n\nconst statement = new Statement()\n\nexport default statement\n\n","import { CTypeEnum } from '..//typedef'\nimport * as constant from './constant'\nimport { object, array } from '@libmedia/common'\n\nexport const BuiltinType = [\n  'i32',\n  'i64',\n  'f32',\n  'f64',\n  'uint8',\n  'uint16',\n  'uint32',\n  'uint64',\n  'int8',\n  'int16',\n  'int32',\n  'int64',\n  'float',\n  'float64',\n  'double',\n  'char',\n  'size',\n  'void',\n  'bool',\n  'size',\n\n  'atomic_char',\n  'atomic_uint8',\n  'atomic_uint16',\n  'atomic_uint32',\n  'atomic_int8',\n  'atomic_int16',\n  'atomic_int32',\n  'atomic_int64',\n  'atomic_uint64',\n  'atomic_bool'\n]\n\nexport const BuiltinAtomicType = [\n  'atomic_char',\n  'atomic_uint8',\n  'atomic_uint16',\n  'atomic_uint32',\n  'atomic_int8',\n  'atomic_int16',\n  'atomic_int32',\n  'atomic_int64',\n  'atomic_uint64',\n  'atomic_bool'\n]\n\nexport const BuiltinDecorator = [\n  constant.cstruct,\n  constant.cunion,\n  constant.cignore,\n  constant.ctype,\n  constant.cpointer,\n  constant.carray,\n  constant.cbitField,\n  constant.cinline,\n  constant.cdeasync\n]\n\nexport const AtomicCall = [\n  'add',\n  'sub',\n  'and',\n  'or',\n  'xor',\n  'store',\n  'load',\n  'compareExchange',\n  'exchange'\n]\n\nexport const BuiltinFloat = [\n  'float',\n  'float64',\n  'double',\n  'f32',\n  'f64'\n]\n\nexport const BuiltinBigInt = [\n  'i64',\n  'int64',\n  'uint64',\n  'atomic_int64',\n  'atomic_uint64'\n]\n\nexport const BuiltinUint = [\n  'uint8',\n  'atomic_uint8',\n  'uint16',\n  'atomic_uint16',\n  'uint32',\n  'atomic_uint32',\n  'uint64',\n  'atomic_uint64',\n  'size'\n]\n\nexport const BuiltinBool = [\n  'bool',\n  'atomic_bool'\n]\n\nexport const CTypeEnum2Type: Record<CTypeEnum, string> = {\n  [CTypeEnum.uint8]: 'uint8',\n  [CTypeEnum.atomic_uint8]: 'atomic_uint8',\n  [CTypeEnum.char]: 'char',\n  [CTypeEnum.atomic_char]: 'atomic_char',\n  [CTypeEnum.uint16]: 'uint16',\n  [CTypeEnum.atomic_uint16]: 'atomic_uint16',\n  [CTypeEnum.uint32]: 'uint32',\n  [CTypeEnum.atomic_uint32]: 'atomic_uint32',\n  [CTypeEnum.uint64]: 'uint64',\n  [CTypeEnum.int8]: 'int8',\n  [CTypeEnum.atomic_int8]: 'atomic_int8',\n  [CTypeEnum.int16]: 'int16',\n  [CTypeEnum.atomic_int16]: 'atomic_int16',\n  [CTypeEnum.int32]: 'int32',\n  [CTypeEnum.atomic_int32]: 'atomic_int32',\n  [CTypeEnum.int64]: 'int64',\n  [CTypeEnum.float]: 'float',\n  [CTypeEnum.double]: 'double',\n  [CTypeEnum.pointer]: 'pointer',\n  [CTypeEnum.void]: 'void',\n  [CTypeEnum.null]: 'nullptr',\n  [CTypeEnum.atomic_uint64]: 'atomic_uint64',\n  [CTypeEnum.atomic_int64]: 'atomic_int64',\n  [CTypeEnum.bool]: 'bool',\n  [CTypeEnum.atomic_bool]: 'atomic_bool',\n  [CTypeEnum.size]: 'size'\n}\n\nexport const Type2CTypeEnum: Record<string, CTypeEnum> = {\n  typeptr: CTypeEnum.pointer,\n  i32: CTypeEnum.int32,\n  i64: CTypeEnum.int64,\n  f32: CTypeEnum.float,\n  f64: CTypeEnum.double\n}\n\nobject.each(CTypeEnum2Type, (value, key) => {\n  Type2CTypeEnum[value] = +key\n})\n\nexport const BuiltinNumber = array.exclude(array.exclude(array.exclude(BuiltinType, BuiltinFloat), BuiltinBigInt), BuiltinBool)\n","import type { Data, TypeArray } from '@libmedia/common'\n\nexport const enum CTypeEnum {\n  null = 0,\n\n  void,\n\n  uint8,\n  atomic_uint8,\n  char,\n  atomic_char,\n  uint16,\n  atomic_uint16,\n  uint32,\n  atomic_uint32,\n  uint64,\n\n  int8,\n  atomic_int8,\n  int16,\n  atomic_int16,\n  int32,\n  atomic_int32,\n  int64,\n\n  float,\n  double,\n  pointer,\n\n  atomic_int64,\n  atomic_uint64,\n\n  bool,\n  atomic_bool,\n  size\n}\n\nexport const CTypeEnum2Bytes: Record<CTypeEnum, number> = {\n  [CTypeEnum.uint8]: 1,\n  [CTypeEnum.atomic_uint8]: 1,\n  [CTypeEnum.char]: 1,\n  [CTypeEnum.atomic_char]: 1,\n  [CTypeEnum.uint16]: 2,\n  [CTypeEnum.atomic_uint16]: 2,\n  [CTypeEnum.uint32]: 4,\n  [CTypeEnum.atomic_uint32]: 4,\n  [CTypeEnum.uint64]: 8,\n  [CTypeEnum.int8]: 1,\n  [CTypeEnum.atomic_int8]: 1,\n  [CTypeEnum.int16]: 2,\n  [CTypeEnum.atomic_int16]: 2,\n  [CTypeEnum.int32]: 4,\n  [CTypeEnum.atomic_int32]: 4,\n  [CTypeEnum.int64]: 8,\n  [CTypeEnum.float]: 4,\n  [CTypeEnum.double]: 8,\n  [CTypeEnum.pointer]: defined(WASM_64) ? 8 : 4,\n  [CTypeEnum.null]: 4,\n  [CTypeEnum.void]: 4,\n\n  [CTypeEnum.atomic_uint64]: 8,\n  [CTypeEnum.atomic_int64]: 8,\n\n  [CTypeEnum.bool]: 1,\n  [CTypeEnum.atomic_bool]: 1,\n  [CTypeEnum.size]: defined(WASM_64) ? 8 : 4\n}\n\nexport const CTypeEnumPointerShiftMap: Record<CTypeEnum, number> = {\n  [CTypeEnum.uint8]: 0,\n  [CTypeEnum.atomic_uint8]: 0,\n  [CTypeEnum.char]: 0,\n  [CTypeEnum.atomic_char]: 0,\n  [CTypeEnum.uint16]: 1,\n  [CTypeEnum.atomic_uint16]: 1,\n  [CTypeEnum.uint32]: 2,\n  [CTypeEnum.atomic_uint32]: 2,\n  [CTypeEnum.uint64]: 4,\n  [CTypeEnum.int8]: 0,\n  [CTypeEnum.atomic_int8]: 0,\n  [CTypeEnum.int16]: 1,\n  [CTypeEnum.atomic_int16]: 1,\n  [CTypeEnum.int32]: 2,\n  [CTypeEnum.atomic_int32]: 2,\n  [CTypeEnum.int64]: 4,\n  [CTypeEnum.float]: 2,\n  [CTypeEnum.double]: 4,\n  [CTypeEnum.pointer]: defined(WASM_64) ? 3 : 2,\n  [CTypeEnum.void]: 2,\n  [CTypeEnum.null]: 2,\n  [CTypeEnum.atomic_uint64]: 4,\n  [CTypeEnum.atomic_int64]: 4,\n\n  [CTypeEnum.bool]: 0,\n  [CTypeEnum.atomic_bool]: 0,\n  [CTypeEnum.size]: defined(WASM_64) ? 3 : 2\n}\n\nexport const enum KeyMetaKey {\n  Type,\n  Pointer,\n  PointerLevel,\n  Array,\n  ArrayLength,\n  BitField,\n  BitFieldLength,\n  BaseAddressOffset,\n  BaseBitOffset,\n  InlineStruct\n}\n\nexport type KeyMeta = {\n  [KeyMetaKey.Type]: CTypeEnum | Struct\n  [KeyMetaKey.Pointer]: 0 | 1\n  [KeyMetaKey.PointerLevel]: number\n  [KeyMetaKey.Array]: 0 | 1\n  [KeyMetaKey.ArrayLength]: number\n  [KeyMetaKey.BitField]: 0 | 1\n  [KeyMetaKey.BitFieldLength]: number\n  [KeyMetaKey.BaseAddressOffset]: uint32\n  [KeyMetaKey.BaseBitOffset]: uint32\n  getTypeMeta?: () => { length: number, maxBaseTypeByteLength: number }\n}\n\nexport type Struct = new (init?: Data) => any\nexport type Union = new (init?: Data) => any\n\n/* eslint-disable */\nexport type CTypeEnum2Type<T> =\n  T extends CTypeEnum.null\n  ? void\n  : T extends CTypeEnum.void\n  ? void\n  : T extends CTypeEnum.uint8\n  ? uint8\n  : T extends CTypeEnum.atomic_int8\n  ? atomic_uint8\n  : T extends CTypeEnum.char\n  ? char\n  : T extends CTypeEnum.uint16\n  ? uint16\n  : T extends CTypeEnum.atomic_uint16\n  ? atomic_uint16\n  : T extends CTypeEnum.uint32\n  ? uint32\n  : T extends CTypeEnum.atomic_uint32\n  ? atomic_uint32\n  : T extends CTypeEnum.uint64\n  ? uint64\n  : T extends CTypeEnum.int8\n  ? int8\n  : T extends CTypeEnum.atomic_int8\n  ? atomic_int8\n  : T extends CTypeEnum.int16\n  ? int16\n  : T extends CTypeEnum.atomic_int16\n  ? atomic_int16\n  : T extends CTypeEnum.int32\n  ? int32\n  : T extends CTypeEnum.atomic_int32\n  ? atomic_int32\n  : T extends CTypeEnum.int64\n  ? int64\n  : T extends CTypeEnum.float\n  ? float\n  : T extends CTypeEnum.double\n  ? double\n  : T extends CTypeEnum.pointer\n  ? pointer<void>\n  : T extends CTypeEnum.atomic_int64\n  ? atomic_int64\n  : T extends CTypeEnum.atomic_uint64\n  ? atomic_uint64\n  : T extends CTypeEnum.bool\n  ? bool\n  : T extends CTypeEnum.atomic_bool\n  ? atomic_bool\n  : T extends CTypeEnum.size\n  ? size\n  : never\n/* eslint-enable */\n\nexport type AtomicsBuffer = Exclude<TypeArray, Float32Array | Float64Array> | BigInt64Array | BigUint64Array\n","export const symbolStruct = Symbol('Struct')\nexport const symbolStructLength = Symbol('StructLength')\nexport const symbolStructMaxBaseTypeByteLength = Symbol('StructMaxBaseTypeByteLength')\nexport const symbolStructAddress = Symbol('StructAddress')\nexport const symbolStructKeysQueue = Symbol('StructKeysQueue')\nexport const symbolStructKeysMeta = Symbol('StructKeysMeta')\nexport const symbolStructKeysInstance = Symbol('StructKeysInstance')\nexport const symbolStructProxyRevoke = Symbol('StructProxyRevoke')\n","import type { KeyMeta, Struct, Union } from './typedef'\nimport { CTypeEnum, CTypeEnum2Bytes, KeyMetaKey } from './typedef'\nimport { symbolStruct, symbolStructKeysMeta,\n  symbolStructLength, symbolStructMaxBaseTypeByteLength\n} from './symbol'\nimport definedMetaProperty from './function/definedMetaProperty'\n\nimport { isLittleEndian, is, array } from '@libmedia/common'\n\n/**\n * 获取结构体最大基本类型的长度\n * \n * @param target \n * @returns \n */\nexport function getMaxBaseTypeByteLength(keysMeta: Map<string, KeyMeta>) {\n\n  let max = 0\n\n  keysMeta.forEach((value) => {\n    if (value[KeyMetaKey.Pointer]) {\n      if (CTypeEnum2Bytes[CTypeEnum.pointer] > max) {\n        max = CTypeEnum2Bytes[CTypeEnum.pointer]\n      }\n    }\n    else {\n      if (is.func(value.getTypeMeta)) {\n        const typeMeta = value.getTypeMeta()\n        if (typeMeta.maxBaseTypeByteLength > max) {\n          max = typeMeta.maxBaseTypeByteLength\n        }\n      }\n      else if (is.func(value[KeyMetaKey.Type])) {\n        if (value[KeyMetaKey.Type][symbolStructMaxBaseTypeByteLength] > max) {\n          max = value[KeyMetaKey.Type][symbolStructMaxBaseTypeByteLength]\n        }\n      }\n      else if (CTypeEnum2Bytes[value[KeyMetaKey.Type] as CTypeEnum] > max) {\n        max = CTypeEnum2Bytes[value[KeyMetaKey.Type] as CTypeEnum]\n      }\n    }\n  })\n\n  return max\n}\n\n/**\n * 获取结构体最大成员的长度\n * \n * @param target \n * @returns \n */\nexport function getMaxTypeByteLength(keysMeta: Map<string, KeyMeta>) {\n\n  let max = 0\n\n  keysMeta.forEach((value) => {\n    if (value[KeyMetaKey.Pointer]) {\n      if (CTypeEnum2Bytes[CTypeEnum.pointer] > max) {\n        max = CTypeEnum2Bytes[CTypeEnum.pointer]\n      }\n    }\n    else {\n      if (is.func(value.getTypeMeta)) {\n        const typeMeta = value.getTypeMeta()\n        if (typeMeta.length > max) {\n          max = typeMeta.length\n        }\n      }\n      else if (is.func(value[KeyMetaKey.Type])) {\n        if (value[KeyMetaKey.Type][symbolStructLength] > max) {\n          max = value[KeyMetaKey.Type][symbolStructLength]\n        }\n      }\n      else if (CTypeEnum2Bytes[value[KeyMetaKey.Type] as CTypeEnum] > max) {\n        max = CTypeEnum2Bytes[value[KeyMetaKey.Type] as CTypeEnum]\n      }\n    }\n  })\n\n  return max\n}\n\n/**\n * 对结构体进行内存布局\n * \n * 1. 结构体变量的首地址能够被其最宽基本类型成员的大小 (sizeof)  所整除 （这个由 malloc 保证）\n * 2. 结构体每个成员相对结构体首地址的偏移量 offset 都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节\n * 3. 结构体的总大小 sizeof 为结构体最宽基本成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。\n * \n * 位域：\n * \n * 4.  如果相邻位域字段的类型相同，且位宽之和小于类型的 sizeof 大小，则后一个字段将紧邻前一个字段存储，直到不能容纳为止。\n * 5.  如果相邻位域字段的类型相同，但位宽之和大于类型的 sizeof 大小，则后一个字段将从新的存储单元开始，其偏移量为其类型大小的整数倍。\n * 6.  如果相邻的位域字段的类型不同，则各编译器的具体实现有差异。（此处采取不压缩）\n * 7.  如果位域字段之间穿插着非位域字段，则不进行压缩。\n * \n * @param target \n * @returns \n */\nexport function layout(keysQueue: string[], keysMeta: Map<string, KeyMeta>, padding: number, offset: number = 0) {\n  let lastBitFieldType: CTypeEnum = CTypeEnum.null\n  let bitFieldRemaining: number = 0\n  let lastOffset: number = offset\n\n  if (keysQueue && keysMeta) {\n    array.each(keysQueue, (key) => {\n      const meta = keysMeta.get(key)\n\n      let padding = 0\n      let length = 0\n\n      if (meta[KeyMetaKey.Pointer]) {\n        padding = CTypeEnum2Bytes[CTypeEnum.pointer]\n        length = CTypeEnum2Bytes[CTypeEnum.pointer]\n      }\n      else {\n        if (is.func(meta.getTypeMeta)) {\n          const typeMeta = meta.getTypeMeta()\n          padding = typeMeta.maxBaseTypeByteLength\n          length = typeMeta.length\n        }\n        else if (is.func(meta[KeyMetaKey.Type])) {\n          padding = (meta[KeyMetaKey.Type] as Function).prototype[symbolStructMaxBaseTypeByteLength]\n          length = (meta[KeyMetaKey.Type] as Function).prototype[symbolStructLength]\n        }\n        else {\n          // 与上一个字段类型相同且有足够 bit 数（条件 4，6）\n          if (meta[KeyMetaKey.BitField]\n            && meta[KeyMetaKey.Type] === lastBitFieldType\n            && bitFieldRemaining >= meta[KeyMetaKey.BitFieldLength]\n          ) {\n            meta[KeyMetaKey.BaseAddressOffset] = lastOffset\n            meta[KeyMetaKey.BaseBitOffset] = CTypeEnum2Bytes[lastBitFieldType] * 8 - bitFieldRemaining\n            bitFieldRemaining -= meta[KeyMetaKey.BitFieldLength]\n\n            if (meta[KeyMetaKey.BitFieldLength] === 0) {\n              meta[KeyMetaKey.BitFieldLength] = bitFieldRemaining\n              lastBitFieldType = CTypeEnum.null\n              bitFieldRemaining = 0\n            }\n\n            if (isLittleEndian()) {\n              meta[KeyMetaKey.BaseBitOffset] = CTypeEnum2Bytes[lastBitFieldType] * 8\n                - meta[KeyMetaKey.BaseBitOffset] - meta[KeyMetaKey.BitFieldLength]\n            }\n\n            return true\n          }\n          else {\n            // 不满足，重新开启空间（条件 5）\n            padding = CTypeEnum2Bytes[meta[KeyMetaKey.Type] as CTypeEnum]\n            length = CTypeEnum2Bytes[meta[KeyMetaKey.Type] as CTypeEnum]\n          }\n        }\n      }\n\n      // 对当前字段类型对齐（条件 2）\n      while (offset % padding !== 0) {\n        offset++\n      }\n      meta[KeyMetaKey.BaseAddressOffset] = offset\n\n      if (meta[KeyMetaKey.BitField]) {\n        lastBitFieldType = meta[KeyMetaKey.Type] as CTypeEnum\n        meta[KeyMetaKey.BaseBitOffset] = 0\n        bitFieldRemaining = CTypeEnum2Bytes[lastBitFieldType] * 8 - meta[KeyMetaKey.BitFieldLength]\n\n        if (isLittleEndian()) {\n          meta[KeyMetaKey.BaseBitOffset] = CTypeEnum2Bytes[lastBitFieldType] * 8 - meta[KeyMetaKey.BitFieldLength]\n        }\n      }\n      else {\n        // 不是位域重置（条件 7）\n        lastBitFieldType = CTypeEnum.null\n        bitFieldRemaining = 0\n      }\n\n      lastOffset = offset\n      offset += meta[KeyMetaKey.Array] ? (length * meta[KeyMetaKey.ArrayLength]) : length\n    })\n  }\n\n  // 对结构体大小对齐（条件 3）\n  while (offset % padding !== 0) {\n    offset++\n  }\n\n  return offset\n}\n\n/**\n * 全局的状态收集\n */\nconst keysQueue: string[] = []\nconst keysMeta: Map<string, KeyMeta> = new Map()\n\nexport function CStruct(target: Struct, { kind }) {\n  if (kind === 'class') {\n    definedMetaProperty(target.prototype, symbolStruct, true)\n    definedMetaProperty(target.prototype, symbolStructMaxBaseTypeByteLength, getMaxBaseTypeByteLength(keysMeta))\n    definedMetaProperty(target.prototype, symbolStructLength, layout(keysQueue, keysMeta, target.prototype[symbolStructMaxBaseTypeByteLength]))\n    definedMetaProperty(target.prototype, symbolStructKeysMeta, new Map(keysMeta.entries()))\n  }\n  keysQueue.length = 0\n  keysMeta.clear()\n}\n\nexport function CUnion(target: Union, { kind }) {\n  if (kind === 'class') {\n    definedMetaProperty(target.prototype, symbolStruct, true)\n    definedMetaProperty(target.prototype, symbolStructMaxBaseTypeByteLength, getMaxBaseTypeByteLength(keysMeta))\n    definedMetaProperty(target.prototype, symbolStructLength, getMaxTypeByteLength(keysMeta))\n    definedMetaProperty(target.prototype, symbolStructKeysMeta, new Map(keysMeta.entries()))\n  }\n  keysQueue.length = 0\n  keysMeta.clear()\n}\n\nexport function CType(type: CTypeEnum | Struct) {\n\n  if (is.func(type) && !type.prototype[symbolStruct]) {\n    throw new TypeError(`type ${type.prototype.constructor.name} is not defined to struct`)\n  }\n\n  return function (target: null, { kind, name }) {\n    if (kind === 'field') {\n      if (name[0] === '$') {\n        throw new TypeError('struct property cannot start with $')\n      }\n\n      if (!array.has(keysQueue, name)) {\n        keysQueue.push(name)\n      }\n      const data: KeyMeta = keysMeta.get(name) || {\n        [KeyMetaKey.Type]: CTypeEnum.void,\n        [KeyMetaKey.Pointer]: 0,\n        [KeyMetaKey.PointerLevel]: 0,\n        [KeyMetaKey.Array]: 0,\n        [KeyMetaKey.ArrayLength]: 0,\n        [KeyMetaKey.BitField]: 0,\n        [KeyMetaKey.BitFieldLength]: 0,\n        [KeyMetaKey.BaseAddressOffset]: 0,\n        [KeyMetaKey.BaseBitOffset]: 0\n      }\n\n      data[KeyMetaKey.Type] = type\n\n      keysMeta.set(name, data)\n    }\n  }\n}\n\nexport function CPointer(level: number = 1) {\n\n  if (level < 1) {\n    throw new TypeError('pointer level can not smaller then 1')\n  }\n\n  return function (target: null, { kind, name }) {\n    if (kind === 'field') {\n      if (!array.has(keysQueue, name)) {\n        keysQueue.push(name)\n      }\n      const data: KeyMeta = keysMeta.get(name) || {\n        [KeyMetaKey.Type]: CTypeEnum.void,\n        [KeyMetaKey.Pointer]: 0,\n        [KeyMetaKey.PointerLevel]: 0,\n        [KeyMetaKey.Array]: 0,\n        [KeyMetaKey.ArrayLength]: 0,\n        [KeyMetaKey.BitField]: 0,\n        [KeyMetaKey.BitFieldLength]: 0,\n        [KeyMetaKey.BaseAddressOffset]: 0,\n        [KeyMetaKey.BaseBitOffset]: 0\n      }\n\n      data[KeyMetaKey.Pointer] = 1\n      data[KeyMetaKey.PointerLevel] = level\n\n      keysMeta.set(name, data)\n    }\n  }\n}\n\nexport function CArray(length: number) {\n\n  if (!length) {\n    throw new TypeError('length must not be 0')\n  }\n\n  return function (target: null, { kind, name }) {\n    if (kind === 'field') {\n      if (!array.has(keysQueue, name)) {\n        keysQueue.push(name)\n      }\n      const data: KeyMeta = keysMeta.get(name) || {\n        [KeyMetaKey.Type]: CTypeEnum.void,\n        [KeyMetaKey.Pointer]: 0,\n        [KeyMetaKey.PointerLevel]: 0,\n        [KeyMetaKey.Array]: 0,\n        [KeyMetaKey.ArrayLength]: 0,\n        [KeyMetaKey.BitField]: 0,\n        [KeyMetaKey.BitFieldLength]: 0,\n        [KeyMetaKey.BaseAddressOffset]: 0,\n        [KeyMetaKey.BaseBitOffset]: 0\n      }\n\n      data[KeyMetaKey.Array] = 1\n      data[KeyMetaKey.ArrayLength] = length\n      keysMeta.set(name, data)\n    }\n  }\n}\n\nexport function CBitField(length: number) {\n  return function (target: null, { kind, name }) {\n    if (is.func(target)) {\n      throw new TypeError('bit field can not use for struct')\n    }\n    if (kind === 'field') {\n      if (!array.has(keysQueue, name)) {\n        keysQueue.push(name)\n      }\n      const data: KeyMeta = keysMeta.get(name) || {\n        [KeyMetaKey.Type]: CTypeEnum.void,\n        [KeyMetaKey.Pointer]: 0,\n        [KeyMetaKey.PointerLevel]: 0,\n        [KeyMetaKey.Array]: 0,\n        [KeyMetaKey.ArrayLength]: 0,\n        [KeyMetaKey.BitField]: 0,\n        [KeyMetaKey.BitFieldLength]: 0,\n        [KeyMetaKey.BaseAddressOffset]: 0,\n        [KeyMetaKey.BaseBitOffset]: 0\n      }\n\n      data[KeyMetaKey.BitField] = 1\n      data[KeyMetaKey.BitFieldLength] = length\n\n      keysMeta.set(name, data)\n    }\n  }\n}\n","import ts from 'typescript'\nimport type { KeyMeta } from '../typedef'\nimport { CTypeEnum, KeyMetaKey } from '../typedef'\nimport { getMaxBaseTypeByteLength, getMaxTypeByteLength, layout } from '../cstruct'\nimport { BuiltinType, Type2CTypeEnum } from './defined'\nimport * as constant from './constant'\nimport * as nodeUtil from './util/nodeutil'\nimport statement from './statement'\nimport { object, array } from '@libmedia/common'\n\nexport enum StructType {\n  CSTRUCT,\n  CUNION,\n  INLINE_OBJECT\n}\n\nexport type KeyMetaExt = Omit<KeyMeta, 'getTypeMeta'> & {\n  has: boolean\n  typeIdentifier: string\n  getTypeMeta?: () => Struct\n  symbol: WeakRef<ts.Symbol>\n  name: string\n}\n\nclass WeakRefPolyfill<T extends any> {\n  private _value: T\n  constructor(value: T) {\n    this._value = value\n  }\n  deref() {\n    return this._value\n  }\n  [Symbol.toStringTag]: 'WeakRef'\n}\n\nfunction createWeakRef(value: any) {\n  return typeof WeakRef === 'undefined' ? new WeakRefPolyfill(value) : new WeakRef(value)\n}\n\nexport type Struct = {\n  maxBaseTypeByteLength: number\n  length: number\n  meta: Map<string, KeyMetaExt>\n  symbol: WeakRef<ts.Symbol>\n  parent?: Struct,\n  structType: StructType\n  definedClassParent?: Struct\n  inlineStructPathMap?: WeakMap<ts.Symbol, string>\n  name: string\n}\n\nconst StructMap: WeakMap<ts.Symbol, Struct> = new WeakMap()\nconst StructFileIdentifiers: Map<string, string[]> = new Map()\n\nconst Stack: {\n  struct: Struct\n  treePath: string[]\n  inlineStructPathMap: WeakMap<ts.Symbol, string>\n}[] = []\n\nfunction addFileIdentifier(symbol: ts.Symbol) {\n  if (symbol.valueDeclaration) {\n    const fileName = symbol.valueDeclaration.getSourceFile().fileName\n    if (StructFileIdentifiers.has(fileName)) {\n      const list = StructFileIdentifiers.get(fileName)\n      if (!array.has(list, symbol.name)) {\n        list.push(symbol.name)\n      }\n    }\n    else {\n      StructFileIdentifiers.set(fileName, [symbol.name])\n    }\n  }\n}\n\nfunction isCStruct(node: ts.ClassDeclaration) {\n\n  if (!node) {\n    return false\n  }\n\n  let has = false\n\n  // 检查是否拥有 CStruct\n  array.each(node.modifiers as any as Array<ts.ModifierLike>, (modifier) => {\n    if (modifier.kind === ts.SyntaxKind.Decorator\n      && modifier.expression?.kind === ts.SyntaxKind.Identifier\n      && ((modifier.expression as ts.Identifier).escapedText === constant.cstruct)\n    ) {\n      has = true\n      return false\n    }\n  })\n\n  return has\n}\n\nfunction isCUnion(node: ts.ClassDeclaration) {\n\n  if (!node) {\n    return false\n  }\n\n  let has = false\n\n  // 检查是否拥有 CUnion\n  array.each(node.modifiers as any as Array<ts.ModifierLike>, (modifier) => {\n    if (modifier.kind === ts.SyntaxKind.Decorator\n      && modifier.expression?.kind === ts.SyntaxKind.Identifier\n      && ((modifier.expression as ts.Identifier).escapedText === constant.cunion)\n    ) {\n      has = true\n      return false\n    }\n  })\n\n  return has\n}\n\nfunction analyzeModifiers(list: ts.NodeArray<ts.ModifierLike>, data: KeyMetaExt) {\n  for (let i = 0; i < list.length; i++) {\n    if (list[i].kind === ts.SyntaxKind.Decorator) {\n      const decorator = list[i] as ts.Decorator\n\n      let hasIgnore = false\n\n      if (ts.isCallExpression(decorator.expression) && ts.isIdentifier(decorator.expression.expression)) {\n        const name = decorator.expression.expression.escapedText\n        if (name === constant.ctype) {\n          data.has = true\n          if (ts.isIdentifier(decorator.expression.arguments[0]) || ts.isExpressionWithTypeArguments(decorator.expression.arguments[0])) {\n            data.typeIdentifier = (ts.isIdentifier((decorator.expression as ts.CallExpression).arguments[0])\n              ? ((decorator.expression as ts.CallExpression).arguments[0] as ts.Identifier).escapedText\n              : (((decorator.expression as ts.CallExpression)\n                .arguments[0] as ts.ExpressionWithTypeArguments)\n                .expression as ts.Identifier).escapedText) as string\n            data.getTypeMeta = () => {\n              const type = ts.isIdentifier((decorator.expression as ts.CallExpression).arguments[0])\n                ? statement.typeChecker.getTypeAtLocation((decorator.expression as ts.CallExpression).arguments[0])\n                : statement.typeChecker.getTypeAtLocation(((decorator.expression as ts.CallExpression)\n                  .arguments[0] as ts.ExpressionWithTypeArguments)\n                  .expression)\n              if (type) {\n                return getStruct(type.symbol)\n              }\n              else {\n                return {\n                  maxBaseTypeByteLength: 0,\n                  length: 0,\n                  structType: StructType.CSTRUCT,\n                  meta: null,\n                  symbol: null,\n                  name: ''\n                }\n              }\n            }\n          }\n          else if (decorator.expression.arguments[0].kind === ts.SyntaxKind.ThisKeyword) {\n            data.typeIdentifier = (decorator.parent.parent as ts.ClassDeclaration).name.escapedText as string\n            data.getTypeMeta = () => {\n              const type = statement.typeChecker.getTypeAtLocation(decorator.parent.parent)\n              return getStruct(type.symbol)\n            }\n          }\n          else if (ts.isPropertyAccessExpression(decorator.expression.arguments[0])) {\n            data[KeyMetaKey.Type] = Type2CTypeEnum[decorator.expression.arguments[0].name.escapedText as string]\n          }\n        }\n        else if (name === constant.cpointer) {\n          data[KeyMetaKey.Pointer] = 1\n          if (!decorator.expression.arguments.length) {\n            data[KeyMetaKey.PointerLevel] = 1\n          }\n          else {\n            if (ts.isIdentifier(decorator.expression.arguments[0])) {\n              data[KeyMetaKey.PointerLevel] = +decorator.expression.arguments[0].escapedText\n            }\n          }\n        }\n        else if (name === constant.carray) {\n          data[KeyMetaKey.Array] = 1\n          data[KeyMetaKey.ArrayLength] = 0\n          if (ts.isNumericLiteral(decorator.expression.arguments[0])) {\n            data[KeyMetaKey.ArrayLength] = +decorator.expression.arguments[0].text\n          }\n          else if (ts.isIdentifier(decorator.expression.arguments[0])) {\n            const symbol = statement.typeChecker.getSymbolAtLocation(decorator.expression.arguments[0])\n            if (symbol && ts.isVariableDeclaration(symbol.valueDeclaration) && symbol.valueDeclaration.initializer) {\n              if (ts.isNumericLiteral(symbol.valueDeclaration.initializer)) {\n                data[KeyMetaKey.ArrayLength] = +symbol.valueDeclaration.initializer.text\n              }\n            }\n          }\n          if (Number.isNaN(data[KeyMetaKey.ArrayLength])) {\n            data[KeyMetaKey.ArrayLength] = 0\n          }\n        }\n        else if (name === constant.cbitField) {\n          data[KeyMetaKey.BitField] = 1\n          if (ts.isIdentifier(decorator.expression.arguments[0])) {\n            data[KeyMetaKey.BitFieldLength] = +decorator.expression.arguments[0].escapedText\n          }\n        }\n        else if (name === constant.cignore) {\n          hasIgnore = true\n          if (ts.isCallExpression(decorator.expression)) {\n            if (decorator.expression.arguments.length\n              && !nodeUtil.checkBool(statement.visitor(decorator.expression.arguments[0]) as ts.Node, statement.visitor)\n            ) {\n              hasIgnore = false\n            }\n          }\n        }\n      }\n      else if (ts.isIdentifier(decorator.expression)) {\n        const name = decorator.expression.escapedText\n        if (name === constant.cignore) {\n          hasIgnore = true\n        }\n      }\n\n      if (hasIgnore) {\n        data.has = false\n      }\n    }\n  }\n}\n\nfunction analyzeType(type: ts.Type, data: KeyMetaExt) {\n  if (type.aliasSymbol) {\n    const typeName = type.aliasSymbol.escapedName as string\n    if (typeName === constant.typeArray && type.aliasTypeArguments[1]?.isNumberLiteral()) {\n      data[KeyMetaKey.Array] = 1\n      data[KeyMetaKey.ArrayLength] = (data[KeyMetaKey.ArrayLength] ? data[KeyMetaKey.ArrayLength] : 1) * type.aliasTypeArguments[1].value\n      analyzeType(type.aliasTypeArguments[0], data)\n    }\n    else if (typeName === constant.typeBit && type.aliasTypeArguments[1]?.isNumberLiteral()) {\n      data[KeyMetaKey.BitField] = 1\n      data[KeyMetaKey.BitFieldLength] = type.aliasTypeArguments[1].value\n      analyzeType(type.aliasTypeArguments[0], data)\n    }\n    else if (typeName === constant.typePointer) {\n      data[KeyMetaKey.PointerLevel]++\n      data[KeyMetaKey.Pointer] = 1\n      analyzeType(type.aliasTypeArguments[0], data)\n    }\n    else if (typeName === constant.typeStruct\n      || typeName === constant.typeUnion\n    ) {\n      const struct = getInlineStruct(\n        type.aliasTypeArguments[0],\n        typeName === constant.typeUnion ? StructType.CUNION : StructType.CSTRUCT\n      )\n      if (struct) {\n        data.has = true\n        const stack = Stack[Stack.length - 1]\n        stack.inlineStructPathMap.set(struct.symbol.deref(), stack.treePath.join('.'))\n        data.getTypeMeta = () => {\n          return struct\n        }\n      }\n    }\n    else if (type.aliasSymbol.valueDeclaration\n      && (\n        ts.isEnumDeclaration(type.aliasSymbol.valueDeclaration)\n        || ts.isEnumMember(type.aliasSymbol.valueDeclaration)\n      )\n    ) {\n      data.has = true\n      data[KeyMetaKey.Type] = CTypeEnum.int32\n    }\n    else if (array.has(BuiltinType, typeName)) {\n      data.has = true\n      data[KeyMetaKey.Type] = Type2CTypeEnum[typeName]\n    }\n  }\n  else if (type.symbol\n    && (isCStruct(type.symbol.valueDeclaration as ts.ClassDeclaration)\n      || isCUnion(type.symbol.valueDeclaration as ts.ClassDeclaration)\n    )\n  ) {\n    if (!data[KeyMetaKey.Pointer] && type.symbol === data.symbol.deref()) {\n      data.has = false\n    }\n    else {\n      data.has = true\n      data.typeIdentifier = type.symbol.escapedName as string\n      data.getTypeMeta = () => {\n        return getStruct(type.symbol)\n      }\n    }\n  }\n  else if (type.symbol?.valueDeclaration\n    && (\n      ts.isEnumDeclaration(type.symbol.valueDeclaration)\n      || ts.isEnumMember(type.symbol.valueDeclaration)\n    )\n  ) {\n    data.has = true\n    data[KeyMetaKey.Type] = CTypeEnum.int32\n  }\n  else if (data[KeyMetaKey.Pointer]) {\n    data.has = true\n    data[KeyMetaKey.Type] = CTypeEnum.void\n  }\n  else if (type.isUnion()) {\n    analyzeType(type.types[0], data)\n  }\n}\n\nfunction getInlineStruct(type: ts.Type, structType: StructType) {\n\n  const metaMap = new Map()\n  const metaQueue = []\n\n  if (type.symbol.members) {\n    type.symbol.members.forEach((value, key) => {\n      if (value.flags & ts.SymbolFlags.Property && value.valueDeclaration && ts.isPropertySignature(value.valueDeclaration)) {\n\n        const stack = Stack[Stack.length - 1]\n\n        stack.treePath.push(key as string)\n\n        const metaData: KeyMetaExt = {\n          [KeyMetaKey.Type]: CTypeEnum.void,\n          [KeyMetaKey.Pointer]: 0,\n          [KeyMetaKey.PointerLevel]: 0,\n          [KeyMetaKey.Array]: 0,\n          [KeyMetaKey.ArrayLength]: 0,\n          [KeyMetaKey.BitField]: 0,\n          [KeyMetaKey.BitFieldLength]: 0,\n          [KeyMetaKey.BaseAddressOffset]: 0,\n          [KeyMetaKey.BaseBitOffset]: 0,\n          has: false,\n          typeIdentifier: '',\n          symbol: null,\n          name: key as string\n        }\n\n        analyzeType(statement.typeChecker.getTypeOfSymbol(value), metaData)\n\n        if (metaData.has) {\n          metaMap.set(key as string, metaData)\n          metaQueue.push(key as string)\n        }\n\n        stack.treePath.pop()\n      }\n    })\n  }\n\n  if (metaMap.size) {\n    const maxBaseTypeByteLength = getMaxBaseTypeByteLength(metaMap)\n    if (!maxBaseTypeByteLength) {\n      return null\n    }\n    const length = structType === StructType.CUNION\n      ? getMaxTypeByteLength(metaMap)\n      : layout(metaQueue, metaMap, maxBaseTypeByteLength, 0)\n\n    StructMap.set(type.symbol, {\n      maxBaseTypeByteLength: maxBaseTypeByteLength,\n      length: length,\n      meta: metaMap,\n      symbol: createWeakRef(type.symbol),\n      parent: null,\n      structType: StructType.INLINE_OBJECT,\n      definedClassParent: Stack[Stack.length - 1].struct,\n      name: type.symbol.name\n    })\n    addFileIdentifier(type.symbol)\n    return StructMap.get(type.symbol)\n  }\n  return null\n}\n\nfunction analyze(symbol: ts.Symbol) {\n\n  // 检查是否是类定义\n  if (!symbol.valueDeclaration || !ts.isClassDeclaration(symbol.valueDeclaration)) {\n    StructMap.set(symbol, null)\n    return\n  }\n\n  const valueDeclaration = symbol.valueDeclaration as ts.ClassDeclaration\n\n  if (!isCStruct(valueDeclaration) && !isCUnion(valueDeclaration)) {\n    StructMap.set(symbol, null)\n    return\n  }\n\n\n  const structType = isCUnion(valueDeclaration) ? StructType.CUNION : StructType.CSTRUCT\n  const metaMap = new Map()\n  const metaQueue = []\n\n  const inlineStructPathMap = new WeakMap()\n  const struct = {\n    maxBaseTypeByteLength: 0,\n    length: 0,\n    meta: null,\n    symbol: createWeakRef(symbol),\n    parent: null,\n    structType: structType,\n    name: symbol.name\n  }\n  const treePath = []\n\n  Stack.length = 0\n  Stack.push({\n    treePath,\n    struct,\n    inlineStructPathMap\n  })\n\n  let parentStruct: Struct | null\n\n  if (valueDeclaration.heritageClauses?.length) {\n    for (let i = 0; i < valueDeclaration.heritageClauses.length; i++) {\n      const clause = valueDeclaration.heritageClauses[i]\n      if (clause.token === ts.SyntaxKind.ExtendsKeyword) {\n        if (clause.types.length === 1) {\n          let parentSymbol = statement.typeChecker.getSymbolAtLocation(clause.types[0].expression)\n          parentStruct = StructMap.get(parentSymbol)\n          if (!parentStruct) {\n            analyze(parentSymbol)\n            parentStruct = StructMap.get(parentSymbol)\n          }\n        }\n      }\n    }\n  }\n\n  if (symbol.members) {\n    symbol.members.forEach((value, key) => {\n      if (value.flags & ts.SymbolFlags.Property && value.valueDeclaration && ts.isPropertyDeclaration(value.valueDeclaration)) {\n\n        const valueDeclaration = value.valueDeclaration\n\n        treePath.push(key as string)\n\n        const metaData: KeyMetaExt = {\n          [KeyMetaKey.Type]: CTypeEnum.void,\n          [KeyMetaKey.Pointer]: 0,\n          [KeyMetaKey.PointerLevel]: 0,\n          [KeyMetaKey.Array]: 0,\n          [KeyMetaKey.ArrayLength]: 0,\n          [KeyMetaKey.BitField]: 0,\n          [KeyMetaKey.BitFieldLength]: 0,\n          [KeyMetaKey.BaseAddressOffset]: 0,\n          [KeyMetaKey.BaseBitOffset]: 0,\n          has: false,\n          typeIdentifier: '',\n          symbol: createWeakRef(symbol),\n          name: key as string\n        }\n\n        analyzeType(statement.typeChecker.getTypeOfSymbol(value), metaData)\n\n        if (valueDeclaration.modifiers?.length) {\n          analyzeModifiers(valueDeclaration.modifiers, metaData)\n        }\n\n        if (metaData.has) {\n          metaMap.set(key as string, metaData)\n          metaQueue.push(key as string)\n        }\n\n        treePath.pop()\n      }\n    })\n  }\n\n  if (metaMap.size) {\n    const maxBaseTypeByteLength = Math.max(getMaxBaseTypeByteLength(metaMap), parentStruct?.maxBaseTypeByteLength ?? 0)\n\n    if (!maxBaseTypeByteLength) {\n      StructMap.set(symbol, null)\n      return\n    }\n\n    let offset = 0\n    if (parentStruct) {\n      offset = parentStruct.length\n    }\n    const length = structType === StructType.CUNION\n      ? getMaxTypeByteLength(metaMap)\n      : layout(metaQueue, metaMap, maxBaseTypeByteLength, offset)\n\n    object.extend(struct, {\n      maxBaseTypeByteLength: maxBaseTypeByteLength,\n      length,\n      meta: metaMap,\n      parent: parentStruct,\n      inlineStructPathMap\n    })\n\n    StructMap.set(symbol, struct)\n    addFileIdentifier(symbol)\n  }\n  else {\n    if (parentStruct) {\n      object.extend(struct, {\n        maxBaseTypeByteLength: parentStruct.maxBaseTypeByteLength,\n        length: parentStruct.length,\n        meta: metaMap,\n        parent: parentStruct\n      })\n      StructMap.set(symbol, struct)\n      addFileIdentifier(symbol)\n    }\n    else {\n      StructMap.set(symbol, null)\n    }\n  }\n\n  Stack.pop()\n}\n\nexport function getStruct(symbol: ts.Symbol) {\n  if (!symbol) {\n    return null\n  }\n  if (!StructMap.has(symbol)) {\n    analyze(symbol)\n  }\n  return StructMap.get(symbol)\n}\n\nexport function hasStruct(symbol: ts.Symbol) {\n  const struct = getStruct(symbol)\n  return struct != null\n}\n\nexport function getStructFileIdentifiers(fileName: string) {\n  return StructFileIdentifiers.get(fileName)\n}\n\nexport function clearStructCache() {\n  StructFileIdentifiers.clear()\n}\n","import ts from 'typescript'\nimport * as constant from '../constant'\nimport { CTypeEnum2Type, Type2CTypeEnum } from '../defined'\nimport { CTypeEnum } from '../../typedef'\nimport { getStruct, hasStruct } from '../struct'\nimport { is } from '@libmedia/common'\n\nexport function isCompatibleType(type1: string, type2: string) {\n  if (type1 === constant.typePointer && type2 === constant.typeAnyptr\n    || type1 === constant.typeAnyptr && type2 === constant.typePointer\n  ) {\n    return true\n  }\n  if (type1 === 'any' || type2 === 'any') {\n    return true\n  }\n  if (type1 === 'void' || type2 === 'void') {\n    return true\n  }\n  return type1 === type2\n}\n\nexport function isTypeEquals(type1: ts.Type, node1: ts.Node, type2: ts.Type, node2: ts.Node) {\n\n  if (isPointerType(type1, node1) && isPointerType(type2, node2)) {\n    if (isAnyPointer(type1) || isAnyPointer(type2)) {\n      return true\n    }\n    return getFixTypeByType(type1, node1) === getFixTypeByType(type2, node2)\n      && getPointerLevelByType(type1, node1) === getPointerLevelByType(type2, node2)\n  }\n  else if (isBuiltinType(type1, node1) && isBuiltinType(type2, node2)) {\n    return getBuiltinByType(type1, node1) === getBuiltinByType(type2, node2)\n  }\n  else if (isStructType(type1) && isStructType(type2)) {\n    return getStructByType(type1) === getStructByType(type2)\n  }\n\n  if (type1.symbol && type2.symbol) {\n    return type1.symbol === type2.symbol\n  }\n  else if (type1.aliasSymbol && type2.aliasSymbol) {\n\n    if (type1.aliasSymbol.escapedName === constant.typePointer && type2.aliasSymbol.escapedName === constant.typeAnyptr\n      || type1.aliasSymbol.escapedName === constant.typeAnyptr && type2.aliasSymbol.escapedName === constant.typePointer\n    ) {\n      return true\n    }\n\n    if (!type1.aliasTypeArguments && !type2.aliasTypeArguments) {\n      return isCompatibleType(type1.aliasSymbol.escapedName as string, type2.aliasSymbol.escapedName as string)\n    }\n    if (type1.aliasTypeArguments?.length === type2.aliasTypeArguments?.length) {\n      for (let i = 0; i < type1.aliasTypeArguments.length; i++) {\n        if (!isTypeEquals(type1.aliasTypeArguments[i], null, type2.aliasTypeArguments[i], null)) {\n          return false\n        }\n      }\n      return true\n    }\n    return false\n  }\n  // @ts-ignore\n  else if (type1.intrinsicName && type2.intrinsicName) {\n    // @ts-ignore\n    return type1.intrinsicName === type2.intrinsicName\n  }\n\n  return false\n}\n\nexport function isBuiltinType(type: ts.Type, node: ts.Node) {\n  if (!type) {\n    return false\n  }\n  if (isPointerType(type, node)) {\n    return true\n  }\n  if (type.aliasSymbol) {\n    if (type.aliasSymbol.escapedName === constant.typeAnyptr\n      || type.aliasSymbol.escapedName === constant.typeMultiPointer\n    ) {\n      return true\n    }\n    return is.number(Type2CTypeEnum[type.aliasSymbol.escapedName as string])\n  }\n  if (type.isIntersection()) {\n    const value = getSymbolTypeValue(type.getProperty(constant.typeProperty))\n    if (value) {\n      return is.number(Type2CTypeEnum[value.replace(/\\*$/g, '')])\n    }\n  }\n  return false\n}\n\nexport function isPointerBuiltinType(type: ts.Type, node: ts.Node) {\n  if (!type) {\n    return false\n  }\n  return isPointerType(type, node)\n    && (\n      type.aliasSymbol && type.aliasTypeArguments && isBuiltinType(type.aliasTypeArguments[0], null)\n      || !type.symbol && !type.aliasSymbol && !isPointerStructType(type, node)\n    )\n}\n\nexport function isStructType(type: ts.Type, ignoreLevel: boolean = false) {\n  if (!type) {\n    return false\n  }\n  if (type.symbol) {\n    return hasStruct(type.symbol)\n  }\n  else if (type.aliasSymbol) {\n    return type.aliasSymbol.escapedName === constant.typeStruct\n      || type.aliasSymbol.escapedName === constant.typeUnion\n  }\n  else if (type.isIntersection()) {\n\n    const level = getSymbolTypeValue(type.getProperty(constant.levelProperty))\n\n    if (!ignoreLevel && level && level > 0) {\n      return false\n    }\n\n    // pointer[x]\n    const type_ = type.getProperty(constant.typeProperty)\n    // @ts-ignore\n    if (type_?.links?.type?.symbol) {\n      // @ts-ignore\n      return isStructType(type_.links.type)\n    }\n    // @ts-ignore\n    else if (type_?.links?.type?.aliasSymbol\n      // @ts-ignore\n      && type_?.links?.type?.aliasTypeArguments\n      && (\n        // @ts-ignore\n        type_.links.type.aliasSymbol.escapedName === constant.typeStruct\n        // @ts-ignore\n         || type_.links.type.aliasSymbol.escapedName === constant.typeUnion\n      )\n    ) {\n      // @ts-ignore\n      return isStructType(type_.links.type.aliasTypeArguments[0])\n    }\n\n    // 内联 struct\n    const struct_ = type.getProperty(constant.structProperty)\n    if (struct_) {\n      for (let i = 0; i < type.types.length; i++) {\n        if (type.types[i].symbol && hasStruct(type.types[i].symbol)) {\n          return true\n        }\n      }\n    }\n  }\n  return false\n}\n\nexport function isAnyPointer(type: ts.Type) {\n  if (type.aliasSymbol) {\n    return type.aliasSymbol.escapedName === constant.typeAnyptr\n  }\n  return false\n}\n\nexport function isArrayType(type: ts.Type) {\n  return type.aliasSymbol\n    && type.aliasSymbol.escapedName === constant.typeArray\n    && type.aliasTypeArguments[1]?.isNumberLiteral()\n}\n\nexport function isNullPointer(type: ts.Type, node: ts.Node) {\n  if (type.aliasSymbol) {\n    return type.aliasSymbol.escapedName === constant.typeNullptr\n  }\n  else if (node && ts.isIdentifier(node)) {\n    return node.escapedText === constant.typeNullptr\n  }\n  return false\n}\n\nexport function isMultiPointer(type: ts.Type) {\n  if (type.aliasSymbol) {\n    return type.aliasSymbol.escapedName === constant.typeMultiPointer\n  }\n  return false\n}\n\nexport function isPointerType(type: ts.Type, node: ts.Node) {\n  if (!type) {\n    return false\n  }\n\n  if (isAnyPointer(type) || isMultiPointer(type) || isNullPointer(type, node)) {\n    return true\n  }\n  if (type.aliasSymbol) {\n    return type.aliasSymbol.escapedName === constant.typePointer\n  }\n  if (type.symbol) {\n    return type.symbol.escapedName === constant.typePointer\n  }\n  if (type.isIntersection()) {\n    const value = getSymbolTypeValue(type.getProperty(constant.levelProperty))\n    if (value != null) {\n      return value > 0\n    }\n  }\n  return false\n}\n\nexport function isSizeType(type: ts.Type, union: boolean = false) {\n  if (!type) {\n    return false\n  }\n  if (type.aliasSymbol) {\n    return type.aliasSymbol.escapedName === constant.typeSize\n  }\n  else if (type.isIntersection()) {\n    const value = getSymbolTypeValue(type.getProperty(constant.typeProperty))\n    if (value === constant.typeSize) {\n      return true\n    }\n  }\n  else if (union && type.isUnion()) {\n    for (let i = 0; i < type.types.length; i++) {\n      if (isSizeType(type.types[i])) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nexport function isPointerStructType(type: ts.Type, node: ts.Node) {\n  if (!type) {\n    return false\n  }\n  if (isPointerType(type, node)) {\n    if (isAnyPointer(type) || isMultiPointer(type)) {\n      return false\n    }\n    if (type.aliasSymbol && type.aliasTypeArguments) {\n      return isStructType(type.aliasTypeArguments[0])\n    }\n    else if (!type.symbol && !type.aliasSymbol && type.isIntersection()) {\n      const level = getSymbolTypeValue(type.getProperty(constant.levelProperty))\n      if (level && level > 1) {\n        return false\n      }\n      return isStructType(type, true)\n    }\n  }\n  return false\n}\n\nexport function getStructByType(type: ts.Type) {\n  if (type.aliasSymbol && type.aliasTypeArguments) {\n    if (type.aliasSymbol.escapedName === constant.typeStruct\n      || type.aliasSymbol.escapedName === constant.typeUnion\n      || type.aliasSymbol.escapedName === constant.typeArray\n      || type.aliasSymbol.escapedName === constant.typePointer\n      || type.aliasSymbol.escapedName === constant.sharedPtr\n    ) {\n      return getStructByType(type.aliasTypeArguments[0])\n    }\n  }\n  else if (type.symbol) {\n    return getStruct(type.symbol)\n  }\n  else if (type.isIntersection()) {\n    // pointer[x]\n    const type_ = type.getProperty(constant.typeProperty)\n    // @ts-ignore\n    if (type_?.links?.type?.symbol) {\n      // @ts-ignore\n      return getStructByType(type_.links.type)\n    }\n    // @ts-ignore\n    else if (type_?.links?.type?.aliasSymbol\n      // @ts-ignore\n      && type_?.links?.type?.aliasTypeArguments\n      && (\n        // @ts-ignore\n        type_.links.type.aliasSymbol.escapedName === constant.typeStruct\n        // @ts-ignore\n         || type_.links.type.aliasSymbol.escapedName === constant.typeUnion\n      )\n    ) {\n      // @ts-ignore\n      return getStructByType(type_.links.type.aliasTypeArguments[0])\n    }\n\n    // 内联 struct\n    const struct_ = type.getProperty(constant.structProperty)\n    if (struct_) {\n      for (let i = 0; i < type.types.length; i++) {\n        if (type.types[i].symbol && hasStruct(type.types[i].symbol)) {\n          return getStruct(type.types[i].symbol)\n        }\n      }\n    }\n  }\n}\n\nexport function getPointerStructByType(type: ts.Type, node: ts.Node) {\n\n  if (getPointerLevelByType(type, node) > 1) {\n    return null\n  }\n  return type.aliasSymbol && type.aliasTypeArguments && !isPointerType(type.aliasTypeArguments[0], null) && getStructByType(type.aliasTypeArguments[0])\n    || !type.symbol && !type.aliasSymbol && getStructByType(type)\n}\n\nexport function getSmartPointerStructByType(type: ts.Type) {\n  return type.aliasSymbol && type.aliasTypeArguments?.length === 1 && getStruct(type.aliasTypeArguments[0].symbol)\n}\n\nexport function getBuiltinNameByType(type: ts.Type) {\n  if (type.aliasSymbol) {\n    return type.aliasSymbol.escapedName as string\n  }\n  if (type.isIntersection()) {\n    const value = getSymbolTypeValue(type.getProperty(constant.typeProperty))\n    if (value) {\n      if (/\\*+$/.test(value)) {\n        return CTypeEnum2Type[CTypeEnum.pointer]\n      }\n      return value\n    }\n  }\n}\n\nexport function getBuiltinByType(type: ts.Type, node: ts.Node) {\n  if (isPointerType(type, node)) {\n    return CTypeEnum.pointer\n  }\n  const name = getBuiltinNameByType(type)\n  if (name) {\n    return Type2CTypeEnum[name]\n  }\n}\n\nexport function getPointerBuiltinByType(type: ts.Type, node: ts.Node) {\n  let builtinType = type.aliasSymbol && type.aliasTypeArguments && getBuiltinByType(type.aliasTypeArguments[0], null)\n  if (!is.number(builtinType) && !type.symbol && !type.aliasSymbol && type.isIntersection()) {\n\n    if (getPointerLevelByType(type, node) > 1) {\n      return CTypeEnum.pointer\n    }\n\n    const value = getSymbolTypeValue(type.getProperty(constant.typeProperty))\n    if (value) {\n      if (/\\*{2}$/.test(value)) {\n        return CTypeEnum.pointer\n      }\n      return Type2CTypeEnum[value.replace(/\\**$/, '')]\n    }\n  }\n  return builtinType\n}\n\nexport function getFixTypeByType(type: ts.Type, node: ts.Node) {\n  if (isPointerType(type, node)) {\n    if (type.aliasSymbol && type.aliasTypeArguments) {\n      return getFixTypeByType(type.aliasTypeArguments[0], null)\n    }\n    else {\n      const value = getSymbolTypeValue(type.getProperty(constant.typeProperty))\n      if (value) {\n        return Type2CTypeEnum[value.replace(/\\**$/, '')]\n      }\n      else {\n        return getStructByType(type)\n      }\n    }\n  }\n  else if (isStructType(type)) {\n    return getStructByType(type)\n  }\n  else if (isBuiltinType(type, node)) {\n    return getBuiltinByType(type, node)\n  }\n}\n\nexport function getPointerLevelByType(type: ts.Type, node: ts.Node) {\n  if (isPointerType(type, node) && type.isIntersection()) {\n    const value = getSymbolTypeValue(type.getProperty(constant.levelProperty))\n    if (value) {\n      return value\n    }\n  }\n  return 0\n}\n\nexport function isSmartPointerType(type: ts.Type) {\n  if (!type) {\n    return false\n  }\n  if (type.aliasSymbol) {\n    const value = getSymbolTypeValue(type.getProperty(constant.typeProperty))\n    return type.aliasSymbol.escapedName === constant.sharedPtr && value === constant.sharedPtr\n  }\n  return false\n}\n\nfunction getSymbolTypeValue(type: ts.Symbol) {\n  if (!type) {\n    return\n  }\n  // @ts-ignore\n  if (type?.links?.type?.value) {\n    // @ts-ignore\n    return type.links.type.value\n  }\n  // @ts-ignore\n  else if (type?.valueDeclaration?.type?.literal) {\n    // @ts-ignore\n    return type.valueDeclaration.type.literal.text\n  }\n}\n","import ts from 'typescript'\nimport * as constant from '../constant'\nimport statement from '../statement'\nimport * as typeUtils from './typeutil'\nimport { AtomicCall, BuiltinBigInt, BuiltinFloat, BuiltinType, BuiltinUint } from '../defined'\nimport { atomicsPath } from '../constant'\nimport { is, array } from '@libmedia/common'\n\nexport function getEqualsBinaryExpressionRight(node: ts.BinaryExpression) {\n  if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {\n    return getEqualsBinaryExpressionRight(node.right as ts.BinaryExpression)\n  }\n  return node\n}\n\n\nexport function isExpressionPointer(node: ts.PropertyAccessExpression | ts.Identifier) {\n  let root = getPropertyAccessExpressionRootNode(node)\n\n  while (root && root !== node) {\n    const type = statement.typeChecker.getTypeAtLocation(root)\n    if (typeUtils.isPointerType(type, root)) {\n      return true\n    }\n    root = root.parent\n  }\n\n  if (!root) {\n    return false\n  }\n\n  const type = statement.typeChecker.getTypeAtLocation(root)\n  if (typeUtils.isPointerType(type, root)) {\n    return true\n  }\n\n  return false\n}\n\nexport function isExpressionSmartPointer(node: ts.PropertyAccessExpression | ts.Identifier) {\n  let root = getPropertyAccessExpressionRootNode(node)\n\n  while (root && root !== node) {\n    const type = statement.typeChecker.getTypeAtLocation(root)\n    if (typeUtils.isSmartPointerType(type)) {\n      return true\n    }\n    root = root.parent\n  }\n\n  if (!root) {\n    return false\n  }\n\n  const type = statement.typeChecker.getTypeAtLocation(root)\n  if (typeUtils.isSmartPointerType(type)) {\n    return true\n  }\n\n  return false\n}\n\nexport function getSizeExpressionType(node: ts.Node) {\n  if (ts.isBinaryExpression(node)) {\n    const type = statement.typeChecker.getTypeAtLocation(node.right)\n    if (typeUtils.isSizeType(type)) {\n      return type\n    }\n    return getSizeExpressionType(node.left)\n  }\n  return statement.typeChecker.getTypeAtLocation(node)\n}\n\nexport function getPointerExpressionType(node: ts.Node) {\n  if (ts.isBinaryExpression(node)) {\n    const type = statement.typeChecker.getTypeAtLocation(node.right)\n    if (typeUtils.isPointerType(type, node.right)) {\n      return type\n    }\n    return getPointerExpressionType(node.left)\n  }\n  return statement.typeChecker.getTypeAtLocation(node)\n}\n\nexport function isPointerNode(node: ts.Node) {\n\n  if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {\n    return isPointerNode(node.left) || isPointerNode(node.right)\n  }\n\n  // 检查表达式类型\n  let type = statement.typeChecker.getTypeAtLocation(node)\n  if (typeUtils.isPointerType(type, node)) {\n    return true\n  }\n  // 检查二元操作符 (pointer 参与的运算结果为 pointer)\n  type = getPointerExpressionType(node)\n  if (typeUtils.isPointerType(type, node)) {\n    return true\n  }\n\n  // 检查属性访问中是否有 pointer\n  if (ts.isPropertyAccessExpression(node)) {\n    return isExpressionPointer(node)\n  }\n  // xx.xx[]\n  else if (ts.isElementAccessExpression(node) && ts.isPropertyAccessExpression(node.expression)) {\n    return isExpressionPointer(node.expression)\n  }\n  // xx[][]\n  else if (ts.isElementAccessExpression(node)) {\n    return isPointerNode(node.expression)\n  }\n  return false\n}\n\nexport function isSmartPointerNode(node: ts.Node) {\n  // 检查表达式类型\n  let type = statement.typeChecker.getTypeAtLocation(node)\n  if (typeUtils.isSmartPointerType(type)) {\n    return true\n  }\n  if (ts.isPropertyAccessExpression(node)) {\n    return isExpressionSmartPointer(node)\n  }\n  else if (ts.isElementAccessExpression(node) && ts.isPropertyAccessExpression(node.expression)) {\n    return isExpressionSmartPointer(node.expression)\n  }\n  else if (ts.isElementAccessExpression(node)) {\n    return isSmartPointerNode(node.expression)\n  }\n  return false\n}\n\nexport function isJSDocTypeAlias(node: ts.Node) {\n  return node.kind === ts.SyntaxKind.JSDocTypedefTag || node.kind === ts.SyntaxKind.JSDocCallbackTag || node.kind === ts.SyntaxKind.JSDocEnumTag\n}\n\nexport function getContainerNode(node: ts.Node) {\n  if (isJSDocTypeAlias(node)) {\n    node = node.parent.parent\n  }\n  while (true) {\n    node = node.parent\n    if (!node) {\n      return void 0\n    }\n    switch (node.kind) {\n      case ts.SyntaxKind.SourceFile:\n      case ts.SyntaxKind.MethodDeclaration:\n      case ts.SyntaxKind.MethodSignature:\n      case ts.SyntaxKind.FunctionDeclaration:\n      case ts.SyntaxKind.FunctionExpression:\n      case ts.SyntaxKind.GetAccessor:\n      case ts.SyntaxKind.SetAccessor:\n      case ts.SyntaxKind.ClassDeclaration:\n      case ts.SyntaxKind.InterfaceDeclaration:\n      case ts.SyntaxKind.EnumDeclaration:\n      case ts.SyntaxKind.ModuleDeclaration:\n        return node\n    }\n  }\n}\n\nexport function isParseTreeNode(node: ts.Node) {\n  return (node.flags & ts.NodeFlags.Synthesized) === 0\n}\nexport function getParseTreeNode(node: ts.Node, nodeTest?: (node: ts.Node) => boolean) {\n  if (node == null || isParseTreeNode(node)) {\n    return node\n  }\n  node = ts.getOriginalNode(node)\n  while (node) {\n    if (isParseTreeNode(node)) {\n      return !nodeTest || nodeTest(node) ? node : undefined\n    }\n    node = ts.getOriginalNode(node)\n  }\n}\n\nexport function isPointerIndexOfCall(node: ts.CallExpression) {\n  if (ts.isPropertyAccessExpression(node.expression)) {\n    const type = statement.typeChecker.getTypeAtLocation(node.expression.expression)\n    return typeUtils.isPointerType(type, node.expression.expression) && node.expression.name.escapedText === constant.indexOf\n  }\n  return false\n}\n\nexport function isPointerElementAccess(node: ts.Node) {\n  return ts.isElementAccessExpression(node) && isPointerNode(node.expression)\n}\n\nexport function isSmartPointerElementAccess(node: ts.Node) {\n  return ts.isElementAccessExpression(node) && isSmartPointerNode(node.expression)\n}\n\nexport function getPropertyAccessExpressionRootNode(node: ts.Node) {\n  if (ts.isPropertyAccessExpression(node)\n   || ts.isCallExpression(node)\n   || ts.isElementAccessExpression(node)\n  ) {\n    return getPropertyAccessExpressionRootNode(node.expression)\n  }\n  return node\n}\n\nexport function getParameterDefaultValue(symbol: ts.Symbol, index: number) {\n  const declarations = symbol.declarations\n  if (declarations?.length) {\n    for (let i = 0; i < declarations.length; i++) {\n      const declaration = declarations[i]\n      if ((ts.isFunctionDeclaration(declaration)\n          || ts.isMethodDeclaration(declaration)\n      )\n        && declaration.parameters\n        && declaration.parameters[index]?.initializer\n      ) {\n        return declaration.parameters[index].initializer\n      }\n    }\n  }\n}\n\nexport function checkBool(node: ts.Node, visitor: ts.Visitor) {\n  function compute(node: ts.Node) {\n    if (ts.isParenthesizedExpression(node)) {\n      return ts.visitNode(node.expression, compute)\n    }\n    else if (ts.isPrefixUnaryExpression(node)) {\n      if (node.operator === ts.SyntaxKind.ExclamationToken) {\n        return !ts.visitNode(node.operand, compute)\n      }\n      return true\n    }\n    else if (ts.isBinaryExpression(node)) {\n      const left = ts.visitNode(node.left, compute)\n      const right = ts.visitNode(node.right, compute)\n\n      if (node.operatorToken.kind === ts.SyntaxKind.AmpersandAmpersandToken) {\n        return left && right\n      }\n      else if (node.operatorToken.kind === ts.SyntaxKind.BarBarToken) {\n        return left || right\n      }\n      return true\n    }\n    else {\n      const newNode = ts.visitNode(node, visitor)\n      if (newNode.kind === ts.SyntaxKind.TrueKeyword) {\n        return true\n      }\n      else if (newNode.kind === ts.SyntaxKind.FalseKeyword) {\n        return false\n      }\n      else if (ts.isNumericLiteral(newNode)) {\n        return (+newNode.text) !== 0\n      }\n      else if (ts.isStringLiteral(newNode)) {\n        return newNode.text !== ''\n      }\n      return true\n    }\n  }\n  return ts.visitNode(node, compute)\n}\n\nexport function getBinaryBuiltinTypeName(node: ts.Expression | ts.Identifier) {\n  if (!node) {\n    return ''\n  }\n  const type = statement.typeChecker.getTypeAtLocation(node)\n\n  if (typeUtils.isSizeType(type)) {\n    return statement.cheapCompilerOptions.defined.WASM_64 ? 'uint64' : 'uint32'\n  }\n  else if (type.aliasSymbol && array.has(BuiltinType, type.aliasSymbol.escapedName as string)) {\n    return type.aliasSymbol.escapedName as string\n  }\n  else if (typeUtils.isPointerType(type, node)) {\n    return statement.cheapCompilerOptions.defined.WASM_64 ? 'uint64' : 'uint32'\n  }\n\n  if (node.kind === ts.SyntaxKind.TrueKeyword || node.kind === ts.SyntaxKind.FalseKeyword) {\n    return 'bool'\n  }\n\n  if (ts.isBinaryExpression(node)) {\n    const leftType = getBinaryBuiltinTypeName(node.left)\n    const rightType = getBinaryBuiltinTypeName(node.right)\n    if (array.has(BuiltinFloat, leftType)) {\n      return leftType\n    }\n    if (array.has(BuiltinFloat, rightType)) {\n      return rightType\n    }\n    if (array.has(BuiltinBigInt, leftType)) {\n      if (node.operatorToken.kind === ts.SyntaxKind.MinusToken) {\n        return 'int64'\n      }\n      return leftType\n    }\n    if (array.has(BuiltinBigInt, rightType)) {\n      if (node.operatorToken.kind === ts.SyntaxKind.MinusToken) {\n        return 'int64'\n      }\n      return rightType\n    }\n\n    if (node.operatorToken.kind === ts.SyntaxKind.MinusToken) {\n      return 'int32'\n    }\n    return 'uint32'\n  }\n\n  if (type.flags & ts.TypeFlags.BigInt || type.flags & ts.TypeFlags.BigIntLiteral) {\n    if (type.flags & ts.TypeFlags.BigIntLiteral) {\n      if (node.parent && ts.isPrefixUnaryExpression(node.parent) && node.parent.operator === ts.SyntaxKind.MinusToken) {\n        return 'int64'\n      }\n    }\n    if (type.flags & ts.TypeFlags.BigInt) {\n      if (ts.isCallExpression(node) && node.arguments[0]) {\n        const type = getBinaryBuiltinTypeName(node.arguments[0])\n        if (!array.has(BuiltinUint, type)) {\n          return 'int64'\n        }\n      }\n    }\n    return 'uint64'\n  }\n\n  if (type.flags & ts.TypeFlags.Enum || type.flags & ts.TypeFlags.EnumLiteral) {\n    return 'int32'\n  }\n\n  if (type.flags & ts.TypeFlags.Number || type.flags & ts.TypeFlags.NumberLiteral) {\n\n    if (type.flags & ts.TypeFlags.NumberLiteral) {\n      // @ts-ignore\n      if ((type.value + '').indexOf('.') > -1) {\n        return 'double'\n      }\n      if (node.parent && ts.isPrefixUnaryExpression(node.parent) && node.parent.operator === ts.SyntaxKind.MinusToken) {\n        return 'int32'\n      }\n\n      if (type.flags & ts.TypeFlags.Number) {\n        if (ts.isCallExpression(node) && node.arguments[0]) {\n          const type = getBinaryBuiltinTypeName(node.arguments[0])\n          if (!array.has(BuiltinUint, type)) {\n            return 'int32'\n          }\n        }\n      }\n      return 'uint32'\n    }\n    return 'double'\n  }\n  if (type.isUnion()) {\n    for (let i = 0; i < type.types.length; i++) {\n      if (type.types[i].aliasSymbol && array.has(BuiltinType, type.types[i].aliasSymbol.escapedName as string)) {\n        return type.types[i].aliasSymbol.escapedName as string\n      }\n    }\n  }\n  return ''\n}\n\nexport function getParentMethodDeclaration(node: ts.ClassDeclaration | ts.InterfaceDeclaration, method: string): ts.MethodDeclaration {\n  if (node.members?.length) {\n    for (let i = 0; i < node.members.length; i++) {\n      if (ts.isMethodDeclaration(node.members[i])\n        && ts.isIdentifier(node.members[i].name)\n        && (node.members[i].name as ts.Identifier).escapedText === method\n      ) {\n        return node.members[i] as ts.MethodDeclaration\n      }\n    }\n  }\n  if (node.heritageClauses) {\n    for (let i = 0; i < node.heritageClauses.length; i++) {\n      const types = node.heritageClauses[i].types\n      for (let j = 0; j < types.length; j++) {\n        if (ts.isExpressionWithTypeArguments(types[j])) {\n          const type = statement.typeChecker.getTypeAtLocation(types[j].expression)\n          if (type?.symbol\n            && type.symbol.valueDeclaration\n            && (ts.isClassDeclaration(type.symbol.valueDeclaration)\n              || ts.isInterfaceDeclaration(type.symbol.valueDeclaration)\n            )\n          ) {\n            const declaration = getParentMethodDeclaration(type.symbol.valueDeclaration, method)\n            if (declaration) {\n              return declaration\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nexport function isSynchronizeFunction(node: ts.FunctionDeclaration | ts.FunctionExpression | ts.ArrowFunction | ts.MethodDeclaration) {\n  if (!node) {\n    return false\n  }\n  if (node.modifiers) {\n    for (let i = 0; i < node.modifiers.length; i++) {\n      const modifier = node.modifiers[i]\n      if (ts.isDecorator(modifier)\n        && ts.isIdentifier(modifier.expression)\n        && modifier.expression.escapedText === constant.cdeasync\n      ) {\n        return true\n      }\n    }\n  }\n  if (node.name && ts.isIdentifier(node.name) && ts.isClassDeclaration(node.parent) && node.parent.heritageClauses) {\n    for (let i = 0; i < node.parent.heritageClauses.length; i++) {\n      for (let i = 0; i < node.parent.heritageClauses.length; i++) {\n        const types = node.parent.heritageClauses[i].types\n        for (let j = 0; j < types.length; j++) {\n          if (ts.isExpressionWithTypeArguments(types[j])) {\n            const type = statement.typeChecker.getTypeAtLocation(types[j].expression)\n            if (type?.symbol\n              && type.symbol.valueDeclaration\n              && (ts.isClassDeclaration(type.symbol.valueDeclaration)\n                || ts.isInterfaceDeclaration(type.symbol.valueDeclaration)\n              )\n            ) {\n              const declaration = getParentMethodDeclaration(type.symbol.valueDeclaration, node.name.escapedText as string)\n              if (declaration) {\n                return isSynchronizeFunction(declaration)\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  return false\n}\n\nexport function isAtomicCallExpression(node: ts.CallExpression) {\n  const callName = ts.isPropertyAccessExpression(node.expression)\n    ? node.expression.name.escapedText\n    : (ts.isIdentifier(node.expression)\n      ? node.expression.escapedText\n      : ''\n    )\n\n  if (!array.has(AtomicCall, callName as string)) {\n    return false\n  }\n\n  const symbol = statement.typeChecker.getSymbolAtLocation(node.expression)\n  const file = symbol.valueDeclaration.getSourceFile()\n  const atomicPathReg = new RegExp(`${atomicsPath}\\\\.ts$`)\n  return atomicPathReg.test(file.fileName)\n    || file.fileName.indexOf(constant.PACKET_NAME) >= 0\n      && file.fileName.indexOf(atomicsPath.replace(constant.PACKET_NAME, '')) >= 0\n}\n\nexport function checkConditionCompile(node: ts.Node) {\n  if (ts.isParenthesizedExpression(node)) {\n    return ts.visitNode(node.expression, checkConditionCompile)\n  }\n  else if (ts.isPrefixUnaryExpression(node)) {\n    return ts.visitNode(node.operand, checkConditionCompile)\n  }\n  else if (ts.isBinaryExpression(node)) {\n    const left = ts.visitNode(node.left, checkConditionCompile)\n    if (!left) {\n      return false\n    }\n    return ts.visitNode(node.right, checkConditionCompile)\n  }\n  if (ts.isCallExpression(node) && ts.isIdentifier(node.expression) && (node.expression.escapedText as string) === constant.defined\n    || node.kind === ts.SyntaxKind.TrueKeyword\n    || node.kind === ts.SyntaxKind.FalseKeyword\n  ) {\n    return true\n  }\n  else {\n    return false\n  }\n}\n\nexport function hasDefined(node: ts.Node) {\n  if (ts.isParenthesizedExpression(node)) {\n    return ts.visitNode(node.expression, hasDefined)\n  }\n  else if (ts.isPrefixUnaryExpression(node)) {\n    return ts.visitNode(node.operand, hasDefined)\n  }\n  else if (ts.isBinaryExpression(node)) {\n    return ts.visitNode(node.left, hasDefined) || ts.visitNode(node.right, hasDefined)\n  }\n  if (ts.isCallExpression(node) && ts.isIdentifier(node.expression) && (node.expression.escapedText as string) === constant.defined) {\n    return true\n  }\n  else {\n    return false\n  }\n}\n\nexport function createBitInt(value: number) {\n  if (statement.cheapCompilerOptions.defined.BIGINT_LITERAL) {\n    return statement.context.factory.createBigIntLiteral(value + 'n')\n  }\n  return statement.context.factory.createCallExpression(\n    statement.context.factory.createIdentifier('BigInt'),\n    undefined,\n    [\n      statement.context.factory.createNumericLiteral(value)\n    ]\n  )\n}\n\nexport function createPointerOperand(value: number | ts.Expression) {\n  if (is.number(value)) {\n    if (statement.cheapCompilerOptions.defined.WASM_64) {\n      return createBitInt(value)\n    }\n    return statement.context.factory.createNumericLiteral(value)\n  }\n  else if (ts.isNumericLiteral(value)) {\n    if (statement.cheapCompilerOptions.defined.WASM_64) {\n      return createBitInt(+value.text)\n    }\n    return value\n  }\n  else if (isBigIntNode(value)) {\n    const num = getBigIntValue(value as ts.CallExpression)\n    if (statement.cheapCompilerOptions.defined.WASM_64) {\n      return createBitInt(Number(num))\n    }\n    return statement.context.factory.createNumericLiteral(Number(num))\n  }\n  else {\n    const typeName = getBinaryBuiltinTypeName(value)\n    if (statement.cheapCompilerOptions.defined.WASM_64\n      && (!typeName || !array.has(BuiltinBigInt, typeName) && typeName !== constant.typeSize)\n    ) {\n      return statement.context.factory.createCallExpression(\n        statement.context.factory.createIdentifier('BigInt'),\n        undefined,\n        [\n          value\n        ]\n      )\n    }\n    return value\n  }\n}\n\nexport function isBigIntNode(node: ts.Node) {\n  return ts.isBigIntLiteral(node)\n    || ts.isCallExpression(node)\n      && ts.isIdentifier(node.expression)\n      && node.expression.escapedText === 'BigInt'\n      && node.arguments.length === 1\n      && ts.isNumericLiteral(node.arguments[0])\n}\n\nexport function getBigIntValue(node: ts.BigIntLiteral | ts.CallExpression) {\n  if (ts.isBigIntLiteral(node)) {\n    return BigInt(node.text.substring(0, node.text.length - 1))\n  }\n  else {\n    return BigInt((node.arguments[0] as ts.NumericLiteral).text)\n  }\n}\n\nexport function getTypeAtLocation(node: ts.Node) {\n  if (node.pos >= 0) {\n    return statement.typeChecker.getTypeAtLocation(node)\n  }\n  if (ts.isParenthesizedExpression(node)) {\n    return getTypeAtLocation(node.expression)\n  }\n  return statement.typeChecker.getTypeAtLocation(node)\n}\n\nexport function isNullPointerNode(node: ts.Node) {\n  return ts.isIdentifier(node) && node.escapedText === constant.typeNullptr\n}\n","\nimport ts from 'typescript'\nimport { array } from '@libmedia/common'\nimport statement, { BlockType } from '../statement'\nimport * as nodeUtils from '../util/nodeutil'\n\nexport default function (node: ts.Block, visitor: ts.Visitor): ts.Node {\n\n  let type = BlockType.UNKNOWN\n\n  if (node.parent) {\n    if (ts.isFunctionDeclaration(node.parent)\n      || ts.isFunctionExpression(node.parent)\n      || ts.isArrowFunction(node.parent)\n      || ts.isMethodDeclaration(node.parent)\n    ) {\n      type = BlockType.FUNCTION\n    }\n    else if (ts.isIfStatement(node.parent)) {\n      type = BlockType.IF\n    }\n    else if (ts.isForStatement(node.parent) || ts.isForOfStatement(node.parent) || ts.isWhileStatement(node.parent)) {\n      type = BlockType.LOOP\n    }\n  }\n\n  statement.pushStack(type)\n\n  if (statement.cheapCompilerOptions.defined.ENABLE_SYNCHRONIZE_API\n    && node.parent\n    && (ts.isFunctionDeclaration(node.parent)\n      || ts.isFunctionExpression(node.parent)\n      || ts.isArrowFunction(node.parent)\n      || ts.isMethodDeclaration(node.parent)\n    )\n    && nodeUtils.isSynchronizeFunction(node.parent)\n  ) {\n    statement.getCurrentStack().synchronize = true\n  }\n\n  let nodes = ts.visitEachChild(node, visitor, statement.context)\n\n  const stack = statement.getCurrentStack()\n\n  const updatedStatements = []\n  array.each(stack.topDeclaration, (item) => {\n    updatedStatements.push(statement.context.factory.createVariableStatement(\n      undefined,\n      statement.context.factory.createVariableDeclarationList([\n        statement.context.factory.createVariableDeclaration(item.formatName, undefined, undefined, item.initializer)\n      ])\n    ))\n  })\n\n  if (updatedStatements.length) {\n    nodes = statement.context.factory.createBlock(\n      [...updatedStatements, ...nodes.statements],\n      true\n    )\n  }\n\n  statement.popStack()\n\n  return nodes\n}\n","\nimport ts from 'typescript'\nimport statement, { StageStatus } from '../statement'\nimport { CTypeEnum2Type, Type2CTypeEnum } from '../defined'\nimport { CTypeEnum } from '../../typedef'\nimport * as nodeUtil from '../util/nodeutil'\nimport { is } from '@libmedia/common'\n\nexport default function (node: ts.Identifier, visitor: ts.Visitor): ts.Node | ts.Node[] {\n  if ((statement.lookupStage(StageStatus.Parameter) || statement.lookupStage(StageStatus.VariableDeclaration))\n    && node.parent\n    && (\n      ts.isVariableDeclaration(node.parent) && node.parent.name === node\n      || ts.isBindingElement(node.parent) && node.parent.name === node\n      || ts.isParameter(node.parent) && node.parent.name === node\n    )\n  ) {\n    statement.getCurrentStack().locals.set(node.escapedText as string, statement.typeChecker.getSymbolAtLocation(node))\n  }\n\n  let parent = node.parent\n\n  if (parent && ts.isAsExpression(parent)) {\n    parent = node.parent.parent\n  }\n\n  if (node.escapedText === CTypeEnum2Type[CTypeEnum.null]\n    && !statement.lookupLocal(node.escapedText)\n    && parent && ((parent as ts.VariableDeclaration).initializer === node\n      || ts.isBinaryExpression(parent)\n      || ts.isCallExpression(parent)\n      || ts.isReturnStatement(parent)\n      || ts.isConditionalExpression(parent)\n      || ts.isCaseClause(parent)\n      || ts.isComputedPropertyName(parent)\n      || ts.isArrayLiteralExpression(parent)\n      || ts.isAsExpression(parent)\n      || statement.getCurrentStage()?.stage === StageStatus.SingleArrowRight && !ts.isTypeReferenceNode(parent)\n  )\n  ) {\n    if (statement.cheapCompilerOptions.defined.WASM_64) {\n      return nodeUtil.createBitInt(0)\n    }\n    else {\n      return statement.context.factory.createNumericLiteral(0)\n    }\n  }\n  else if (is.number(Type2CTypeEnum[node.escapedText as string])\n    && !statement.lookupLocal(node.escapedText as string)\n    && parent && (\n    (parent as ts.VariableDeclaration).initializer === node\n        || ts.isBinaryExpression(parent)\n        || (ts.isCallExpression(parent) && parent.expression !== node)\n        || ts.isReturnStatement(parent)\n        || ts.isConditionalExpression(parent)\n        || ts.isCaseClause(parent)\n        || ts.isComputedPropertyName(parent)\n        || ts.isElementAccessExpression(parent) && parent.argumentExpression === node\n        || statement.getCurrentStage()?.stage === StageStatus.SingleArrowRight && !ts.isTypeReferenceNode(parent)\n  )\n  ) {\n    return statement.context.factory.createNumericLiteral(Type2CTypeEnum[node.escapedText as string])\n  }\n  return ts.visitEachChild(node, visitor, statement.context)\n}\n","\nimport ts from 'typescript'\nimport statement from '../statement'\nimport { BuiltinDecorator } from '../defined'\nimport * as nodeUtils from '../util/nodeutil'\nimport { array } from '@libmedia/common'\n\nexport default function (node: ts.Decorator, visitor: ts.Visitor): ts.Node {\n  if (ts.isIdentifier(node.expression)) {\n    const name = node.expression.escapedText as string\n    if (array.has(BuiltinDecorator, name)) {\n      return undefined\n    }\n  }\n  else if (ts.isCallExpression(node.expression) && ts.isIdentifier(node.expression.expression)) {\n    const name = node.expression.expression.escapedText as string\n    if (array.has(BuiltinDecorator, name)) {\n      return undefined\n    }\n  }\n  return ts.visitEachChild(node, visitor, statement.context)\n}\n\nexport function asyncVisitor(node: ts.AsyncKeyword, visitor: ts.Visitor) {\n  if (statement.cheapCompilerOptions.defined.ENABLE_SYNCHRONIZE_API\n    && node.parent\n    && (ts.isFunctionDeclaration(node.parent)\n      || ts.isFunctionExpression(node.parent)\n      || ts.isArrowFunction(node.parent)\n      || ts.isMethodDeclaration(node.parent)\n    )\n    && nodeUtils.isSynchronizeFunction(node.parent)\n  ) {\n    return undefined\n  }\n  return node\n}\n","import ts from 'typescript'\nimport { is } from '@libmedia/common'\nimport type { Struct } from '../../struct'\nimport { StructType } from '../../struct'\nimport statement from '../../statement'\nimport * as constant from '../../constant'\nimport { KeyMetaKey } from '../../../typedef'\n\nexport default function generateStruct(struct: Struct) {\n\n  const definedMetaProperty = statement.addIdentifierImport(constant.definedMetaProperty, constant.InternalPath, false)\n  const symbolStruct = statement.addSymbolImport(constant.symbolStruct)\n  const symbolStructMaxBaseTypeByteLength = statement.addSymbolImport(constant.symbolStructMaxBaseTypeByteLength)\n  const symbolStructLength = statement.addSymbolImport(constant.symbolStructLength)\n  const symbolStructKeysMeta = statement.addSymbolImport(constant.symbolStructKeysMeta)\n\n  const list: ts.Statement[] = []\n\n  // const map = new Map()\n  list.push(statement.context.factory.createVariableStatement(\n    undefined,\n    statement.context.factory.createVariableDeclarationList([\n      statement.context.factory.createVariableDeclaration(\n        statement.context.factory.createIdentifier('map'),\n        undefined,\n        undefined,\n        statement.context.factory.createNewExpression(\n          statement.context.factory.createIdentifier('Map'),\n          undefined,\n          []\n        )\n      )\n    ], ts.NodeFlags.Const)\n  ))\n\n  const meta = struct.meta\n  meta.forEach((data, key) => {\n    let type: ts.PropertyAssignment | ts.GetAccessorDeclaration\n    if (is.func(data.getTypeMeta)) {\n      if (data.typeIdentifier) {\n        const targetSymbol = data.getTypeMeta()?.symbol.deref()\n        const targetSource = targetSymbol?.valueDeclaration.getSourceFile()\n        if (targetSource && targetSource.fileName !== statement.currentFile.fileName) {\n          type = statement.context.factory.createPropertyAssignment(\n            statement.context.factory.createNumericLiteral(KeyMetaKey.Type),\n            statement.addStructImport(\n              targetSymbol,\n              targetSource\n            )\n          )\n        }\n        else {\n          if (statement.hasStruct(data.typeIdentifier)) {\n            type = statement.context.factory.createPropertyAssignment(\n              statement.context.factory.createNumericLiteral(KeyMetaKey.Type),\n              statement.context.factory.createIdentifier(data.typeIdentifier)\n            )\n          }\n          else {\n            type = statement.context.factory.createGetAccessorDeclaration(\n              undefined,\n              statement.context.factory.createNumericLiteral(KeyMetaKey.Type),\n              [],\n              undefined,\n              statement.context.factory.createBlock(\n                [statement.context.factory.createReturnStatement(statement.context.factory.createIdentifier(data.typeIdentifier))],\n                false\n              )\n            )\n          }\n        }\n      }\n      else {\n        const inlineStruct = data.getTypeMeta()\n        if (inlineStruct && inlineStruct.structType === StructType.INLINE_OBJECT) {\n          const body = generateStruct(inlineStruct)\n          body.push(statement.context.factory.createReturnStatement(statement.context.factory.createIdentifier(constant.prototype)))\n          type = statement.context.factory.createPropertyAssignment(\n            statement.context.factory.createNumericLiteral(KeyMetaKey.Type),\n            statement.context.factory.createCallExpression(\n              statement.context.factory.createParenthesizedExpression(statement.context.factory.createFunctionExpression(\n                undefined,\n                undefined,\n                undefined,\n                undefined,\n                [\n                  statement.context.factory.createParameterDeclaration(\n                    undefined,\n                    undefined,\n                    statement.context.factory.createIdentifier(constant.prototype)\n                  )\n                ],\n                undefined,\n                // @ts-ignore\n                statement.context.factory.createBlock(body, true)\n              )),\n              undefined,\n              [\n                statement.context.factory.createObjectLiteralExpression()\n              ]\n            )\n          )\n        }\n        else {\n          return true\n        }\n      }\n    }\n    else {\n      type = statement.context.factory.createPropertyAssignment(\n        statement.context.factory.createNumericLiteral(KeyMetaKey.Type),\n        statement.context.factory.createNumericLiteral(data[KeyMetaKey.Type] as number)\n      )\n    }\n\n    list.push(statement.context.factory.createExpressionStatement(statement.context.factory.createCallExpression(\n      statement.context.factory.createPropertyAccessExpression(\n        statement.context.factory.createIdentifier('map'),\n        statement.context.factory.createIdentifier('set')\n      ),\n      undefined,\n      [\n        statement.context.factory.createStringLiteral(key),\n        statement.context.factory.createObjectLiteralExpression([\n          type,\n          statement.context.factory.createPropertyAssignment(\n            statement.context.factory.createNumericLiteral(KeyMetaKey.Pointer),\n            statement.context.factory.createNumericLiteral(data[KeyMetaKey.Pointer])\n          ),\n          statement.context.factory.createPropertyAssignment(\n            statement.context.factory.createNumericLiteral(KeyMetaKey.PointerLevel),\n            statement.context.factory.createNumericLiteral(data[KeyMetaKey.PointerLevel])\n          ),\n          statement.context.factory.createPropertyAssignment(\n            statement.context.factory.createNumericLiteral(KeyMetaKey.Array),\n            statement.context.factory.createNumericLiteral(data[KeyMetaKey.Array])\n          ),\n          statement.context.factory.createPropertyAssignment(\n            statement.context.factory.createNumericLiteral(KeyMetaKey.ArrayLength),\n            statement.context.factory.createNumericLiteral(data[KeyMetaKey.ArrayLength])\n          ),\n          statement.context.factory.createPropertyAssignment(\n            statement.context.factory.createNumericLiteral(KeyMetaKey.BitField),\n            statement.context.factory.createNumericLiteral(data[KeyMetaKey.BitField])\n          ),\n          statement.context.factory.createPropertyAssignment(\n            statement.context.factory.createNumericLiteral(KeyMetaKey.BitFieldLength),\n            statement.context.factory.createNumericLiteral(data[KeyMetaKey.BitFieldLength])\n          ),\n          statement.context.factory.createPropertyAssignment(\n            statement.context.factory.createNumericLiteral(KeyMetaKey.BaseAddressOffset),\n            statement.context.factory.createNumericLiteral(data[KeyMetaKey.BaseAddressOffset])\n          ),\n          statement.context.factory.createPropertyAssignment(\n            statement.context.factory.createNumericLiteral(KeyMetaKey.BaseBitOffset),\n            statement.context.factory.createNumericLiteral(data[KeyMetaKey.BaseBitOffset])\n          )\n        ])\n      ]\n    )))\n  })\n\n  // definedMetaProperty(proto, symbolStruct, true)\n  list.push(statement.context.factory.createExpressionStatement(statement.context.factory.createCallExpression(\n    definedMetaProperty,\n    undefined,\n    [\n      statement.context.factory.createIdentifier(constant.prototype),\n      symbolStruct,\n      statement.context.factory.createTrue()\n    ]\n  )))\n\n  // definedMetaProperty(proto, symbolStructMaxBaseTypeByteLength, 0)\n  list.push(statement.context.factory.createExpressionStatement(statement.context.factory.createCallExpression(\n    definedMetaProperty,\n    undefined,\n    [\n      statement.context.factory.createIdentifier(constant.prototype),\n      symbolStructMaxBaseTypeByteLength,\n      statement.context.factory.createNumericLiteral(struct.maxBaseTypeByteLength)\n    ]\n  )))\n\n  // definedMetaProperty(proto, symbolStructLength, 0)\n  list.push(statement.context.factory.createExpressionStatement(statement.context.factory.createCallExpression(\n    definedMetaProperty,\n    undefined,\n    [\n      statement.context.factory.createIdentifier(constant.prototype),\n      symbolStructLength,\n      statement.context.factory.createNumericLiteral(struct.length)\n    ]\n  )))\n\n  // definedMetaProperty(proto, symbolStructKeysMeta, map)\n  list.push(statement.context.factory.createExpressionStatement(statement.context.factory.createCallExpression(\n    definedMetaProperty,\n    undefined,\n    [\n      statement.context.factory.createIdentifier(constant.prototype),\n      symbolStructKeysMeta,\n      statement.context.factory.createIdentifier('map')\n    ]\n  )))\n\n  return list\n}\n","\nimport ts from 'typescript'\nimport statement from '../statement'\nimport * as constant from '../constant'\nimport * as typeUtils from '../util/typeutil'\nimport generateStruct from './function/generateStruct'\n\nexport default function (node: ts.ClassDeclaration, visitor: ts.Visitor): ts.Node[] | ts.Node {\n  const type = statement.typeChecker.getTypeAtLocation(node)\n  const struct = typeUtils.getStructByType(type)\n  if (struct && (!node.modifiers || !node.modifiers.some((modifier) => modifier.kind === ts.SyntaxKind.DeclareKeyword))) {\n\n    const structName = node.name.escapedText as string\n\n    if (!statement.hasStruct(structName)) {\n      statement.addStruct(structName)\n    }\n\n    const structNode = ts.visitEachChild(node, visitor, statement.context)\n\n    const newNode: ts.Node[] = [\n      statement.context.factory.createClassDeclaration(\n        structNode.modifiers,\n        structNode.name,\n        structNode.typeParameters,\n        structNode.heritageClauses,\n        [\n          ...structNode.members,\n          statement.context.factory.createClassStaticBlockDeclaration(statement.context.factory.createBlock([\n            statement.context.factory.createVariableStatement(\n              undefined,\n              statement.context.factory.createVariableDeclarationList([\n                statement.context.factory.createVariableDeclaration(\n                  statement.context.factory.createIdentifier(constant.prototype),\n                  undefined,\n                  undefined,\n                  statement.context.factory.createPropertyAccessExpression(\n                    statement.context.factory.createThis(),\n                    statement.context.factory.createIdentifier(constant.prototype)\n                  )\n                )\n              ], ts.NodeFlags.Const)\n            ),\n            ...generateStruct(struct)\n          ], true))\n        ]\n      )\n    ]\n\n    const item = statement.getDeclaration(structName)\n\n    if (item) {\n      newNode.push(statement.context.factory.createExpressionStatement(statement.context.factory.createBinaryExpression(\n        statement.context.factory.createIdentifier(item.formatName),\n        ts.SyntaxKind.EqualsToken,\n        statement.context.factory.createIdentifier(item.name)\n      )))\n    }\n    return newNode\n  }\n\n  return ts.visitEachChild(node, visitor, statement.context)\n}\n","\nimport ts from 'typescript'\nimport statement from '../statement'\nimport * as nodeUtil from '../util/nodeutil'\n\nfunction check(node: ts.Node) {\n  if (ts.isBlock(node)\n    && !node.statements.some((n) => !ts.isImportDeclaration(n))\n  ) {\n    if (node.statements.length === 1) {\n      return node.statements[0]\n    }\n    return node.statements\n  }\n  return node\n}\n\nexport default function (node: ts.IfStatement, visitor: ts.Visitor): ts.Node | ts.Node[] {\n  if (ts.visitNode(node.expression, nodeUtil.hasDefined) && ts.visitNode(node.expression, nodeUtil.checkConditionCompile)) {\n    if (nodeUtil.checkBool(node.expression, visitor)) {\n      return check(ts.visitNode(node.thenStatement, visitor)) as ts.Node\n    }\n    else if (node.elseStatement) {\n      return check(ts.visitNode(node.elseStatement, visitor)) as ts.Node\n    }\n    else {\n      return undefined\n    }\n  }\n  return ts.visitEachChild(node, visitor, statement.context)\n}\n","import ts from 'typescript'\nimport statement, { StageStatus } from '../statement'\nimport * as typeUtils from '../util/typeutil'\nimport * as nodeUtils from '../util/nodeutil'\n\nexport default function (node: ts.ParameterDeclaration, visitor: ts.Visitor): ts.Node | ts.Node[] {\n\n  statement.pushStage(StageStatus.Parameter)\n\n  if (node.initializer && node.type && node.pos > -1) {\n    const type = statement.typeChecker.getTypeAtLocation(node.type)\n    if (typeUtils.isSizeType(type)) {\n      return ts.visitNode(statement.context.factory.createParameterDeclaration(\n        node.modifiers,\n        node.dotDotDotToken,\n        node.name,\n        node.questionToken,\n        node.type,\n        nodeUtils.createPointerOperand(node.initializer)\n      ), statement.visitor)\n    }\n  }\n  const newNode = ts.visitEachChild(node, visitor, statement.context)\n\n  statement.popStage()\n\n  return newNode\n}\n","export const TYPE_MISMATCH = 10000\n\nexport const INVALID_OPERATE = 20000\n\nexport const SYNTAX_ERROR = 30000\n","\nimport ts from 'typescript'\nimport statement, { StageStatus } from '../statement'\nimport * as typeUtils from '../util/typeutil'\nimport * as nodeUtils from '../util/nodeutil'\nimport reportError from '../function/reportError'\nimport * as error from '../error'\n\nexport default function (node: ts.VariableDeclaration, visitor: ts.Visitor): ts.Node | ts.Node[] {\n\n  statement.pushStage(StageStatus.VariableDeclaration)\n  if (node.initializer && node.type && node.pos > -1) {\n    const type = statement.typeChecker.getTypeAtLocation(node.type)\n    const initType = statement.typeChecker.getTypeAtLocation(node.initializer)\n    if (typeUtils.isPointerType(type, null)\n      && (typeUtils.isBuiltinType(initType, node.initializer) || (initType.flags & ts.TypeFlags.NumberLike))\n      && !typeUtils.isPointerType(initType, node.initializer)\n      && !typeUtils.isNullPointer(initType, node.initializer)\n    ) {\n      reportError(statement.currentFile, node, `type ${typeUtils.getBuiltinNameByType(initType) || 'number'} is not assignable to variable declaration of type ${typeUtils.getBuiltinNameByType(type)}`, error.TYPE_MISMATCH)\n    }\n    else if (typeUtils.isSizeType(type)) {\n      return ts.visitNode(statement.context.factory.createVariableDeclaration(\n        node.name,\n        node.exclamationToken,\n        node.type,\n        nodeUtils.createPointerOperand(node.initializer)\n      ), statement.visitor)\n    }\n  }\n  const newNode = ts.visitEachChild(node, visitor, statement.context)\n\n  statement.popStage()\n\n  return newNode\n}\n","\nimport ts from 'typescript'\nimport statement from '../statement'\n\nexport default function (node: ts.FunctionDeclaration, visitor: ts.Visitor): ts.Node | ts.Node[] {\n\n  if (node.name) {\n    statement.addFunc(node.name.escapedText as string, node)\n  }\n\n  statement.pushStack()\n\n  let newNode = ts.visitEachChild(node, visitor, statement.context)\n\n  statement.popStack()\n\n  return newNode\n}\n","import ts from 'typescript'\nimport * as constant from '../constant'\nimport statement from '../statement'\n\nexport default function (node: ts.ExpressionStatement, visitor: ts.Visitor): ts.Node {\n\n  if (ts.isCallExpression(node.expression)\n    && ts.isIdentifier(node.expression.expression)\n    && node.expression.expression.escapedText === constant.assert\n  ) {\n    if (statement.cheapCompilerOptions.defined['DEBUG'] && node.expression.arguments.length >= 1) {\n      const newNode = ts.visitEachChild(node.expression, visitor, statement.context)\n\n      const list: ts.Statement[] = []\n\n      const { line } = ts.getLineAndCharacterOfPosition(statement.currentFile, node.getStart())\n\n      const args: ts.Expression[] = [\n        statement.context.factory.createStringLiteral(`[${statement.currentFilePath} line: ${line + 1}]`),\n        statement.context.factory.createStringLiteral(`Assertion failed: ${node.expression.arguments[0].getText()}`)\n      ]\n\n      if (newNode.arguments[1]) {\n        args.push(newNode.arguments[1])\n      }\n\n      list.push(statement.context.factory.createExpressionStatement(statement.context.factory.createCallExpression(\n        statement.context.factory.createPropertyAccessExpression(\n          statement.context.factory.createIdentifier('console'),\n          statement.context.factory.createIdentifier('error')\n        ),\n        undefined,\n        args\n      )))\n\n      list.push(statement.context.factory.createDebuggerStatement())\n\n      return statement.context.factory.createIfStatement(\n        statement.context.factory.createPrefixUnaryExpression(\n          ts.SyntaxKind.ExclamationToken,\n          statement.context.factory.createParenthesizedExpression(newNode.arguments[0])\n        ),\n        statement.context.factory.createBlock(\n          list,\n          true\n        )\n      )\n    }\n    else {\n      return undefined\n    }\n  }\n\n  return ts.visitEachChild(node, visitor, statement.context)\n}\n","\nimport type ts from 'typescript'\nimport statement from '../statement'\n\nexport default function (node: ts.BigIntLiteral, visitor: ts.Visitor): ts.Node | ts.Node[] {\n  if (statement.cheapCompilerOptions.defined.BIGINT_LITERAL === false) {\n    return statement.context.factory.createCallExpression(\n      statement.context.factory.createIdentifier('BigInt'),\n      undefined,\n      [\n        statement.context.factory.createNumericLiteral(node.text.replace(/n$/, ''))\n      ]\n    )\n  }\n  return node\n}\n","import type { Struct } from '../struct'\n\nexport default function getStructMeta(struct: Struct, key: string) {\n  let meta = struct.meta.get(key)\n  if (meta) {\n    return meta\n  }\n  let next = struct.parent\n  while (next) {\n    meta = next.meta.get(key)\n    if (meta) {\n      return meta\n    }\n    next = next.parent\n  }\n\n  return null\n}\n","\nimport type { Expression } from 'typescript'\nimport ts from 'typescript'\nimport statement from '../statement'\nimport { BuiltinBigInt, BuiltinBool, BuiltinFloat, BuiltinNumber, BuiltinUint, CTypeEnum2Type, Type2CTypeEnum } from '../defined'\nimport reportError from '../function/reportError'\nimport { CTypeEnum, CTypeEnum2Bytes, KeyMetaKey } from '../../typedef'\nimport type { Struct } from '../struct'\nimport { StructType, hasStruct } from '../struct'\nimport { isPointerNode } from '../util/nodeutil'\nimport relativePath from '../function/relativePath'\nimport * as constant from '../constant'\nimport * as nodeUtils from '../util/nodeutil'\nimport * as typeUtils from '../util/typeutil'\nimport getStructMeta from '../function/getStructMeta'\nimport * as error from '../error'\n\nimport { is, array, isDef, toString } from '@libmedia/common'\n\nfunction definedReplace(name: string, node: ts.Node) {\n  if (name === constant.LINE || name === constant.LINE_2) {\n    const { line } = ts.getLineAndCharacterOfPosition(statement.currentFile, node.getStart())\n    return statement.context.factory.createNumericLiteral(line + 1)\n  }\n  else if (name === constant.FILE || name === constant.FILE_2) {\n    const { formatName } = statement.addModuleDeclaration('fileName', statement.context.factory.createStringLiteral(statement.currentFilePath))\n    return statement.context.factory.createIdentifier(formatName)\n  }\n  else if (isDef(statement.cheapCompilerOptions.defined[name])) {\n    const value = statement.cheapCompilerOptions.defined[name]\n    if (is.boolean(value)) {\n      return value ? statement.context.factory.createTrue() : statement.context.factory.createFalse()\n    }\n    else if (is.number(value)) {\n      return statement.context.factory.createNumericLiteral(value)\n    }\n    else if (is.string(value)) {\n      return statement.context.factory.createStringLiteral(value)\n    }\n    else if (node) {\n      reportError(statement.currentFile, node, `the type(${typeof value}) of defined not support`)\n      return node\n    }\n  }\n  else if (node) {\n    reportError(statement.currentFile, node, `cannot found the defined(${name})`)\n    return node\n  }\n}\n\nfunction definedString(name: string, node: ts.Node) {\n  if (name === constant.LINE || name === constant.LINE_2) {\n    const { line } = ts.getLineAndCharacterOfPosition(statement.currentFile, node.getStart())\n    return toString(line + 1)\n  }\n  else if (name === constant.FILE || name === constant.FILE_2) {\n    return statement.currentFilePath\n  }\n  else if (isDef(statement.cheapCompilerOptions.defined[name])) {\n    const value = statement.cheapCompilerOptions.defined[name]\n    return toString(value, '')\n  }\n  return ''\n}\n\nfunction hasTypeArgs(args: ts.NodeArray<ts.TypeParameterDeclaration>) {\n  if (!args) {\n    return false\n  }\n  for (let i = 0; i < args.length; i++) {\n    const node = args[i]\n    if (node.name.escapedText === constant.args) {\n      return true\n    }\n  }\n\n  return false\n}\n\nfunction getTypeArgs(target: ts.NodeArray<ts.TypeParameterDeclaration>, sig: ts.NodeArray<ts.TypeNode>) {\n  let index = -1\n  for (let i = 0; i < target.length; i++) {\n    const node = target[i]\n    if (node.name.escapedText === constant.args) {\n      index = i\n      break\n    }\n  }\n\n  if (index > -1) {\n    return sig[index]\n  }\n}\n\nfunction isArgsEnable(target: ts.NodeArray<ts.TypeParameterDeclaration>, sig: ts.NodeArray<ts.TypeNode>, call: ts.CallExpression) {\n  for (let i = 0; i < target.length; i++) {\n    const node = target[i]\n    if (node.name.escapedText === constant.enableArgs && node.default) {\n      const args: ts.Node[] = []\n      addArgs(args, sig[i], call)\n      if (args[0].kind === ts.SyntaxKind.FalseKeyword\n        || ts.isStringLiteral(args[0]) && args[0].text === ''\n        || ts.isNumericLiteral(args[0]) && args[0].text === '0'\n      ) {\n        return false\n      }\n      break\n    }\n  }\n  return true\n}\n\nfunction addArgs(args: ts.Node[], node: ts.Node, call: ts.CallExpression) {\n  if (ts.isTypeReferenceNode(node)) {\n    // @ts-ignore\n    if (ts.isIdentifier(node.typeName) && node.typeName.symbol) {\n      // @ts-ignore\n      const type = statement.typeChecker.getTypeOfSymbol(node.typeName.symbol)\n      // @ts-ignore\n      if (typeUtils.isBuiltinType(type, node.typeName.symbol?.valueDeclaration)) {\n        // @ts-ignore\n        args.push(statement.context.factory.createNumericLiteral(typeUtils.getBuiltinByType(type, node.typeName.symbol?.valueDeclaration)))\n      }\n      else if (type.aliasSymbol) {\n        const name = type.aliasSymbol.escapedName as string\n        args.push(statement.context.factory.createIdentifier(name))\n      }\n      else if (type.symbol && type.symbol.valueDeclaration && ts.isClassDeclaration(type.symbol.valueDeclaration)) {\n        let key: ts.Expression\n        const targetSource = type.symbol.valueDeclaration?.getSourceFile()\n        if (targetSource !== statement.currentFile) {\n          key = statement.addStructImport(\n            type.symbol,\n            targetSource\n          )\n        }\n        else {\n          key = statement.context.factory.createIdentifier(type.symbol.escapedName as string)\n        }\n        args.push(key)\n      }\n      else if (type.symbol) {\n        args.push(statement.context.factory.createIdentifier(type.symbol.escapedName as string))\n      }\n      else {\n        args.push(statement.context.factory.createIdentifier('undefined'))\n      }\n    }\n    else {\n      args.push(statement.context.factory.createIdentifier('undefined'))\n    }\n  }\n  else if (ts.isLiteralTypeNode(node)) {\n    if (ts.isNumericLiteral(node.literal)) {\n      args.push(statement.context.factory.createNumericLiteral(+node.literal.text))\n    }\n    else if (ts.isStringLiteral(node.literal)) {\n      if (/^defined\\(([a-zA-Z_$][a-zA-Z0-9_$]*)\\)$/.test(node.literal.text)) {\n        const match = node.literal.text.match(/^defined\\(([a-zA-Z_$][a-zA-Z0-9_$]*)\\)$/)\n        const newNode = definedReplace(match[1], call)\n        if (newNode) {\n          args.push(newNode)\n        }\n        else {\n          args.push(statement.context.factory.createIdentifier('undefined'))\n        }\n      }\n      else if (/^moduleId\\(([0-9]+)\\)$/.test(node.literal.text)) {\n        if (statement.cheapCompilerOptions.defined.ENV_WEBPACK) {\n          const match = node.literal.text.match(/^moduleId\\(([0-9]+)\\)$/)\n          const index = +match[1]\n          const arg = call.arguments[index]\n          if (arg) {\n            const type = statement.typeChecker.getTypeAtLocation(arg)\n            const targetSource = type.symbol.valueDeclaration?.getSourceFile()\n            if (targetSource) {\n\n              const callType = statement.typeChecker.getTypeAtLocation(call.expression)\n              const callPath = callType?.symbol?.valueDeclaration?.getSourceFile().fileName\n\n              let cheapThreadPath = constant.cheapThreadPath\n              if (statement.options.cheapSourcePath) {\n                cheapThreadPath = statement.options.cheapSourcePath + cheapThreadPath.replace(constant.PACKET_NAME, '')\n              }\n\n              if (statement.cheapCompilerOptions.defined.ENABLE_THREADS\n                && statement.cheapCompilerOptions.defined.ENABLE_THREADS_SPLIT\n                && (callPath.indexOf(cheapThreadPath) >= 0\n                  || callPath.indexOf(constant.PACKET_NAME) >= 0\n                    && callPath.indexOf(cheapThreadPath.replace(constant.PACKET_NAME, '')) >= 0\n                )\n                && (\n                  callType.symbol.escapedName === constant.createThreadFromClass\n                    || callType.symbol.escapedName === constant.createThreadFromFunction\n                    || callType.symbol.escapedName === constant.createThreadFromModule\n                )\n              ) {\n                const initType = callType.symbol.escapedName === constant.createThreadFromClass\n                  ? 'class'\n                  : ( callType.symbol.escapedName === constant.createThreadFromModule ? 'module' : 'function')\n\n                let point = ts.isIdentifier(call.arguments[0]) ? call.arguments[0].escapedText\n                  : (ts.isPropertyAccessExpression(call.arguments[0]) ? call.arguments[0].name.escapedText : 'unknown')\n\n                if (initType === 'class' || initType === 'function') {\n                  let type: ts.Type\n                  if (ts.isIdentifier(call.arguments[0])) {\n                    type = statement.typeChecker.getTypeAtLocation(call.arguments[0])\n                  }\n                  else if (ts.isPropertyAccessExpression(call.arguments[0])) {\n                    type = statement.typeChecker.getTypeAtLocation(call.arguments[0].name)\n                  }\n                  if (type?.symbol?.valueDeclaration) {\n                    if (ts.isClassDeclaration(type.symbol.valueDeclaration)) {\n                      if (type.symbol.valueDeclaration.name) {\n                        point = type.symbol.valueDeclaration.name.escapedText\n                      }\n                      else {\n                        reportError(statement.currentFile, node, 'The thread class must have a class name')\n                        return node\n                      }\n                    }\n                    else if (ts.isFunctionDeclaration(type.symbol.valueDeclaration)) {\n                      if (type.symbol.valueDeclaration.name) {\n                        point = type.symbol.valueDeclaration.name.escapedText\n                      }\n                      else {\n                        reportError(statement.currentFile, node, 'The thread function must has a function name')\n                        return node\n                      }\n                    }\n                  }\n                }\n\n                let name = `${point}Thread`\n\n                if (call.arguments[1] && ts.isObjectLiteralExpression(call.arguments[1])) {\n                  call.arguments[1].properties.forEach((node) => {\n                    if (ts.isPropertyAssignment(node) && ts.isIdentifier(node.name) && node.name.escapedText === 'name') {\n                      let text = node.initializer.getText()\n                      if (text) {\n                        text = text.replace(/^['|\"]/, '')\n                        text = text.replace(/['|\"]$/, '')\n\n                        if (text) {\n                          name = text\n                        }\n                      }\n                    }\n                  })\n                }\n                const loader = `cheap-worker-loader?type=${initType}&point=${point}&name=${name}`\n                const identifier = statement.addIdentifierImport('worker', `${loader}!${relativePath(statement.currentFile.fileName, targetSource.fileName)}`, true)\n                args.push(identifier)\n              }\n              else {\n                args.push(statement.context.factory.createCallExpression(\n                  statement.context.factory.createPropertyAccessExpression(\n                    statement.context.factory.createIdentifier('require'),\n                    statement.context.factory.createIdentifier('resolveWeak')\n                  ),\n                  undefined,\n                  [\n                    statement.context.factory.createStringLiteral(relativePath(statement.currentFile.fileName, targetSource.fileName))\n                  ]\n                ))\n              }\n            }\n          }\n        }\n        else {\n          reportError(statement.currentFile, call, 'moduleId only support in webpack')\n        }\n      }\n      else {\n        let text = node.literal.text.replace(/defined\\(([a-zA-Z_$][a-zA-Z0-9_$]*)\\)/g, (s1: string, s2: string) => {\n          return definedString(s2, call)\n        })\n        args.push(statement.context.factory.createStringLiteral(text))\n      }\n    }\n    else if (node.literal.kind === ts.SyntaxKind.TrueKeyword) {\n      args.push(statement.context.factory.createTrue())\n    }\n    else if (node.literal.kind === ts.SyntaxKind.FalseKeyword) {\n      args.push(statement.context.factory.createFalse())\n    }\n  }\n  else if (node.kind === ts.SyntaxKind.UndefinedKeyword) {\n    args.push(statement.context.factory.createIdentifier('undefined'))\n  }\n}\n\nfunction accessCType(pointer: ts.Node, type: CTypeEnum) {\n  return statement.context.factory.createCallExpression(\n    statement.context.factory.createElementAccessExpression(\n      statement.addMemoryImport(constant.ctypeEnumRead) as ts.Expression,\n      type\n    ),\n    undefined,\n    [\n      pointer as ts.Expression\n    ]\n  )\n}\n\nfunction accessStruct(pointer: ts.Node, struct: Struct) {\n\n  const targetStruct = struct\n  let targetSymbol = targetStruct.symbol.deref()\n  let targetPath = ''\n\n  if (targetStruct.structType === StructType.INLINE_OBJECT) {\n    targetSymbol = targetStruct.definedClassParent.symbol.deref()\n    targetPath = targetStruct.definedClassParent.inlineStructPathMap.get(targetStruct.symbol.deref())\n  }\n\n  const targetSource = targetSymbol.valueDeclaration?.getSourceFile()\n  if (targetSource) {\n    let key: ts.Expression\n    if (targetSource !== statement.currentFile) {\n      key = statement.addStructImport(\n        targetSymbol,\n        targetSource\n      )\n    }\n    else {\n      key = statement.context.factory.createIdentifier(targetSymbol.escapedName as string)\n    }\n    const args = [\n      pointer as ts.Expression,\n      key\n    ]\n    if (targetPath) {\n      args.push(statement.context.factory.createStringLiteral(targetPath))\n    }\n    return statement.context.factory.createCallExpression(\n      statement.addIdentifierImport(constant.structAccess, constant.RootPath, false),\n      undefined,\n      args\n    )\n  }\n}\n\nfunction getTypeSize(nameType: ts.Type, node: ts.Node) {\n  if (typeUtils.isStructType(nameType)) {\n    const struct = typeUtils.getStructByType(nameType)\n    if (struct) {\n      return struct.length\n    }\n  }\n  else if (typeUtils.isBuiltinType(nameType, node)) {\n    return CTypeEnum2Bytes[typeUtils.getBuiltinByType(nameType, node)]\n  }\n  else if (nameType.aliasSymbol) {\n    const type = nameType.aliasSymbol.escapedName as string\n    if (type === constant.typeArray && nameType.aliasTypeArguments[1]?.isNumberLiteral()) {\n      return getTypeSize(nameType.aliasTypeArguments[0], null) * nameType.aliasTypeArguments[1].value\n    }\n    else if (type === constant.typeBit && nameType.aliasTypeArguments[1]?.isNumberLiteral()) {\n      return nameType.aliasTypeArguments[1].value\n    }\n  }\n  return 0\n}\n\nfunction formatArgument(signature: ts.Signature, args: ts.NodeArray<ts.Expression>) {\n  const newArgument: ts.Expression[] = []\n  let hasSizeParameter = false\n  for (let i = 0; i < args.length; i++) {\n    if (signature.parameters[i]) {\n      const argumentType = statement.typeChecker.getTypeAtLocation(args[i])\n      const parameterType = statement.typeChecker.getTypeOfSymbol(signature.parameters[i])\n\n      if (typeUtils.isPointerType(argumentType, args[i])\n          && typeUtils.isBuiltinType(parameterType, signature.parameters[i].valueDeclaration)\n          && !typeUtils.isPointerType(parameterType, signature.parameters[i].valueDeclaration)\n          && !typeUtils.isNullPointer(parameterType, signature.parameters[i].valueDeclaration)\n        || typeUtils.isBuiltinType(argumentType, args[i])\n          && !typeUtils.isPointerType(argumentType, args[i])\n          && !typeUtils.isNullPointer(argumentType, args[i])\n          && typeUtils.isPointerType(parameterType, signature.parameters[i].valueDeclaration)\n      ) {\n        reportError(statement.currentFile, args[i], `type ${typeUtils.getBuiltinNameByType(argumentType)} is not assignable to parameter of type ${typeUtils.getBuiltinNameByType(parameterType)}`, error.TYPE_MISMATCH)\n      }\n      if (typeUtils.isSizeType(parameterType)) {\n        newArgument.push(nodeUtils.createPointerOperand(args[i]))\n        hasSizeParameter = true\n      }\n      else {\n        newArgument.push(args[i])\n      }\n    }\n  }\n  return {\n    newArgument,\n    hasSizeParameter\n  }\n}\n\nexport default function (node: ts.CallExpression, visitor: ts.Visitor): ts.Node {\n  let callName: string = ''\n  if (ts.isIdentifier(node.expression)) {\n    callName = node.expression.escapedText as string\n  }\n  else if (ts.isPropertyAccessExpression(node.expression)) {\n    callName = node.expression.name.escapedText as string\n  }\n\n  const signature = statement.typeChecker.getResolvedSignature(node)\n  const target = signature?.getDeclaration()\n  if (target && hasTypeArgs(target.typeParameters)) {\n    const sig = statement.typeChecker.signatureToSignatureDeclaration(\n      signature,\n      ts.SyntaxKind.CallSignature,\n      nodeUtils.getParseTreeNode(nodeUtils.getContainerNode(node)),\n      ts.NodeBuilderFlags.WriteTypeArgumentsOfSignature\n        | ts.NodeBuilderFlags.IgnoreErrors\n        | ts.NodeBuilderFlags.WriteTypeParametersInQualifiedName\n        | ts.NodeBuilderFlags.UseAliasDefinedOutsideCurrentScope\n        | ts.NodeBuilderFlags.MultilineObjectLiterals\n        | ts.NodeBuilderFlags.OmitParameterModifiers\n    )\n    if (sig?.typeArguments) {\n      const typeNode = getTypeArgs(target.typeParameters, sig.typeArguments)\n      if (typeNode && isArgsEnable(target.typeParameters, sig.typeArguments, node)) {\n        const args: ts.Expression[] = []\n\n        let padding = (target.parameters?.length || 0) - node.arguments.length\n        while (padding > 0) {\n          args.push(nodeUtils.getParameterDefaultValue(\n            statement.typeChecker.getSymbolAtLocation(target.name),\n            node.arguments.length + args.length\n          ) ?? statement.context.factory.createIdentifier('undefined'))\n          padding--\n        }\n\n        if (ts.isTupleTypeNode(typeNode)) {\n          typeNode.elements.forEach((item) => {\n            if (padding < 0) {\n              padding++\n            }\n            else {\n              addArgs(args, item, node)\n            }\n          })\n        }\n        else {\n          if (padding < 0) {\n            padding++\n          }\n          else {\n            addArgs(args, typeNode, node)\n          }\n        }\n\n        if (nodeUtils.isAtomicCallExpression(node)\n          && typeUtils.getPointerBuiltinByType(statement.typeChecker.getTypeAtLocation(node.arguments[0]), node.arguments[0]) === CTypeEnum.atomic_bool\n        ) {\n          if (callName === 'load') {\n            return ts.visitNode(statement.context.factory.createCallExpression(\n              statement.context.factory.createIdentifier(constant.staticCast),\n              [\n                statement.context.factory.createTypeReferenceNode(\n                  statement.context.factory.createIdentifier(CTypeEnum2Type[CTypeEnum.atomic_bool]),\n                  undefined\n                )\n              ],\n              [\n                statement.context.factory.createCallExpression(\n                  node.expression,\n                  undefined,\n                  [\n                    ...node.arguments,\n                    ...args\n                  ]\n                )\n              ]\n            ), visitor)\n          }\n          else if (callName === 'store' || callName === 'exchange') {\n            return ts.visitNode(statement.context.factory.createCallExpression(\n              node.expression,\n              undefined,\n              [\n                node.arguments[0],\n                statement.context.factory.createCallExpression(\n                  statement.context.factory.createIdentifier(constant.staticCast),\n                  [\n                    statement.context.factory.createTypeReferenceNode(\n                      statement.context.factory.createIdentifier(CTypeEnum2Type[CTypeEnum.atomic_int32]),\n                      undefined\n                    )\n                  ],\n                  [\n                    node.arguments[1]\n                  ]\n                ),\n                ...args\n              ]\n            ), visitor)\n          }\n          else if (callName === 'compareExchange') {\n            return ts.visitNode(statement.context.factory.createCallExpression(\n              node.expression,\n              undefined,\n              [\n                node.arguments[0],\n                statement.context.factory.createCallExpression(\n                  statement.context.factory.createIdentifier(constant.staticCast),\n                  [\n                    statement.context.factory.createTypeReferenceNode(\n                      statement.context.factory.createIdentifier(CTypeEnum2Type[CTypeEnum.atomic_int32]),\n                      undefined\n                    )\n                  ],\n                  [\n                    node.arguments[1]\n                  ]\n                ),\n                statement.context.factory.createCallExpression(\n                  statement.context.factory.createIdentifier(constant.staticCast),\n                  [\n                    statement.context.factory.createTypeReferenceNode(\n                      statement.context.factory.createIdentifier(CTypeEnum2Type[CTypeEnum.atomic_int32]),\n                      undefined\n                    )\n                  ],\n                  [\n                    node.arguments[2]\n                  ]\n                ),\n                ...args\n              ]\n            ), visitor)\n          }\n          else {\n            reportError(statement.currentFile, node, `atomic_bool not support to ${callName} operate`)\n            return node\n          }\n        }\n\n        return ts.visitNode(statement.context.factory.createCallExpression(\n          node.expression,\n          node.typeArguments,\n          [\n            ...node.arguments,\n            ...args\n          ]\n        ), visitor)\n      }\n    }\n  }\n\n  // 全局函数\n  if (ts.isIdentifier(node.expression)) {\n    if (callName === constant.sizeof && !statement.lookupFunc(constant.sizeof)) {\n      const arg = node.arguments[0]\n\n      let nameType: ts.Type = statement.typeChecker.getTypeAtLocation(arg)\n\n      if (nameType) {\n        const size = getTypeSize(nameType, arg)\n        if (size) {\n          return nodeUtils.createPointerOperand(statement.context.factory.createNumericLiteral(size))\n        }\n        else {\n          return statement.context.factory.createCallExpression(\n            statement.addIdentifierImport(constant.sizeof, constant.RootPath, false),\n            undefined,\n            node.arguments\n          )\n        }\n      }\n    }\n    else if (callName === constant.addressof && !statement.lookupFunc(constant.addressof)) {\n      const arg = node.arguments[0]\n      if (ts.isCallExpression(arg)\n      // addressof(accessof(p))\n        && (ts.isIdentifier(arg.expression) && arg.expression.escapedText === constant.accessof\n          // addressof(CTypeEnumRead[type](p))\n          || ts.isElementAccessExpression(arg.expression)\n            && (ts.isIdentifier(arg.expression.expression) || ts.isPropertyAccessExpression(arg.expression.expression))\n            && statement.isIdentifier(arg.expression.expression, constant.ctypeEnumRead, constant.ctypeEnumReadPath, constant.InternalPath)\n          // addressof(structAccess(p, A))\n          || (ts.isIdentifier(arg.expression) || ts.isPropertyAccessExpression(arg.expression))\n            && statement.isIdentifier(arg.expression, constant.structAccess, constant.structAccessPath, constant.RootPath)\n        )\n      ) {\n        return ts.visitNode(arg.arguments[0], visitor)\n      }\n\n      // addressof(struct)\n      if (ts.isIdentifier(arg)) {\n        // 只支持 struct 取地址\n        if (!hasStruct(statement.typeChecker.getTypeAtLocation(arg)?.symbol)) {\n          reportError(statement.currentFile, arg, 'addressof only support with struct instance Identifier')\n          return node\n        }\n        return statement.context.factory.createElementAccessExpression(\n          ts.visitNode(arg, visitor) as ts.Expression,\n          statement.addSymbolImport(constant.symbolStructAddress)\n        )\n      }\n      // addressof(struct.p)\n      else if (ts.isPropertyAccessExpression(arg)\n        || ts.isCallExpression(arg) && nodeUtils.isPointerIndexOfCall(arg)\n        // pointer[x]\n        || ts.isElementAccessExpression(arg) && typeUtils.isPointerType(statement.typeChecker.getTypeAtLocation(arg.expression), arg.expression)\n      ) {\n        const newArg = ts.visitNode(arg, visitor) as ts.Expression\n        if (ts.isCallExpression(newArg)\n          && (ts.isIdentifier(newArg.expression)\n              && statement.isIdentifier(newArg.expression, constant.structAccess, constant.structAccessPath, constant.RootPath)\n            || ts.isPropertyAccessExpression(newArg.expression)\n              && statement.isIdentifier(newArg.expression, constant.structAccess, constant.structAccessPath, constant.RootPath)\n          )\n        ) {\n          return newArg.arguments[0]\n        }\n        else if (ts.isCallExpression(newArg)\n          && ts.isElementAccessExpression(newArg.expression)\n          && (ts.isIdentifier(newArg.expression.expression)\n              && statement.isIdentifier(newArg.expression.expression, constant.ctypeEnumRead, constant.ctypeEnumReadPath, constant.InternalPath)\n            || ts.isPropertyAccessExpression(newArg.expression.expression)\n              && statement.isIdentifier(newArg.expression.expression, constant.ctypeEnumRead, constant.ctypeEnumReadPath, constant.InternalPath)\n          )\n        ) {\n          return newArg.arguments[0]\n        }\n        else if (ts.isPropertyAccessExpression(newArg)) {\n          let type = statement.typeChecker.getTypeAtLocation(arg.expression)\n          let struct = typeUtils.getStructByType(type)\n\n          if (!struct) {\n            type = statement.typeChecker.getTypeAtLocation(arg)\n            struct = typeUtils.getStructByType(type)\n            if (struct) {\n              return statement.context.factory.createElementAccessExpression(\n                newArg as ts.Expression,\n                statement.addSymbolImport(constant.symbolStructAddress)\n              )\n            }\n            reportError(statement.currentFile, arg, 'addressof only support with struct instance or struct property')\n            return node\n          }\n\n          const meta = getStructMeta(struct, newArg.name.escapedText as string)\n\n          if (!meta) {\n            reportError(statement.currentFile, node, `struct ${struct.symbol.deref().escapedName} not has property ${newArg.name.escapedText}`)\n            return node\n          }\n\n          if (meta[KeyMetaKey.BitField]) {\n            reportError(statement.currentFile, arg, 'addressof not support with bit field property')\n            return node\n          }\n\n          if (meta[KeyMetaKey.BaseAddressOffset]) {\n            return statement.context.factory.createBinaryExpression(\n              statement.context.factory.createElementAccessExpression(\n                newArg.expression,\n                statement.addSymbolImport(constant.symbolStructAddress)\n              ),\n              ts.SyntaxKind.PlusToken,\n              nodeUtils.createPointerOperand(meta[KeyMetaKey.BaseAddressOffset])\n            )\n          }\n          else {\n            if (ts.isCallExpression(newArg.expression)\n              && ts.isIdentifier(newArg.expression.expression)\n              && newArg.expression.expression.escapedText === constant.structAccess\n            ) {\n              return newArg.expression.arguments[0]\n            }\n            return statement.context.factory.createElementAccessExpression(\n              newArg.expression,\n              statement.addSymbolImport(constant.symbolStructAddress)\n            )\n          }\n        }\n        else if (ts.isElementAccessExpression(newArg)\n          && ts.isCallExpression(newArg.expression)\n          && ts.isIdentifier(newArg.expression.expression)\n          && newArg.expression.expression.escapedText === constant.structAccess\n        ) {\n          return newArg.expression.arguments[0]\n        }\n        else {\n          reportError(statement.currentFile, arg, 'invalid operation')\n          return node\n        }\n      }\n      // addressof(struct.p[x])\n      else if (ts.isElementAccessExpression(arg)) {\n        const address = ts.visitNode(\n          statement.context.factory.createCallExpression(\n            statement.context.factory.createIdentifier(constant.addressof),\n            undefined,\n            [\n              arg.expression\n            ]\n          ),\n          visitor\n        )\n\n        let offset: ts.Expression\n        let size = 0\n        const type = statement.typeChecker.getTypeAtLocation(arg)\n        if (typeUtils.isBuiltinType(type, arg)) {\n          size = CTypeEnum2Bytes[typeUtils.getBuiltinByType(type, arg)]\n        }\n        else if (typeUtils.isStructType(type)) {\n          const struct = typeUtils.getStructByType(type)\n          size = struct.length\n        }\n        else if (typeUtils.isArrayType(type)) {\n          size = getTypeSize(type.aliasTypeArguments[0], null) * (type.aliasTypeArguments[1] as ts.NumberLiteralType).value\n        }\n\n        if (!size) {\n          reportError(statement.currentFile, arg, 'type mismatch')\n          return node\n        }\n\n        if (ts.isNumericLiteral(arg.argumentExpression)) {\n          if (+arg.argumentExpression.text) {\n            offset = nodeUtils.createPointerOperand(+arg.argumentExpression.text * size)\n          }\n        }\n        else {\n          offset = nodeUtils.createPointerOperand(statement.context.factory.createBinaryExpression(\n            ts.visitNode(arg.argumentExpression, visitor) as ts.Expression,\n            ts.SyntaxKind.AsteriskToken,\n            statement.context.factory.createNumericLiteral(size)\n          ))\n        }\n\n        if (offset) {\n          return statement.context.factory.createBinaryExpression(\n            address as ts.Expression,\n            ts.SyntaxKind.PlusToken,\n            offset\n          )\n        }\n        return address as ts.Expression\n      }\n      else {\n        const type = statement.typeChecker.getTypeAtLocation(arg)\n        if (type.symbol && hasStruct(type.symbol)) {\n          return statement.context.factory.createElementAccessExpression(\n            ts.visitNode(arg, visitor) as ts.Expression,\n            statement.addSymbolImport(constant.symbolStructAddress)\n          )\n        }\n        reportError(statement.currentFile, arg, 'addressof only support in related to struct')\n        return node\n      }\n    }\n    else if (callName === constant.accessof && !statement.lookupFunc(constant.accessof) && isPointerNode(node.arguments[0])) {\n      const arg = node.arguments[0]\n      if (ts.isCallExpression(arg) && ts.isIdentifier(arg.expression) && arg.expression.escapedText === constant.addressof) {\n        return ts.visitNode(arg.arguments[0], visitor)\n      }\n      const type = nodeUtils.getPointerExpressionType(arg)\n      if (typeUtils.isPointerType(type, arg)) {\n        const newArg = ts.visitNode(arg, visitor) as ts.Expression\n        if (typeUtils.isPointerStructType(type, arg)) {\n          const struct = typeUtils.getPointerStructByType(type, arg)\n          return accessStruct(newArg, struct)\n        }\n        else if (typeUtils.isPointerBuiltinType(type, arg)) {\n          return statement.context.factory.createCallExpression(\n            statement.context.factory.createElementAccessExpression(\n              statement.addMemoryImport(constant.ctypeEnumRead) as ts.Expression,\n              typeUtils.getPointerBuiltinByType(type, arg)\n            ),\n            undefined,\n            [\n              newArg as ts.Expression\n            ]\n          )\n        }\n        else {\n          reportError(statement.currentFile, node, 'accessof only support in cheap builtin type or struct type')\n          return node\n        }\n      }\n      else {\n        reportError(statement.currentFile, node, `the type of ${arg.getText()} is not pointer`)\n        return node\n      }\n    }\n    else if (callName === constant.offsetof && !statement.lookupFunc(constant.offsetof)) {\n      if (node.arguments.length === 2) {\n        const type = statement.typeChecker.getTypeAtLocation(node.arguments[0])\n        if (typeUtils.isStructType(type) && ts.isStringLiteral(node.arguments[1])) {\n          const struct = typeUtils.getStructByType(type)\n          const meta = getStructMeta(struct, node.arguments[1].text)\n          if (meta) {\n            return statement.context.factory.createNumericLiteral(meta[KeyMetaKey.BaseAddressOffset])\n          }\n          else {\n            reportError(statement.currentFile, node, `struct ${struct.name} has not property ${node.arguments[1].text}`)\n            return node\n          }\n        }\n        else {\n          reportError(statement.currentFile, node, 'offsetof invalid arguments')\n          return node\n        }\n      }\n      else {\n        reportError(statement.currentFile, node, 'offsetof invalid arguments')\n        return node\n      }\n    }\n    else if (callName === constant.staticCast && !statement.lookupFunc(constant.staticCast)) {\n      const newNode = ts.visitNode(node.arguments[0], visitor)\n      let sourceType = nodeUtils.getBinaryBuiltinTypeName(node.arguments[0])\n      let targetType = node.typeArguments[0]\n        && statement.typeChecker.getTypeAtLocation(node.typeArguments[0])?.aliasSymbol?.escapedName as string || ''\n\n      if (!targetType && ts.isTypeReferenceNode(node.typeArguments[0]) && ts.isIdentifier(node.typeArguments[0].typeName)) {\n        targetType = node.typeArguments[0].typeName.escapedText as string\n      }\n      if (targetType === constant.typePointer\n        || targetType === constant.typeSize\n      ) {\n        targetType = statement.cheapCompilerOptions.defined.WASM_64 ? 'uint64' : 'uint32'\n      }\n\n      const argType = statement.typeChecker.getTypeAtLocation(node.arguments[0])\n      // uint 字面量直接不做转换\n      if (array.has(BuiltinUint, sourceType)\n        && (argType.flags & ts.TypeFlags.BigIntLiteral || argType.flags & ts.TypeFlags.NumberLiteral)\n        && CTypeEnum2Bytes[Type2CTypeEnum[targetType]] === CTypeEnum2Bytes[Type2CTypeEnum[sourceType]]\n      ) {\n        sourceType = targetType\n      }\n\n      if (array.has(BuiltinNumber, targetType)) {\n        let exp = newNode as ts.Expression\n        // float double -> int32\n        // a >> 0\n        if (array.has(BuiltinFloat, sourceType)) {\n          exp = statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n            statement.context.factory.createParenthesizedExpression(newNode as ts.Expression),\n            ts.SyntaxKind.GreaterThanGreaterThanToken,\n            statement.context.factory.createNumericLiteral(0)\n          ))\n          sourceType = 'int32'\n        }\n        // uint64 int64, bigint -> int32 uint32, number\n        // Number(a)\n        else if (array.has(BuiltinBigInt, sourceType)) {\n\n          let bits = CTypeEnum2Bytes[Type2CTypeEnum[targetType]] * 8\n\n          if (!array.has(BuiltinFloat, targetType)) {\n            if (array.has(BuiltinUint, targetType)) {\n              exp = statement.context.factory.createCallExpression(\n                statement.context.factory.createPropertyAccessExpression(\n                  statement.context.factory.createIdentifier('BigInt'),\n                  statement.context.factory.createIdentifier('asUintN')\n                ),\n                undefined,\n                [\n                  statement.context.factory.createNumericLiteral(bits),\n                  newNode as ts.Expression\n                ]\n              ) as ts.Expression\n            }\n            else {\n              exp = statement.context.factory.createCallExpression(\n                statement.context.factory.createPropertyAccessExpression(\n                  statement.context.factory.createIdentifier('BigInt'),\n                  statement.context.factory.createIdentifier('asIntN')\n                ),\n                undefined,\n                [\n                  statement.context.factory.createNumericLiteral(bits),\n                  newNode as ts.Expression\n                ]\n              ) as ts.Expression\n            }\n\n            exp = statement.context.factory.createCallExpression(\n              statement.context.factory.createIdentifier('Number'),\n              undefined,\n              [\n                exp\n              ]\n            )\n          }\n          else {\n            exp = statement.context.factory.createCallExpression(\n              statement.context.factory.createIdentifier('Number'),\n              undefined,\n              [\n                newNode as ts.Expression\n              ]\n            ) as ts.Expression\n          }\n          sourceType = targetType\n        }\n\n        // 8 bit\n        // a & 0xff\n        if (CTypeEnum2Bytes[Type2CTypeEnum[sourceType]] > 1\n          && CTypeEnum2Bytes[Type2CTypeEnum[targetType]] === 1\n        ) {\n          exp = statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n            exp,\n            ts.SyntaxKind.AmpersandToken,\n            statement.context.factory.createNumericLiteral('0xff', ts.TokenFlags.HexSpecifier)\n          ))\n          sourceType = 'uint8'\n        }\n        // 16 bit\n        // a & 0xffff\n        else if (CTypeEnum2Bytes[Type2CTypeEnum[sourceType]] > 2\n          && CTypeEnum2Bytes[Type2CTypeEnum[targetType]] === 2\n        ) {\n          exp = statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n            exp,\n            ts.SyntaxKind.AmpersandToken,\n            statement.context.factory.createNumericLiteral('0xffff', ts.TokenFlags.HexSpecifier)\n          ))\n          sourceType = 'uint16'\n        }\n\n        if (array.has(BuiltinUint, sourceType) && !array.has(BuiltinUint, targetType)) {\n          // uint -> int\n          // a >> 0\n          if (CTypeEnum2Bytes[Type2CTypeEnum[targetType]] === 1) {\n            exp = statement.context.factory.createConditionalExpression(\n              statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n                exp,\n                ts.SyntaxKind.AmpersandToken,\n                statement.context.factory.createNumericLiteral('0x80', ts.TokenFlags.HexSpecifier)\n              )),\n              statement.context.factory.createToken(ts.SyntaxKind.QuestionToken),\n              statement.context.factory.createPrefixUnaryExpression(\n                ts.SyntaxKind.MinusToken,\n                statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n                  statement.context.factory.createNumericLiteral('0x100', ts.TokenFlags.HexSpecifier),\n                  ts.SyntaxKind.MinusToken,\n                  exp\n                ))\n              ),\n              statement.context.factory.createToken(ts.SyntaxKind.ColonToken),\n              exp\n            )\n          }\n          else if (CTypeEnum2Bytes[Type2CTypeEnum[targetType]] === 2) {\n            exp = statement.context.factory.createConditionalExpression(\n              statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n                exp,\n                ts.SyntaxKind.AmpersandToken,\n                statement.context.factory.createNumericLiteral('0x80000', ts.TokenFlags.HexSpecifier)\n              )),\n              statement.context.factory.createToken(ts.SyntaxKind.QuestionToken),\n              statement.context.factory.createPrefixUnaryExpression(\n                ts.SyntaxKind.MinusToken,\n                statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n                  statement.context.factory.createNumericLiteral('0x10000', ts.TokenFlags.HexSpecifier),\n                  ts.SyntaxKind.MinusToken,\n                  exp\n                ))\n              ),\n              statement.context.factory.createToken(ts.SyntaxKind.ColonToken),\n              exp\n            )\n          }\n          else {\n            exp = statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n              exp,\n              ts.SyntaxKind.GreaterThanGreaterThanToken,\n              statement.context.factory.createNumericLiteral(0)\n            ))\n          }\n        }\n        else if (!array.has(BuiltinUint, sourceType) && !array.has(BuiltinBool, sourceType) && array.has(BuiltinUint, targetType)) {\n          // int -> uint\n          // a >>> 0\n          if (CTypeEnum2Bytes[Type2CTypeEnum[targetType]] === 1) {\n            exp = statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n              exp,\n              ts.SyntaxKind.AmpersandToken,\n              statement.context.factory.createNumericLiteral('0xff', ts.TokenFlags.HexSpecifier)\n            ))\n          }\n          else if (CTypeEnum2Bytes[Type2CTypeEnum[targetType]] === 2) {\n            exp = statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n              exp,\n              ts.SyntaxKind.AmpersandToken,\n              statement.context.factory.createNumericLiteral('0xffff', ts.TokenFlags.HexSpecifier)\n            ))\n          }\n          else {\n            exp = statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n              exp,\n              ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken,\n              statement.context.factory.createNumericLiteral(0)\n            ))\n          }\n        }\n\n        if (array.has(BuiltinBool, sourceType)) {\n          if (exp.kind === ts.SyntaxKind.TrueKeyword) {\n            exp = statement.context.factory.createNumericLiteral(1)\n          }\n          else if (exp.kind === ts.SyntaxKind.FalseKeyword) {\n            exp = statement.context.factory.createNumericLiteral(0)\n          }\n          else {\n            exp = statement.context.factory.createConditionalExpression(\n              statement.context.factory.createParenthesizedExpression(exp),\n              statement.context.factory.createToken(ts.SyntaxKind.QuestionToken),\n              statement.context.factory.createNumericLiteral(1),\n              statement.context.factory.createToken(ts.SyntaxKind.ColonToken),\n              statement.context.factory.createNumericLiteral(0)\n            )\n          }\n        }\n\n        if (ts.isBinaryExpression(exp) || ts.isConditionalExpression(exp)) {\n          exp = statement.context.factory.createParenthesizedExpression(exp)\n        }\n\n        return exp\n      }\n      else if (array.has(BuiltinBigInt, targetType)) {\n\n        let exp = newNode as ts.Expression\n        const sourceBytes = CTypeEnum2Bytes[Type2CTypeEnum[sourceType]]\n\n        // float double -> int32\n        if (array.has(BuiltinFloat, sourceType)) {\n          exp = statement.context.factory.createCallExpression(\n            statement.context.factory.createPropertyAccessExpression(\n              statement.context.factory.createIdentifier('Math'),\n              statement.context.factory.createIdentifier('floor')\n            ),\n            undefined,\n            [\n              exp\n            ]\n          )\n          exp = statement.context.factory.createCallExpression(\n            statement.context.factory.createIdentifier('BigInt'),\n            undefined,\n            [\n              exp\n            ]\n          )\n          sourceType = 'int64'\n        }\n        // int32 uint32 -> bigint\n        if (array.has(BuiltinNumber, sourceType)) {\n          let isInt64 = false\n          if (!array.has(BuiltinUint, sourceType)) {\n            if (array.has(BuiltinUint, targetType)) {\n              exp = statement.context.factory.createBinaryExpression(\n                exp,\n                ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken,\n                statement.context.factory.createNumericLiteral(0)\n              )\n            }\n            else {\n              exp = statement.context.factory.createBinaryExpression(\n                exp,\n                ts.SyntaxKind.GreaterThanGreaterThanToken,\n                statement.context.factory.createNumericLiteral(0)\n              )\n              isInt64 = true\n            }\n          }\n          exp = statement.context.factory.createCallExpression(\n            statement.context.factory.createIdentifier('BigInt'),\n            undefined,\n            [\n              exp\n            ]\n          )\n          sourceType = isInt64 ? 'int64' : 'uint64'\n        }\n\n        if (array.has(BuiltinUint, sourceType) && !array.has(BuiltinUint, targetType) && sourceBytes === 8) {\n          // uint64 -> int64\n          exp = statement.context.factory.createCallExpression(\n            statement.context.factory.createPropertyAccessExpression(\n              statement.context.factory.createIdentifier('BigInt'),\n              statement.context.factory.createIdentifier('asIntN')\n            ),\n            undefined,\n            [\n              statement.context.factory.createNumericLiteral(64),\n              exp\n            ]\n          )\n        }\n        else if (!array.has(BuiltinUint, sourceType) && !array.has(BuiltinBool, sourceType) && array.has(BuiltinUint, targetType)) {\n          // int64 -> uint64\n          exp = statement.context.factory.createCallExpression(\n            statement.context.factory.createPropertyAccessExpression(\n              statement.context.factory.createIdentifier('BigInt'),\n              statement.context.factory.createIdentifier('asUintN')\n            ),\n            undefined,\n            [\n              statement.context.factory.createNumericLiteral(64),\n              exp\n            ]\n          )\n        }\n\n        if (array.has(BuiltinBool, sourceType)) {\n          if (exp.kind === ts.SyntaxKind.TrueKeyword) {\n            exp = statement.context.factory.createBigIntLiteral('1n')\n          }\n          else if (exp.kind === ts.SyntaxKind.FalseKeyword) {\n            exp = statement.context.factory.createBigIntLiteral('0n')\n          }\n          else {\n            exp = statement.context.factory.createConditionalExpression(\n              statement.context.factory.createParenthesizedExpression(exp),\n              statement.context.factory.createToken(ts.SyntaxKind.QuestionToken),\n              statement.context.factory.createBigIntLiteral('1n'),\n              statement.context.factory.createToken(ts.SyntaxKind.ColonToken),\n              statement.context.factory.createBigIntLiteral('0n')\n            )\n          }\n        }\n\n        if (ts.isBinaryExpression(exp) || ts.isConditionalExpression(exp)) {\n          exp = statement.context.factory.createParenthesizedExpression(exp)\n        }\n        return exp\n      }\n      else if (array.has(BuiltinFloat, targetType)) {\n\n        let exp = newNode as ts.Expression\n\n        if (array.has(BuiltinBigInt, sourceType)) {\n          exp = statement.context.factory.createCallExpression(\n            statement.context.factory.createIdentifier('Number'),\n            undefined,\n            [\n              exp\n            ]\n          )\n        }\n\n        if (array.has(BuiltinBool, sourceType)) {\n          if (exp.kind === ts.SyntaxKind.TrueKeyword) {\n            exp = statement.context.factory.createNumericLiteral(1.0)\n          }\n          else if (exp.kind === ts.SyntaxKind.FalseKeyword) {\n            exp = statement.context.factory.createNumericLiteral(0.0)\n          }\n          else {\n            exp = statement.context.factory.createConditionalExpression(\n              statement.context.factory.createParenthesizedExpression(exp),\n              statement.context.factory.createToken(ts.SyntaxKind.QuestionToken),\n              statement.context.factory.createNumericLiteral(1.0),\n              statement.context.factory.createToken(ts.SyntaxKind.ColonToken),\n              statement.context.factory.createNumericLiteral(0.0)\n            )\n          }\n        }\n\n        if (ts.isBinaryExpression(exp) || ts.isConditionalExpression(exp)) {\n          exp = statement.context.factory.createParenthesizedExpression(exp)\n        }\n        return exp\n      }\n      else if (array.has(BuiltinBool, targetType)) {\n\n        let exp = newNode as ts.Expression\n\n        if (ts.isBinaryExpression(exp) || ts.isConditionalExpression(exp)) {\n          exp = statement.context.factory.createParenthesizedExpression(exp)\n        }\n\n        return statement.context.factory.createPrefixUnaryExpression(\n          ts.SyntaxKind.ExclamationToken,\n          statement.context.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.ExclamationToken,\n            exp\n          )\n        )\n      }\n      return statement.context.factory.createParenthesizedExpression(newNode as ts.Expression)\n    }\n    else if (callName === constant.reinterpretCast && !statement.lookupFunc(constant.reinterpretCast)) {\n      if (statement.cheapCompilerOptions.defined.WASM_64) {\n        let targetType = node.typeArguments[0]\n          && statement.typeChecker.getTypeAtLocation(node.typeArguments[0])?.aliasSymbol?.escapedName as string || ''\n\n        // 转 size 和 pointer 64 位需要变成 bigint\n        if (targetType === constant.typeSize\n          || targetType === constant.typePointer\n        ) {\n          const sourceType = nodeUtils.getBinaryBuiltinTypeName(node.arguments[0])\n          if (!array.has(BuiltinBigInt, sourceType)) {\n            return nodeUtils.createPointerOperand(ts.visitNode(node.arguments[0], visitor) as Expression)\n          }\n        }\n        // size 和 pointer 转 number\n        const sourceType = statement.typeChecker.getTypeAtLocation(node.arguments[0])\n        if ((typeUtils.isSizeType(sourceType) || typeUtils.isPointerType(sourceType, node.arguments[0]))\n          && !array.has(BuiltinBigInt, targetType)\n          && targetType !== constant.typePointer\n          && targetType !== constant.typeSize\n        ) {\n          const result = ts.visitNode(node.arguments[0], visitor) as Expression\n          if (nodeUtils.isBigIntNode(result)) {\n            return statement.context.factory.createNumericLiteral(Number(nodeUtils.getBigIntValue(result as ts.BigIntLiteral)))\n          }\n          return statement.context.factory.createCallExpression(\n            statement.context.factory.createIdentifier('Number'),\n            undefined,\n            [\n              result\n            ]\n          )\n        }\n      }\n      return ts.visitNode(node.arguments[0], visitor)\n    }\n    else if (callName === constant.defined\n      && !statement.lookupFunc(constant.defined)\n      && node.arguments.length === 1 && ts.isIdentifier(node.arguments[0])\n    ) {\n      const name = node.arguments[0].escapedText as string\n      return definedReplace(name, node)\n    }\n    else if (callName === constant.move && !statement.lookupFunc(constant.move)) {\n      const { newArgument } = formatArgument(signature, node.arguments)\n      return ts.visitNode(\n        statement.context.factory.createCallExpression(\n          statement.context.factory.createIdentifier(constant.addressof),\n          undefined,\n          newArgument\n        ),\n        visitor\n      )\n    }\n    else if (callName === constant.malloc && !statement.lookupFunc(constant.malloc)) {\n      const { newArgument } = formatArgument(signature, node.arguments)\n      return ts.visitNode(\n        statement.context.factory.createCallExpression(\n          statement.context.factory.createPropertyAccessExpression(\n            statement.addIdentifierImport(constant.Allocator, constant.InternalPath, false),\n            statement.context.factory.createIdentifier(constant.malloc)\n          ),\n          undefined,\n          newArgument\n        ),\n        visitor\n      )\n    }\n    else if (callName === constant.calloc && !statement.lookupFunc(constant.calloc)) {\n      const { newArgument } = formatArgument(signature, node.arguments)\n      return ts.visitNode(\n        statement.context.factory.createCallExpression(\n          statement.context.factory.createPropertyAccessExpression(\n            statement.addIdentifierImport(constant.Allocator, constant.InternalPath, false),\n            statement.context.factory.createIdentifier(constant.calloc)\n          ),\n          undefined,\n          newArgument\n        ),\n        visitor\n      )\n    }\n    else if (callName === constant.realloc && !statement.lookupFunc(constant.realloc)) {\n      const { newArgument } = formatArgument(signature, node.arguments)\n      return ts.visitNode(\n        statement.context.factory.createCallExpression(\n          statement.context.factory.createPropertyAccessExpression(\n            statement.addIdentifierImport(constant.Allocator, constant.InternalPath, false),\n            statement.context.factory.createIdentifier(constant.realloc)\n          ),\n          undefined,\n          newArgument\n        ),\n        visitor\n      )\n    }\n    else if (callName === constant.alignedAlloc && !statement.lookupFunc(constant.alignedAlloc)) {\n      const { newArgument } = formatArgument(signature, node.arguments)\n      return ts.visitNode(\n        statement.context.factory.createCallExpression(\n          statement.context.factory.createPropertyAccessExpression(\n            statement.addIdentifierImport(constant.Allocator, constant.InternalPath, false),\n            statement.context.factory.createIdentifier('alignedAlloc')\n          ),\n          undefined,\n          newArgument\n        ),\n        visitor\n      )\n    }\n    else if (callName === constant.free && !statement.lookupFunc(constant.free)) {\n      const { newArgument } = formatArgument(signature, node.arguments)\n      return ts.visitNode(\n        statement.context.factory.createCallExpression(\n          statement.context.factory.createPropertyAccessExpression(\n            statement.addIdentifierImport(constant.Allocator, constant.InternalPath, false),\n            statement.context.factory.createIdentifier(constant.free)\n          ),\n          undefined,\n          newArgument\n        ),\n        visitor\n      )\n    }\n    else if (callName === constant.make && !statement.lookupFunc(constant.make)) {\n      if (node.arguments.length < 2) {\n        if (!node.typeArguments\n          || node.typeArguments.length !== 1\n          || !ts.isTypeReferenceNode(node.typeArguments[0])\n          || !ts.isIdentifier(node.typeArguments[0].typeName)\n        ) {\n          reportError(statement.currentFile, node, 'invalid typeArguments', error.INVALID_OPERATE)\n          return node\n        }\n        const type = statement.typeChecker.getTypeAtLocation(node.typeArguments[0].typeName)\n        const isValid = type.symbol\n          && type.symbol.valueDeclaration\n          && ts.isClassDeclaration(type.symbol.valueDeclaration)\n          && hasStruct(type.symbol)\n\n        if (!isValid) {\n          reportError(statement.currentFile, node, `invalid typeArguments, not found struct defined of ${node.typeArguments[0].typeName.escapedText}`, error.INVALID_OPERATE)\n          return node\n        }\n      }\n      const tree = ts.visitEachChild(node, statement.visitor, statement.context)\n      return statement.context.factory.createCallExpression(\n        statement.addIdentifierImport(constant.make, constant.RootPath, false),\n        undefined,\n        tree.arguments\n      )\n    }\n    else if (callName === constant.makeSharedPtr && !statement.lookupFunc(constant.makeSharedPtr)) {\n      if (node.arguments.length < 3) {\n        if (!node.typeArguments\n          || node.typeArguments.length !== 1\n          || !ts.isTypeReferenceNode(node.typeArguments[0])\n          || !ts.isIdentifier(node.typeArguments[0].typeName)\n        ) {\n          reportError(statement.currentFile, node, 'invalid typeArguments', error.INVALID_OPERATE)\n          return node\n        }\n\n        const type = statement.typeChecker.getTypeAtLocation(node.typeArguments[0].typeName)\n        const isValid = type.symbol\n          && type.symbol.valueDeclaration\n          && ts.isClassDeclaration(type.symbol.valueDeclaration)\n          && hasStruct(type.symbol)\n          || typeUtils.isBuiltinType(type, null)\n\n        if (!isValid) {\n          reportError(statement.currentFile, node, `invalid typeArguments, not found struct defined of ${node.typeArguments[0].typeName.escapedText} or ${node.typeArguments[0].typeName.escapedText} is not builtin type`, error.INVALID_OPERATE)\n          return node\n        }\n      }\n      const tree = ts.visitEachChild(node, statement.visitor, statement.context)\n      return statement.context.factory.createCallExpression(\n        statement.addIdentifierImport(constant.makeSharedPtrImportName, constant.InternalPath, false),\n        undefined,\n        tree.arguments\n      )\n    }\n    else if (callName === constant.unmake && !statement.lookupFunc(constant.unmake)) {\n      const tree = ts.visitEachChild(node, statement.visitor, statement.context)\n      return statement.context.factory.createCallExpression(\n        statement.addIdentifierImport(constant.unmake, constant.RootPath, false),\n        undefined,\n        tree.arguments\n      )\n    }\n  }\n  else if (ts.isPropertyAccessExpression(node.expression)) {\n    if (callName === constant.indexOf) {\n      const type = statement.typeChecker.getTypeAtLocation(node.expression.expression)\n      if (typeUtils.isPointerType(type, node.expression.expression) && node.arguments[0]) {\n\n        let tree = ts.visitNode(node.expression.expression, visitor)\n\n        if (typeUtils.isPointerStructType(type, node.expression.expression)) {\n          const struct = typeUtils.getPointerStructByType(type, node.expression.expression)\n          if (struct) {\n            let offset: ts.Expression = null\n            if (ts.isNumericLiteral(node.arguments[0])) {\n              if (+node.arguments[0].text) {\n                offset = nodeUtils.createPointerOperand(+node.arguments[0].text * struct.length)\n              }\n            }\n            else {\n              offset = nodeUtils.createPointerOperand(statement.context.factory.createBinaryExpression(\n                ts.visitNode(node.arguments[0], visitor) as ts.Expression,\n                ts.SyntaxKind.AsteriskToken,\n                statement.context.factory.createNumericLiteral(struct.length)\n              ))\n            }\n\n            tree = offset ? statement.context.factory.createBinaryExpression(\n              tree as ts.Expression,\n              ts.SyntaxKind.PlusToken,\n              offset\n            ) : tree\n            return accessStruct(tree, struct)\n          }\n        }\n        else if (typeUtils.isPointerBuiltinType(type, node.expression.expression)) {\n          const ctype = typeUtils.getPointerBuiltinByType(type, node.expression.expression)\n          const byteLength = CTypeEnum2Bytes[ctype]\n          if (byteLength) {\n\n            let offset: ts.Expression = null\n            if (ts.isNumericLiteral(node.arguments[0])) {\n              if (+node.arguments[0].text) {\n                offset = nodeUtils.createPointerOperand(+node.arguments[0].text * byteLength)\n              }\n            }\n            else {\n              offset = nodeUtils.createPointerOperand(statement.context.factory.createBinaryExpression(\n                ts.visitNode(node.arguments[0], visitor) as ts.Expression,\n                ts.SyntaxKind.AsteriskToken,\n                statement.context.factory.createNumericLiteral(byteLength)\n              ))\n            }\n\n            tree = offset ? statement.context.factory.createBinaryExpression(\n              tree as ts.Expression,\n              ts.SyntaxKind.PlusToken,\n              offset\n            ) : tree\n            return accessCType(tree, ctype)\n          }\n\n        }\n      }\n    }\n  }\n\n  if (signature && node.arguments.length) {\n    const { hasSizeParameter, newArgument } = formatArgument(signature, node.arguments)\n    if (hasSizeParameter) {\n      return ts.visitNode(statement.context.factory.createCallExpression(\n        node.expression,\n        node.typeArguments,\n        [\n          ...newArgument\n        ]\n      ), visitor)\n    }\n  }\n\n  return ts.visitEachChild(node, visitor, statement.context)\n}\n","\nimport ts from 'typescript'\nimport statement, { StageStatus } from '../statement'\nimport reportError from '../function/reportError'\nimport { CTypeEnum, CTypeEnum2Bytes, KeyMetaKey } from '../../typedef'\nimport relativePath from '../function/relativePath'\nimport * as nodeUtils from '../util/nodeutil'\nimport * as typeUtils from '../util/typeutil'\nimport * as constant from '../constant'\nimport type { KeyMetaExt } from '../struct'\nimport { StructType } from '../struct'\nimport getStructMeta from '../function/getStructMeta'\nimport { BuiltinBigInt, CTypeEnum2Type } from '../defined'\nimport { is, array } from '@libmedia/common'\n\nfunction createPlusExpress(tree: ts.Node, right: ts.Node) {\n  // 合并 a + 2 + 3\n  if (ts.isBinaryExpression(tree)\n    && tree.operatorToken.kind === ts.SyntaxKind.PlusToken\n    && (ts.isNumericLiteral(tree.right) || nodeUtils.isBigIntNode(tree.right)\n      || ts.isNumericLiteral(tree.left) || nodeUtils.isBigIntNode(tree.left)\n    )\n    && (ts.isNumericLiteral(right) || nodeUtils.isBigIntNode(right))\n  ) {\n    if (ts.isNumericLiteral(tree.right)) {\n      return statement.context.factory.createBinaryExpression(\n        tree.left,\n        ts.SyntaxKind.PlusToken,\n        statement.context.factory.createNumericLiteral((+tree.right.text) + (+(right as ts.NumericLiteral).text))\n      )\n    }\n    else if (nodeUtils.isBigIntNode(tree.right)) {\n      return statement.context.factory.createBinaryExpression(\n        tree.left,\n        ts.SyntaxKind.PlusToken,\n        nodeUtils.createBitInt(Number(nodeUtils.getBigIntValue(tree.right as ts.BigIntLiteral)\n              + nodeUtils.getBigIntValue(right as ts.BigIntLiteral)))\n      )\n    }\n    else if (ts.isNumericLiteral(tree.left)) {\n      return statement.context.factory.createBinaryExpression(\n        statement.context.factory.createNumericLiteral((+tree.left.text) + (+(right as ts.NumericLiteral).text)),\n        ts.SyntaxKind.PlusToken,\n        tree.right\n      )\n    }\n    else if (nodeUtils.isBigIntNode(tree.left)) {\n      return statement.context.factory.createBinaryExpression(\n        nodeUtils.createBitInt(Number(nodeUtils.getBigIntValue(tree.left as ts.BigIntLiteral)\n              + nodeUtils.getBigIntValue(right as ts.BigIntLiteral))),\n        ts.SyntaxKind.PlusToken,\n        tree.right\n      )\n    }\n  }\n  return statement.context.factory.createBinaryExpression(\n    tree as ts.Expression,\n    ts.SyntaxKind.PlusToken,\n    nodeUtils.createPointerOperand(right as ts.Expression)\n  )\n}\n\nfunction handleMeta(node: ts.Node, tree: ts.Node, meta: KeyMetaExt) {\n  if (meta[KeyMetaKey.Pointer]) {\n    tree = statement.context.factory.createCallExpression(\n      statement.context.factory.createElementAccessExpression(\n        statement.addMemoryImport(constant.ctypeEnumRead),\n        CTypeEnum.pointer\n      ),\n      undefined,\n      [\n        meta[KeyMetaKey.BaseAddressOffset]\n          ? createPlusExpress(\n            tree as ts.Expression,\n            nodeUtils.createPointerOperand(meta[KeyMetaKey.BaseAddressOffset])\n          )\n          : tree as ts.Expression\n      ]\n    )\n    return tree\n  }\n  else if (is.number(meta[KeyMetaKey.Type]) && !is.func(meta.getTypeMeta)) {\n    tree = statement.context.factory.createCallExpression(\n      statement.context.factory.createElementAccessExpression(\n        statement.addMemoryImport(constant.ctypeEnumRead),\n        meta[KeyMetaKey.Type] as number\n      ),\n      undefined,\n      [\n        meta[KeyMetaKey.BaseAddressOffset]\n          ? createPlusExpress(\n            tree as ts.Expression,\n            nodeUtils.createPointerOperand(meta[KeyMetaKey.BaseAddressOffset])\n          )\n          : tree as ts.Expression\n      ]\n    )\n\n    if (meta[KeyMetaKey.BitField] && !statement.lookupStage(StageStatus.AddressOf)) {\n      const shift = CTypeEnum2Bytes[meta[KeyMetaKey.Type] as number] * 8 - meta[KeyMetaKey.BaseBitOffset] - meta[KeyMetaKey.BitFieldLength]\n      let isBigInt = array.has(BuiltinBigInt, CTypeEnum2Type[meta[KeyMetaKey.Type]])\n      if (statement.cheapCompilerOptions.defined.WASM_64) {\n        if (meta[KeyMetaKey.Type] === CTypeEnum.pointer\n          || meta[KeyMetaKey.Type] === CTypeEnum.size\n        ) {\n          isBigInt = true\n        }\n      }\n      const mask = Math.pow(2, meta[KeyMetaKey.BitFieldLength]) - 1\n      tree = statement.context.factory.createBinaryExpression(\n        statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n          tree as ts.Expression,\n          ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken,\n          isBigInt\n            ? nodeUtils.createBitInt(shift)\n            : statement.context.factory.createNumericLiteral(shift)\n        )),\n        ts.SyntaxKind.AmpersandToken,\n        isBigInt\n          ? nodeUtils.createBitInt(shift)\n          : statement.context.factory.createNumericLiteral(mask)\n      )\n    }\n\n    return tree\n  }\n  else if (is.func(meta.getTypeMeta)) {\n    const targetStruct = meta.getTypeMeta()\n\n    let targetSymbol = targetStruct.symbol.deref()\n    let targetPath = ''\n\n    if (targetStruct.structType === StructType.INLINE_OBJECT) {\n      targetSymbol = targetStruct.definedClassParent.symbol.deref()\n      targetPath = targetStruct.definedClassParent.inlineStructPathMap.get(targetStruct.symbol.deref())\n    }\n\n    const targetSource = targetSymbol.valueDeclaration?.getSourceFile()\n    if (targetSource) {\n      let key: ts.Expression\n      if (targetSource !== statement.currentFile) {\n        // addressof(pointer.struct) 不需要导入\n        if (node.parent\n          && ts.isCallExpression(node.parent)\n          && ts.isIdentifier(node.parent.expression)\n          && node.parent.expression.escapedText === constant.addressof\n          && !statement.lookupFunc(constant.addressof)\n        ) {\n          key = statement.context.factory.createIdentifier('undefined')\n        }\n        else {\n          key = statement.addStructImport(\n            targetSymbol,\n            targetSource\n          )\n        }\n      }\n      else {\n        key = statement.context.factory.createIdentifier(targetSymbol.escapedName as string)\n      }\n      const args = [\n        meta[KeyMetaKey.BaseAddressOffset]\n          ? createPlusExpress(\n            tree as ts.Expression,\n            nodeUtils.createPointerOperand(meta[KeyMetaKey.BaseAddressOffset])\n          )\n          : tree as ts.Expression,\n        key\n      ]\n      if (targetPath) {\n        args.push(statement.context.factory.createStringLiteral(targetPath))\n      }\n      return statement.context.factory.createCallExpression(\n        statement.addIdentifierImport(constant.structAccess, constant.RootPath, false),\n        undefined,\n        args\n      )\n    }\n  }\n  else {\n    reportError(statement.currentFile, node, 'struct type mismatch')\n    return node\n  }\n}\n\nexport default function (node: ts.PropertyAccessExpression, visitor: ts.Visitor): ts.Node {\n  if (nodeUtils.isPointerNode(node)\n    && !(array.has(constant.smartPointerProperty, node.name.escapedText as string) && nodeUtils.isSmartPointerNode(node.expression))\n  ) {\n    if (statement.getCurrentStage()?.stage !== StageStatus.EqualLeft) {\n      let root: ts.Node = nodeUtils.getPropertyAccessExpressionRootNode(node)\n      let tree: ts.Node = root\n\n      let next = root.parent as ts.PropertyAccessExpression | ts.CallExpression | ts.ElementAccessExpression\n      let lastIsIndexOf = false\n      let hasPointerIndex = nodeUtils.isPointerNode(root)\n\n      while (next !== node) {\n        const type = statement.typeChecker.getTypeAtLocation(root)\n        if (lastIsIndexOf\n          || typeUtils.isPointerType(type, root)\n          || typeUtils.isSmartPointerType(type)\n          || type.aliasSymbol?.escapedName === constant.typeArray\n        ) {\n          let struct = lastIsIndexOf\n            ? typeUtils.getStructByType(type)\n            : (\n              typeUtils.isSmartPointerType(type)\n                ? typeUtils.getSmartPointerStructByType(type)\n                : (\n                  typeUtils.isPointerType(type, root)\n                    ? typeUtils.getPointerStructByType(type, root)\n                    : (\n                      typeUtils.isPointerType(type.aliasTypeArguments[0], null)\n                        ? null\n                        : typeUtils.getStructByType(type.aliasTypeArguments[0])\n                    )\n                )\n            )\n\n          if (struct) {\n            if (ts.isPropertyAccessExpression(next)) {\n              if (ts.isCallExpression(next.parent)) {\n                next = next.parent as ts.PropertyAccessExpression | ts.CallExpression | ts.ElementAccessExpression\n                continue\n              }\n              else {\n                const meta = getStructMeta(struct, next.name.escapedText as string)\n\n                if (!meta) {\n                  reportError(statement.currentFile, node, `struct ${struct.symbol.deref().escapedName} not has property ${next.name.escapedText}`)\n                  return node\n                }\n\n                if (typeUtils.isSmartPointerType(type)) {\n                  tree = statement.context.factory.createCallExpression(\n                    statement.context.factory.createPropertyAccessExpression(\n                      tree as ts.Expression,\n                      statement.context.factory.createIdentifier('get')\n                    ),\n                    undefined,\n                    []\n                  )\n                }\n\n                if (meta[KeyMetaKey.Pointer] && !meta[KeyMetaKey.Array]) {\n                  tree = statement.context.factory.createCallExpression(\n                    statement.context.factory.createElementAccessExpression(\n                      statement.addMemoryImport(constant.ctypeEnumRead) as ts.Expression,\n                      CTypeEnum.pointer\n                    ),\n                    undefined,\n                    [\n                      meta[KeyMetaKey.BaseAddressOffset]\n                        ? createPlusExpress(\n                          tree,\n                          nodeUtils.createPointerOperand(meta[KeyMetaKey.BaseAddressOffset])\n                        )\n                        : tree as ts.Expression\n                    ]\n                  )\n                }\n                else if (meta[KeyMetaKey.BaseAddressOffset]) {\n                  tree = createPlusExpress(\n                    tree as ts.Expression,\n                    nodeUtils.createPointerOperand(meta[KeyMetaKey.BaseAddressOffset])\n                  )\n                }\n              }\n              lastIsIndexOf = false\n            }\n            else if (ts.isCallExpression(next)) {\n              if (ts.isNumericLiteral(next.arguments[0]) && +next.arguments[0].text !== 0) {\n                tree = createPlusExpress(\n                  tree as ts.Expression,\n                  nodeUtils.createPointerOperand(+next.arguments[0].text * struct.length)\n                )\n              }\n              else if (!ts.isNumericLiteral(next.arguments[0])) {\n                tree = statement.context.factory.createBinaryExpression(\n                  tree as ts.Expression,\n                  ts.SyntaxKind.PlusToken,\n                  nodeUtils.createPointerOperand(statement.context.factory.createBinaryExpression(\n                    next.arguments[0],\n                    ts.SyntaxKind.AsteriskToken,\n                    statement.context.factory.createNumericLiteral(struct.length)\n                  ))\n                )\n              }\n              lastIsIndexOf = true\n              hasPointerIndex = true\n            }\n            else if (ts.isElementAccessExpression(next)) {\n              if (ts.isNumericLiteral(next.argumentExpression) && +next.argumentExpression.text !== 0) {\n                tree = createPlusExpress(\n                  tree as ts.Expression,\n                  nodeUtils.createPointerOperand(+next.argumentExpression.text * struct.length)\n                )\n              }\n              else if (!ts.isNumericLiteral(next.argumentExpression)) {\n                tree = statement.context.factory.createBinaryExpression(\n                  tree as ts.Expression,\n                  ts.SyntaxKind.PlusToken,\n                  nodeUtils.createPointerOperand(statement.context.factory.createBinaryExpression(\n                    next.argumentExpression,\n                    ts.SyntaxKind.AsteriskToken,\n                    statement.context.factory.createNumericLiteral(struct.length)\n                  ))\n                )\n              }\n              lastIsIndexOf = true\n              hasPointerIndex = true\n            }\n          }\n          // [] 操作\n          else if ((type.aliasSymbol?.escapedName === constant.typeArray || typeUtils.isPointerType(type, root))\n            && typeUtils.isPointerType(type.aliasTypeArguments[0], null)\n            && ts.isElementAccessExpression(next)\n          ) {\n            if (ts.isNumericLiteral(next.argumentExpression) && +next.argumentExpression.text !== 0) {\n              tree = createPlusExpress(\n                tree as ts.Expression,\n                nodeUtils.createPointerOperand(+next.argumentExpression.text * CTypeEnum2Bytes[CTypeEnum.pointer])\n              )\n            }\n            else if (!ts.isNumericLiteral(next.argumentExpression)) {\n              tree = statement.context.factory.createBinaryExpression(\n                tree as ts.Expression,\n                ts.SyntaxKind.PlusToken,\n                nodeUtils.createPointerOperand(statement.context.factory.createBinaryExpression(\n                  next.argumentExpression,\n                  ts.SyntaxKind.AsteriskToken,\n                  statement.context.factory.createNumericLiteral(CTypeEnum2Bytes[CTypeEnum.pointer])\n                ))\n              )\n            }\n\n            tree = statement.context.factory.createCallExpression(\n              statement.context.factory.createElementAccessExpression(\n                statement.addMemoryImport(constant.ctypeEnumRead) as ts.Expression,\n                CTypeEnum.pointer\n              ),\n              undefined,\n              [\n                tree as ts.Expression\n              ]\n            )\n            hasPointerIndex = true\n          }\n          // 指针的 indexOf\n          else if (typeUtils.isPointerType(type, root)\n            && ts.isPropertyAccessExpression(next) && next.name.escapedText === constant.indexOf\n            && ts.isCallExpression(next.parent)\n          ) {\n            next = next.parent as ts.CallExpression\n\n            let step = 0\n            if (typeUtils.isPointerType(type.aliasTypeArguments[0], null)) {\n              step = CTypeEnum2Bytes[CTypeEnum.pointer]\n            }\n            else {\n              const struct = typeUtils.getStructByType(type.aliasTypeArguments[0])\n              if (struct) {\n                step = struct.length\n              }\n              else {\n                reportError(statement.currentFile, node, 'the pointer type only allowed in builtin type or struct type')\n                return node\n              }\n            }\n\n            if (ts.isNumericLiteral(next.arguments[0]) && +next.arguments[0].text !== 0) {\n              tree = createPlusExpress(\n                tree as ts.Expression,\n                nodeUtils.createPointerOperand(+next.arguments[0].text * step)\n              )\n            }\n            else if (!ts.isNumericLiteral(next.arguments[0])) {\n              tree = statement.context.factory.createBinaryExpression(\n                tree as ts.Expression,\n                ts.SyntaxKind.PlusToken,\n                nodeUtils.createPointerOperand(statement.context.factory.createBinaryExpression(\n                  next.arguments[0],\n                  ts.SyntaxKind.AsteriskToken,\n                  statement.context.factory.createNumericLiteral(step)\n                ))\n              )\n            }\n            // 二级指针\n            if (typeUtils.isPointerType(type.aliasTypeArguments[0], null)) {\n              tree = statement.context.factory.createCallExpression(\n                statement.context.factory.createElementAccessExpression(\n                  statement.addMemoryImport(constant.ctypeEnumRead) as ts.Expression,\n                  CTypeEnum.pointer\n                ),\n                undefined,\n                [\n                  tree as ts.Expression\n                ]\n              )\n            }\n\n            lastIsIndexOf = true\n            hasPointerIndex = true\n          }\n          else {\n            reportError(statement.currentFile, node, 'invalid pointer operate')\n            return node\n          }\n        }\n        else {\n          let struct = typeUtils.getStructByType(type)\n          // pointer.struct.xx\n          if (struct && hasPointerIndex && ts.isPropertyAccessExpression(next)) {\n            const meta = getStructMeta(struct, next.name.escapedText as string)\n\n            if (!meta) {\n              reportError(statement.currentFile, node, `struct ${struct.symbol.deref().escapedName} not has property ${next.name.escapedText}`)\n              return node\n            }\n\n            if (meta[KeyMetaKey.Pointer] && !meta[KeyMetaKey.Array]) {\n              tree = statement.context.factory.createCallExpression(\n                statement.context.factory.createElementAccessExpression(\n                  statement.addMemoryImport(constant.ctypeEnumRead) as ts.Expression,\n                  CTypeEnum.pointer\n                ),\n                undefined,\n                [\n                  meta[KeyMetaKey.BaseAddressOffset]\n                    ? createPlusExpress(\n                      tree,\n                      nodeUtils.createPointerOperand(meta[KeyMetaKey.BaseAddressOffset])\n                    )\n                    : tree as ts.Expression\n                ]\n              )\n            }\n            else if (meta[KeyMetaKey.BaseAddressOffset]) {\n              tree = createPlusExpress(\n                tree as ts.Expression,\n                nodeUtils.createPointerOperand(meta[KeyMetaKey.BaseAddressOffset])\n              )\n            }\n            lastIsIndexOf = false\n          }\n          else {\n            tree = next\n          }\n        }\n        root = next\n        next = next.parent as ts.PropertyAccessExpression | ts.CallExpression | ts.ElementAccessExpression\n      }\n\n      if (!nodeUtils.isPointerNode(root) && !hasPointerIndex) {\n        return node\n      }\n\n      const type = statement.typeChecker.getTypeAtLocation(root)\n      let struct = typeUtils.isPointerType(type, root) ? typeUtils.getPointerStructByType(type, root) : typeUtils.getStructByType(type)\n\n      if (!struct) {\n        reportError(statement.currentFile, node, 'struct type mismatch')\n        return node\n      }\n\n      const meta = getStructMeta(struct, node.name.escapedText as string)\n\n      if (!meta) {\n        reportError(statement.currentFile, node, `struct ${struct.symbol.deref().escapedName} not has property ${node.name.escapedText}`)\n        return node\n      }\n\n      statement.pushStage(StageStatus.PointerPlusMinusIgnore)\n      tree = ts.visitNode(tree, visitor)\n      statement.popStage()\n\n      if (ts.isCallExpression(tree)\n        && ts.isIdentifier(tree.expression)\n        && statement.isIdentifier(tree.expression, constant.structAccess, constant.structAccessPath, constant.RootPath)\n      ) {\n        return statement.context.factory.createPropertyAccessExpression(\n          tree,\n          node.name\n        )\n      }\n      return handleMeta(node, tree, meta)\n    }\n  }\n  else if (nodeUtils.isSmartPointerNode(node)) {\n    const expressionType = statement.typeChecker.getTypeAtLocation(node.expression)\n    if (typeUtils.isSmartPointerType(expressionType)\n      && ts.isIdentifier(node.name)\n      && !array.has(constant.smartPointerProperty, node.name.escapedText as string)\n      && expressionType.aliasTypeArguments?.length === 1\n    ) {\n      const struct = typeUtils.getStructByType(expressionType)\n      if (!struct) {\n        reportError(statement.currentFile, node, 'struct type mismatch')\n        return node\n      }\n\n      const meta = getStructMeta(struct, node.name.escapedText as string)\n\n      if (!meta) {\n        reportError(statement.currentFile, node, `struct ${struct.symbol.deref().escapedName} not has property ${node.name.escapedText}`)\n        return node\n      }\n\n      let tree = ts.visitNode(node.expression, visitor)\n\n      tree = statement.context.factory.createCallExpression(\n        statement.context.factory.createPropertyAccessExpression(\n          tree as ts.Expression,\n          statement.context.factory.createIdentifier('get')\n        ),\n        undefined,\n        []\n      )\n\n      return handleMeta(node, tree, meta)\n    }\n  }\n  return ts.visitEachChild(node, visitor, statement.context)\n}\n","import ts from 'typescript'\nexport default function isMergeOperator(operator: ts.SyntaxKind) {\n  return operator === ts.SyntaxKind.PlusEqualsToken\n    || operator === ts.SyntaxKind.MinusEqualsToken\n    || operator === ts.SyntaxKind.AsteriskEqualsToken\n    || operator === ts.SyntaxKind.AsteriskAsteriskEqualsToken\n    || operator === ts.SyntaxKind.SlashEqualsToken\n    || operator === ts.SyntaxKind.PercentEqualsToken\n    || operator === ts.SyntaxKind.LessThanLessThanEqualsToken\n    || operator === ts.SyntaxKind.GreaterThanGreaterThanEqualsToken\n    || operator === ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken\n    || operator === ts.SyntaxKind.AmpersandEqualsToken\n    || operator === ts.SyntaxKind.BarEqualsToken\n    || operator === ts.SyntaxKind.CaretEqualsToken\n}\n","import ts from 'typescript'\nexport default function mergeOperator2Operator(operator: ts.SyntaxKind) {\n  switch (operator) {\n    case ts.SyntaxKind.PlusEqualsToken:\n      return ts.SyntaxKind.PlusToken\n    case ts.SyntaxKind.MinusEqualsToken:\n      return ts.SyntaxKind.MinusToken\n    case ts.SyntaxKind.AsteriskEqualsToken:\n      return ts.SyntaxKind.AsteriskToken\n    case ts.SyntaxKind.AsteriskAsteriskEqualsToken:\n      return ts.SyntaxKind.AsteriskAsteriskToken\n    case ts.SyntaxKind.SlashEqualsToken:\n      return ts.SyntaxKind.SlashToken\n    case ts.SyntaxKind.PercentEqualsToken:\n      return ts.SyntaxKind.PercentToken\n    case ts.SyntaxKind.LessThanLessThanEqualsToken:\n      return ts.SyntaxKind.LessThanLessThanToken\n    case ts.SyntaxKind.GreaterThanGreaterThanEqualsToken:\n      return ts.SyntaxKind.GreaterThanGreaterThanToken\n    case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:\n      return ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken\n    case ts.SyntaxKind.AmpersandEqualsToken:\n      return ts.SyntaxKind.AmpersandToken\n    case ts.SyntaxKind.BarEqualsToken:\n      return ts.SyntaxKind.BarToken\n    case ts.SyntaxKind.CaretEqualsToken:\n      return ts.SyntaxKind.CaretToken\n    default:\n      return ts.SyntaxKind.EqualsToken\n  }\n}\n","import ts from 'typescript'\n\nexport function compute<T extends number | bigint>(a: T, b: T, token: ts.SyntaxKind): T {\n  if (token === ts.SyntaxKind.PlusToken) {\n    return ((a as number) + (b as number)) as T\n  }\n  else if (token === ts.SyntaxKind.MinusToken) {\n    return (a - b) as T\n  }\n  else if (token === ts.SyntaxKind.AsteriskToken) {\n    return (a * b) as T\n  }\n  else if (token === ts.SyntaxKind.AsteriskAsteriskToken) {\n    return (a ** b) as T\n  }\n  else if (token === ts.SyntaxKind.SlashToken) {\n    return (a / b) as T\n  }\n  else if (token === ts.SyntaxKind.PercentToken) {\n    return (a % b) as T\n  }\n  else if (token === ts.SyntaxKind.LessThanLessThanToken) {\n    return (a << b) as T\n  }\n  else if (token === ts.SyntaxKind.GreaterThanGreaterThanToken) {\n    return (a >> b) as T\n  }\n  else if (token === ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken) {\n    return (a >>> b) as T\n  }\n  else if (token === ts.SyntaxKind.AmpersandToken) {\n    return (a & b) as T\n  }\n  else if (token === ts.SyntaxKind.BarToken) {\n    return (a | b) as T\n  }\n}\n","\nimport ts from 'typescript'\nimport { is, array } from '@libmedia/common'\nimport statement, { StageStatus } from '../statement'\nimport reportError from '../function/reportError'\nimport type { KeyMetaExt, Struct } from '../struct'\nimport { hasStruct } from '../struct'\nimport * as constant from '../constant'\nimport { CTypeEnum, CTypeEnum2Bytes, KeyMetaKey } from '../../typedef'\nimport { getEqualsBinaryExpressionRight, isPointerNode } from '../util/nodeutil'\nimport isMergeOperator from '../function/isMergeOperator'\nimport mergeOperator2Operator from '../function/mergeOperator2Operator'\nimport { BuiltinBigInt, BuiltinNumber, CTypeEnum2Type } from '../defined'\nimport * as nodeUtils from '../util/nodeutil'\nimport * as typeUtils from '../util/typeutil'\nimport { compute } from '../function/compute'\nimport getStructMeta from '../function/getStructMeta'\nimport * as error from '../error'\n\nfunction visitorLeft(node: ts.Node, visitor: ts.Visitor, operatorToken: ts.SyntaxKind): ts.Node {\n  let push = false\n  if (operatorToken === ts.SyntaxKind.EqualsToken) {\n    statement.pushStage(StageStatus.EqualLeft)\n    push = true\n  }\n\n  const newNode = ts.visitNode(node, visitor)\n\n  if (push) {\n    statement.popStage()\n  }\n  return newNode\n}\n\nfunction visitorRight(node: ts.Node, visitor: ts.Visitor, operatorToken: ts.SyntaxKind): ts.Node {\n  let push = false\n  if (operatorToken === ts.SyntaxKind.EqualsToken) {\n    statement.pushStage(StageStatus.EqualRight)\n    push = true\n  }\n  const newNode = ts.visitNode(node, visitor)\n\n  if (push) {\n    statement.popStage()\n  }\n\n  return newNode\n}\n\nfunction generateWritePropertyNode(address: ts.Expression, value: ts.Expression, meta: KeyMetaExt) {\n  if (meta[KeyMetaKey.BitField]) {\n    let mask1 = 0\n    let len = CTypeEnum2Bytes[meta[KeyMetaKey.Type] as number] * 8\n    for (let i = 0; i < meta[KeyMetaKey.BitFieldLength]; i++) {\n      mask1 |= (1 << (len - 1 - (i + meta[KeyMetaKey.BaseBitOffset])))\n    }\n    let oldValue: ts.Expression = statement.context.factory.createCallExpression(\n      statement.context.factory.createElementAccessExpression(\n        statement.addMemoryImport(constant.ctypeEnumRead) as ts.Expression,\n        meta[KeyMetaKey.Type] as number\n      ),\n      undefined,\n      [\n        address\n      ]\n    )\n    const mask2 = (Math.pow(2, meta[KeyMetaKey.BitFieldLength]) - 1)\n    const shift = len - meta[KeyMetaKey.BaseBitOffset] - meta[KeyMetaKey.BitFieldLength]\n    let isBigInt = array.has(BuiltinBigInt, CTypeEnum2Type[meta[KeyMetaKey.Type as number]])\n    if (statement.cheapCompilerOptions.defined.WASM_64) {\n      if (meta[KeyMetaKey.Type as number] === CTypeEnum.pointer\n        || meta[KeyMetaKey.Type as number] === CTypeEnum.size\n      ) {\n        isBigInt = true\n        if (meta[KeyMetaKey.Type as number] === CTypeEnum.size) {\n          value = nodeUtils.createPointerOperand(value)\n        }\n      }\n    }\n\n    value = statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n      value,\n      ts.SyntaxKind.AmpersandToken,\n      isBigInt\n        ? nodeUtils.createBitInt(mask2)\n        : statement.context.factory.createNumericLiteral(mask2)\n    ))\n\n    value = statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n      value,\n      ts.SyntaxKind.LessThanLessThanToken,\n      isBigInt\n        ? nodeUtils.createBitInt(shift)\n        : statement.context.factory.createNumericLiteral(shift)\n    ))\n\n    oldValue = statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n      oldValue,\n      ts.SyntaxKind.AmpersandToken,\n      statement.context.factory.createPrefixUnaryExpression(\n        ts.SyntaxKind.TildeToken,\n        isBigInt\n          ? nodeUtils.createBitInt(mask1)\n          : statement.context.factory.createNumericLiteral(mask1)\n      )\n    ))\n\n    value = statement.context.factory.createBinaryExpression(\n      oldValue,\n      ts.SyntaxKind.BarToken,\n      value\n    )\n  }\n\n  return statement.context.factory.createCallExpression(\n    statement.context.factory.createElementAccessExpression(\n      statement.addMemoryImport(constant.ctypeEnumWrite) as ts.Expression,\n      meta[KeyMetaKey.Pointer] ? CTypeEnum.pointer : meta[KeyMetaKey.Type] as number\n    ),\n    undefined,\n    [\n      address as ts.Expression,\n      value\n    ]\n  )\n}\n\nfunction singleArrowVisitor(node: ts.BinaryExpression, visitor: ts.Visitor): ts.Node {\n  if (ts.isPrefixUnaryExpression(node.right)) {\n    if (node.parent && ts.isExpressionStatement(node.parent) && ((ts.isCallExpression(node.left)\n      && (ts.isIdentifier(node.left.expression) && node.left.expression.escapedText === constant.accessof\n        || ts.isPropertyAccessExpression(node.left.expression)\n          && node.left.expression.name.escapedText === constant.indexOf\n          && isPointerNode(node.left.expression.expression)\n      ))\n      || ts.isElementAccessExpression(node.left) && nodeUtils.isPointerElementAccess(node.left))\n    ) {\n      const type1 = statement.typeChecker.getTypeAtLocation(node.left)\n      const type2 = statement.typeChecker.getTypeAtLocation(node.right.operand)\n\n      if (typeUtils.isTypeEquals(type1, node.left, type2, node.right.operand) || typeUtils.isPointerType(type1, node.left) && typeUtils.isNullPointer(type2, node.right.operand)) {\n\n        let left = ts.visitNode(statement.context.factory.createCallExpression(\n          statement.context.factory.createIdentifier(constant.addressof),\n          undefined,\n          [\n            node.left\n          ]\n        ), visitor)\n\n        if (typeUtils.isStructType(type1)) {\n          const struct = typeUtils.getStructByType(type1)\n\n          statement.pushStage(StageStatus.SingleArrowRight)\n\n          const right = ts.visitNode(statement.context.factory.createCallExpression(\n            statement.context.factory.createIdentifier(constant.addressof),\n            undefined,\n            [\n              node.right.operand\n            ]\n          ), visitor) as ts.Expression\n\n          statement.popStage()\n\n          return statement.context.factory.createCallExpression(\n            statement.addMemoryImport(constant.memcpy),\n            undefined,\n            [\n              left as ts.Expression,\n              right,\n              nodeUtils.createPointerOperand(struct.length)\n            ]\n          )\n        }\n        else if (typeUtils.isBuiltinType(type1, node.left)) {\n          const type = typeUtils.getBuiltinByType(type1, node.left)\n          statement.pushStage(StageStatus.SingleArrowRight)\n\n          const right = ts.visitNode(\n            node.right.operand,\n            visitor\n          ) as ts.Expression\n\n          statement.popStage()\n\n          return statement.context.factory.createCallExpression(\n            statement.context.factory.createElementAccessExpression(\n              statement.addMemoryImport(constant.ctypeEnumWrite),\n              type\n            ),\n            undefined,\n            [\n              left as ts.Expression,\n              right\n            ]\n          )\n        }\n        else {\n          reportError(\n            statement.currentFile,\n            node,\n            'operator \\'<-\\' only allowed between two builtin type or struct type'\n          )\n          return node\n        }\n      }\n      else {\n        reportError(statement.currentFile, node, 'The types on the left and right sides of the operator \\'<-\\' are not equal')\n        return node\n      }\n    }\n    else {\n\n      const type1 = statement.typeChecker.getTypeAtLocation(node.left)\n      const type2 = statement.typeChecker.getTypeAtLocation(node.right.operand)\n\n      if (typeUtils.isStructType(type1) && typeUtils.isTypeEquals(type1, node.left, type2, node.right.operand)) {\n        const struct = typeUtils.getStructByType(type1)\n\n        statement.pushStage(StageStatus.SingleArrowRight)\n\n        const right = ts.visitNode(statement.context.factory.createCallExpression(\n          statement.context.factory.createIdentifier(constant.addressof),\n          undefined,\n          [\n            node.right.operand\n          ]\n        ), visitor) as ts.Expression\n\n        statement.popStage()\n\n        const left = ts.visitNode(statement.context.factory.createCallExpression(\n          statement.context.factory.createIdentifier(constant.addressof),\n          undefined,\n          [\n            node.left as ts.Expression\n          ]\n        ), visitor) as ts.Expression\n\n        return statement.context.factory.createCallExpression(\n          statement.addMemoryImport(constant.memcpy),\n          undefined,\n          [\n            left,\n            right,\n            nodeUtils.createPointerOperand(struct.length)\n          ]\n        )\n      }\n    }\n  }\n  return ts.visitEachChild(node, visitor, statement.context)\n}\n\nfunction equalVisitor(node: ts.BinaryExpression, visitor: ts.Visitor): ts.Node {\n\n  const leftType = statement.typeChecker.getTypeAtLocation(node.left)\n  const rightType = statement.typeChecker.getTypeAtLocation(node.right)\n\n  if (typeUtils.isPointerType(leftType, node.left)\n      && (typeUtils.isBuiltinType(rightType, node.right) || rightType.flags & ts.TypeFlags.NumberLike)\n      && !typeUtils.isPointerType(rightType, node.right)\n      && !typeUtils.isNullPointer(rightType, node.right)\n    || typeUtils.isBuiltinType(leftType, node.left)\n      && !typeUtils.isPointerType(leftType, node.left)\n      && !typeUtils.isNullPointer(leftType, node.left)\n      && typeUtils.isPointerType(rightType, node.right)\n  ) {\n    reportError(statement.currentFile, node, `type ${typeUtils.getBuiltinNameByType(leftType) || 'number'} is not assignable to value of type ${typeUtils.getBuiltinNameByType(rightType) || 'number'}`, error.TYPE_MISMATCH)\n    return node\n  }\n\n  if (ts.isIdentifier(node.left) && ts.isIdentifier(node.right)) {\n    return ts.visitEachChild(node, visitor, statement.context)\n  }\n  else {\n    if (ts.isPropertyAccessExpression(node.left)\n      && nodeUtils.isExpressionPointer(node.left)\n      && ts.isObjectLiteralExpression(node.right)\n      && typeUtils.isStructType(statement.typeChecker.getTypeAtLocation(node.left))\n    ) {\n      const list: ts.Expression[] = []\n\n      const addr = ts.visitNode(statement.context.factory.createCallExpression(\n        statement.context.factory.createIdentifier(constant.addressof),\n        undefined,\n        [\n          node.left\n        ]\n      ), visitor) as ts.Expression\n\n      function each(base: number, struct: Struct, properties: ts.NodeArray<ts.ObjectLiteralElementLike>) {\n        properties.forEach((ele) => {\n          if (ts.isPropertyAssignment(ele) && ts.isIdentifier(ele.name)) {\n            if (!struct) {\n              reportError(statement.currentFile, ele, 'struct not found ')\n              return\n            }\n            const meta = getStructMeta(struct, ele.name.escapedText as string)\n            if (ts.isObjectLiteralExpression(ele.initializer) && meta.getTypeMeta) {\n              each(\n                base + meta[KeyMetaKey.BaseAddressOffset],\n                meta.getTypeMeta(),\n                ele.initializer.properties\n              )\n            }\n            else if (is.number(meta[KeyMetaKey.Type])) {\n              list.push(generateWritePropertyNode(\n                (ts.isBinaryExpression(addr)\n                  && ts.isNumericLiteral(addr.right)\n                  && addr.operatorToken.kind === ts.SyntaxKind.PlusToken)\n                  ? statement.context.factory.createBinaryExpression(\n                    addr.left,\n                    ts.SyntaxKind.PlusToken,\n                    nodeUtils.createPointerOperand((meta[KeyMetaKey.BaseAddressOffset] + base) + (+addr.right.text))\n                  )\n                  : statement.context.factory.createBinaryExpression(\n                    addr,\n                    ts.SyntaxKind.PlusToken,\n                    nodeUtils.createPointerOperand(meta[KeyMetaKey.BaseAddressOffset] + base)\n                  ),\n                ele.initializer,\n                meta\n              ))\n            }\n            else {\n              reportError(statement.currentFile, ele, 'struct found invalid property value')\n            }\n          }\n          else {\n            reportError(statement.currentFile, ele, 'struct found invalid property')\n          }\n        })\n      }\n\n      each(0, typeUtils.getStructByType(statement.typeChecker.getTypeAtLocation(node.left)), node.right.properties)\n\n      if (list.length === 0) {\n        return undefined\n      }\n      if (list.length === 1) {\n        return list[0]\n      }\n      else {\n        let left = list[0]\n        for (let i = 1; i < list.length; i++) {\n          left = statement.context.factory.createBinaryExpression(\n            left,\n            ts.SyntaxKind.CommaToken,\n            list[i]\n          )\n        }\n        return left\n      }\n    }\n\n    if (ts.isPropertyAccessExpression(node.left)\n      || ts.isElementAccessExpression(node.left)\n    ) {\n      const hasPointer = nodeUtils.isExpressionPointer(node.left.expression as ts.Identifier)\n      const hasSmartPointer = ts.isPropertyAccessExpression(node.left) && nodeUtils.isSmartPointerNode(node.left.expression)\n      if (hasPointer || hasSmartPointer) {\n        const type1 = statement.typeChecker.getTypeAtLocation(node.left)\n        const type2 = statement.typeChecker.getTypeAtLocation(node.right)\n\n        statement.pushStage(StageStatus.AddressOf)\n        const address = ts.visitNode(\n          statement.context.factory.createCallExpression(\n            statement.context.factory.createIdentifier(constant.addressof),\n            undefined,\n            [\n              node.left as ts.Expression\n            ]\n          ),\n          visitor\n        ) as ts.Expression\n        statement.popStage()\n        if (typeUtils.isStructType(type1) && typeUtils.isTypeEquals(type1, node.left, type2, node.right)\n          || type1.aliasSymbol && (\n            type1.aliasSymbol.escapedName === constant.typeStruct\n            || (type1.aliasSymbol.escapedName === constant.typeUnion)\n          )\n          && type1.aliasTypeArguments\n          && type2.aliasTypeArguments\n          && hasStruct(type1.aliasTypeArguments[0].symbol)\n          && typeUtils.isTypeEquals(type1.aliasTypeArguments[0], null, type2.aliasTypeArguments[0], null)\n        ) {\n          const struct = typeUtils.getStructByType(type1)\n          const valueAddress = ts.visitNode(\n            statement.context.factory.createCallExpression(\n              statement.context.factory.createIdentifier(constant.addressof),\n              undefined,\n              [\n                node.right as ts.Expression\n              ]\n            ),\n            visitor\n          )\n          return statement.context.factory.createCallExpression(\n            statement.addMemoryImport(constant.memcpy),\n            undefined,\n            [\n              address as ts.Expression,\n              valueAddress as ts.Expression,\n              nodeUtils.createPointerOperand(struct.length)\n            ]\n          )\n        }\n        else if (typeUtils.isBuiltinType(type1, node.left)\n          || (type1.aliasSymbol\n            && type1.aliasSymbol.escapedName === constant.typeBit\n          )\n          || (type1.symbol?.valueDeclaration\n            && (\n              ts.isEnumDeclaration(type1.symbol.valueDeclaration)\n              || ts.isEnumMember(type1.symbol.valueDeclaration)\n            )\n          )\n          || (type1.isUnion() && type1.types[0]?.symbol?.valueDeclaration\n            && (ts.isEnumDeclaration(type1.types[0]?.symbol?.valueDeclaration)\n              || ts.isEnumMember(type1.types[0]?.symbol?.valueDeclaration)\n            )\n          )\n        ) {\n          let newValue = visitorRight(node.right, visitor, node.operatorToken.kind) as ts.Expression\n          if (typeUtils.isSizeType(type1)) {\n            newValue = nodeUtils.createPointerOperand(newValue)\n          }\n\n          if (ts.isPropertyAccessExpression(node.left)) {\n            const type = statement.typeChecker.getTypeAtLocation(node.left.expression)\n            const struct = typeUtils.getStructByType(type)\n\n            if (struct == null) {\n              reportError(statement.currentFile, node, `${node.left.expression.getText()} is not struct`)\n              return node\n            }\n\n            const meta = getStructMeta(struct, node.left.name.escapedText as string)\n\n            if (!meta) {\n              reportError(statement.currentFile, node, `struct ${struct.symbol.deref().escapedName} not has property ${node.left.name.escapedText}`)\n              return node\n            }\n            return generateWritePropertyNode(address, newValue, meta)\n          }\n          else if (ts.isElementAccessExpression(node.left)) {\n            if (typeUtils.isBuiltinType(type1, node.left)) {\n              return statement.context.factory.createCallExpression(\n                statement.context.factory.createElementAccessExpression(\n                  statement.addMemoryImport(constant.ctypeEnumWrite) as ts.Expression,\n                  typeUtils.getBuiltinByType(type1, node.left)\n                ),\n                undefined,\n                [\n                  address as ts.Expression,\n                  newValue\n                ]\n              )\n            }\n          }\n        }\n\n      }\n    }\n\n    if (typeUtils.isSizeType(leftType)\n      && !isAllSizeOrPointer(node.right)\n    ) {\n      if (ts.isNumericLiteral(node.right)) {\n        return statement.context.factory.createBinaryExpression(\n          ts.visitNode(node.left, statement.visitor) as ts.Expression,\n          node.operatorToken,\n          nodeUtils.createPointerOperand(ts.visitNode(node.right, statement.visitor) as ts.Expression)\n        )\n      }\n      reportError(statement.currentFile, node, `type ${typeUtils.getBuiltinNameByType(leftType) || 'number'} is not assignable to value of type ${typeUtils.getBuiltinNameByType(rightType) || 'number'}`, error.TYPE_MISMATCH)\n      return node\n    }\n\n    return statement.context.factory.createBinaryExpression(\n      visitorLeft(node.left, visitor, node.operatorToken.kind) as ts.Expression,\n      ts.SyntaxKind.EqualsToken,\n      visitorRight(node.right, visitor, node.operatorToken.kind) as ts.Expression\n    )\n  }\n}\n\nfunction isAllSizeOrPointer(node: ts.Expression) {\n  if (ts.isBinaryExpression(node)) {\n    if (!isAllSizeOrPointer(node.left)) {\n      return false\n    }\n    return isAllSizeOrPointer(node.right)\n  }\n  else if (ts.isParenthesizedExpression(node)) {\n    return isAllSizeOrPointer(node.expression)\n  }\n  const type = statement.typeChecker.getTypeAtLocation(node)\n  if (typeUtils.isSizeType(type) || typeUtils.isPointerType(type, node)) {\n    return true\n  }\n  return false\n}\n\nfunction hasSizeNode(node: ts.Expression) {\n  if (ts.isBinaryExpression(node)) {\n    if (hasSizeNode(node.left)) {\n      return true\n    }\n    return hasSizeNode(node.right)\n  }\n  else if (ts.isParenthesizedExpression(node)) {\n    return hasSizeNode(node.expression)\n  }\n  const type = statement.typeChecker.getTypeAtLocation(node)\n  if (typeUtils.isSizeType(type)) {\n    return true\n  }\n  return false\n}\n\nfunction handle(node: ts.BinaryExpression, visitor: ts.Visitor): ts.Node {\n  /**\n   * 将多个等号变成逗号运算符\n   */\n  if ( node.operatorToken.kind === ts.SyntaxKind.EqualsToken\n    && ts.isBinaryExpression(node.right)\n    && node.right.operatorToken.kind === ts.SyntaxKind.EqualsToken\n    && (isPointerNode(node.right)\n      || isPointerNode(node.left)\n    )\n  ) {\n    const right = getEqualsBinaryExpressionRight(node)\n    let tree: ts.Node = statement.context.factory.createBinaryExpression(node.left, ts.SyntaxKind.EqualsToken, right)\n    let next: ts.Node = node.right\n    while (next && ts.isBinaryExpression(next) && next.operatorToken.kind === ts.SyntaxKind.EqualsToken) {\n      tree = statement.context.factory.createBinaryExpression(\n        tree as ts.Expression,\n        ts.SyntaxKind.CommaToken,\n        statement.context.factory.createBinaryExpression(next.left, ts.SyntaxKind.EqualsToken, right)\n      )\n      next = next.right\n    }\n    return ts.visitEachChild(tree, visitor, statement.context)\n  }\n  // 指针复合运算\n  else if (isPointerNode(node.left) && isMergeOperator(node.operatorToken.kind)) {\n    return ts.visitNode(\n      statement.context.factory.createBinaryExpression(\n        node.left,\n        ts.SyntaxKind.EqualsToken,\n        statement.context.factory.createBinaryExpression(\n          node.left,\n          mergeOperator2Operator(node.operatorToken.kind),\n          node.right\n        )\n      ),\n      visitor\n    )\n  }\n  // 赋值运算\n  else if (node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {\n    return equalVisitor(node, visitor)\n  }\n  // 单箭头运算\n  else if (node.operatorToken.kind === ts.SyntaxKind.LessThanToken\n    && ts.isPrefixUnaryExpression(node.right)\n    && node.right.operator === ts.SyntaxKind.MinusToken\n  ) {\n    return singleArrowVisitor(node, visitor)\n  }\n  // size 运算\n  else if ((hasSizeNode(node.right) || hasSizeNode(node.left))\n    && node.operatorToken.kind !== ts.SyntaxKind.AmpersandAmpersandToken\n    && node.operatorToken.kind !== ts.SyntaxKind.BarBarToken\n    && node.operatorToken.kind !== ts.SyntaxKind.GreaterThanToken\n    && node.operatorToken.kind !== ts.SyntaxKind.GreaterThanEqualsToken\n    && node.operatorToken.kind !== ts.SyntaxKind.LessThanToken\n    && node.operatorToken.kind !== ts.SyntaxKind.LessThanEqualsToken\n  ) {\n    if (hasSizeNode(node.left) && !isAllSizeOrPointer(node.right)) {\n      if (ts.isNumericLiteral(node.right) && (!node.parent || !ts.isBinaryExpression(node.parent))) {\n        return statement.context.factory.createBinaryExpression(\n          ts.visitNode(node.left, statement.visitor) as ts.Expression,\n          node.operatorToken.kind === ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken\n            ? ts.SyntaxKind.GreaterThanGreaterThanToken\n            : node.operatorToken.kind,\n          nodeUtils.createPointerOperand(node.right)\n        )\n      }\n      reportError(statement.currentFile, node, 'size type in binary expression must convert to other base type')\n      return node\n    }\n\n    if (!isAllSizeOrPointer(node.left) && hasSizeNode(node.right)) {\n      if (ts.isNumericLiteral(node.left) && (!node.parent || !ts.isBinaryExpression(node.parent))) {\n        return statement.context.factory.createBinaryExpression(\n          nodeUtils.createPointerOperand(node.left),\n          node.operatorToken,\n          ts.visitNode(node.right, statement.visitor) as ts.Expression\n        )\n      }\n      reportError(statement.currentFile, node, 'size type in binary expression must convert to other base type')\n      return node\n    }\n  }\n  // 指针加减运算\n  else if ((node.operatorToken.kind === ts.SyntaxKind.PlusToken\n    || node.operatorToken.kind === ts.SyntaxKind.MinusToken\n  )\n    && !statement.lookupStage(StageStatus.PointerPlusMinusIgnore)\n  ) {\n    const type1 = nodeUtils.getTypeAtLocation(node.left)\n    const type2 = nodeUtils.getTypeAtLocation(node.right)\n\n    if (typeUtils.isPointerType(type1, node.left)\n      && (ts.isNumericLiteral(node.right)\n        || type2.flags & ts.TypeFlags.NumberLike\n        || array.has(BuiltinNumber, typeUtils.getBuiltinNameByType(type2))\n      )\n    ) {\n      let step = 1\n\n      if (typeUtils.isPointerStructType(type1, node.left)) {\n        const struct = typeUtils.getPointerStructByType(type1, node.left)\n        step = struct.length\n      }\n      else if (typeUtils.isPointerBuiltinType(type1, node.left)) {\n        step = CTypeEnum2Bytes[typeUtils.getPointerBuiltinByType(type1, node.left)]\n      }\n\n      if (step > 1) {\n\n        const right = visitorRight(node.right, visitor, node.operatorToken.kind) as ts.NumericLiteral\n\n        return statement.context.factory.createBinaryExpression(\n          visitorLeft(node.left, visitor, node.operatorToken.kind) as ts.Expression,\n          node.operatorToken.kind,\n          ts.isNumericLiteral(right)\n            ? nodeUtils.createPointerOperand(+right.text * step)\n            : statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n              nodeUtils.createPointerOperand(right),\n              ts.SyntaxKind.AsteriskToken,\n              nodeUtils.createPointerOperand(step)\n            ))\n        )\n      }\n      else if (statement.cheapCompilerOptions.defined.WASM_64) {\n        const right = visitorRight(node.right, visitor, node.operatorToken.kind) as ts.Expression\n        return statement.context.factory.createBinaryExpression(\n          visitorLeft(node.left, visitor, node.operatorToken.kind) as ts.Expression,\n          node.operatorToken.kind,\n          nodeUtils.createPointerOperand(right)\n        )\n      }\n    }\n    else if (typeUtils.isPointerType(type2, node.right)\n      && (ts.isNumericLiteral(node.left)\n        || type1.flags & ts.TypeFlags.NumberLike\n        || array.has(BuiltinNumber, type1.aliasSymbol?.escapedName)\n      )\n    ) {\n      let step = 1\n\n      if (typeUtils.isPointerBuiltinType(type2, node.right)) {\n        step = CTypeEnum2Bytes[typeUtils.getPointerBuiltinByType(type2, node.right)]\n      }\n      else if (typeUtils.isPointerStructType(type2, node.right)) {\n        const struct = typeUtils.getPointerStructByType(type2, node.right)\n        step = struct.length\n      }\n\n      if (step > 1) {\n        const left = visitorRight(node.left, visitor, node.operatorToken.kind) as ts.Expression\n\n        return statement.context.factory.createBinaryExpression(\n          ts.isNumericLiteral(left)\n            ? nodeUtils.createPointerOperand(+left.text * step)\n            : statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n              nodeUtils.createPointerOperand(left),\n              ts.SyntaxKind.AsteriskToken,\n              nodeUtils.createPointerOperand(step)\n            )),\n          node.operatorToken.kind,\n          visitorLeft(node.right, visitor, node.operatorToken.kind) as ts.Expression\n        )\n      }\n      else if (statement.cheapCompilerOptions.defined.WASM_64) {\n        const left = visitorRight(node.left, visitor, node.operatorToken.kind) as ts.NumericLiteral\n        return statement.context.factory.createBinaryExpression(\n          nodeUtils.createPointerOperand(left),\n          node.operatorToken.kind,\n          visitorLeft(node.right, visitor, node.operatorToken.kind) as ts.Expression\n        )\n      }\n    }\n    else if (typeUtils.isPointerType(type1, node.left) && typeUtils.isPointerType(type2, node.right)) {\n      if (node.operatorToken.kind === ts.SyntaxKind.MinusToken && typeUtils.isTypeEquals(type1, node.left, type2, node.right)) {\n\n        let step = 1\n\n        if (typeUtils.isPointerBuiltinType(type1, node.left)) {\n          step = CTypeEnum2Bytes[typeUtils.getPointerBuiltinByType(type1, node.left)]\n        }\n        else if (typeUtils.isPointerStructType(type1, node.left)) {\n          const struct = typeUtils.getPointerStructByType(type1, node.left)\n          step = struct.length\n        }\n        if (step > 1) {\n          if (step & (step - 1)) {\n            if (statement.cheapCompilerOptions.defined.WASM_64) {\n              return statement.context.factory.createCallExpression(\n                statement.context.factory.createIdentifier('Number'),\n                undefined,\n                [\n                  statement.context.factory.createBinaryExpression(\n                    statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n                      visitorLeft(node.left, visitor, node.operatorToken.kind) as ts.Expression,\n                      node.operatorToken.kind,\n                      visitorRight(node.right, visitor, node.operatorToken.kind) as ts.Expression\n                    )),\n                    ts.SyntaxKind.SlashToken,\n                    nodeUtils.createBitInt(step)\n                  )\n                ]\n              )\n            }\n            else {\n              return statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n                statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n                  visitorLeft(node.left, visitor, node.operatorToken.kind) as ts.Expression,\n                  node.operatorToken.kind,\n                  visitorRight(node.right, visitor, node.operatorToken.kind) as ts.Expression\n                )),\n                ts.SyntaxKind.SlashToken,\n                statement.context.factory.createNumericLiteral(step)\n              ))\n            }\n          }\n          else {\n            let exponent = 0\n            while (step > 1) {\n              exponent++\n              step >>>= 1\n            }\n            if (statement.cheapCompilerOptions.defined.WASM_64) {\n              return statement.context.factory.createCallExpression(\n                statement.context.factory.createIdentifier('Number'),\n                undefined,\n                [\n                  statement.context.factory.createBinaryExpression(\n                    statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n                      visitorLeft(node.left, visitor, node.operatorToken.kind) as ts.Expression,\n                      node.operatorToken.kind,\n                      visitorRight(node.right, visitor, node.operatorToken.kind) as ts.Expression\n                    )),\n                    ts.SyntaxKind.GreaterThanGreaterThanToken,\n                    nodeUtils.createBitInt(exponent)\n                  )\n                ]\n              )\n            }\n            return statement.context.factory.createBinaryExpression(\n              statement.context.factory.createParenthesizedExpression(statement.context.factory.createBinaryExpression(\n                visitorLeft(node.left, visitor, node.operatorToken.kind) as ts.Expression,\n                node.operatorToken.kind,\n                visitorRight(node.right, visitor, node.operatorToken.kind) as ts.Expression\n              )),\n              ts.SyntaxKind.GreaterThanGreaterThanToken,\n              statement.context.factory.createNumericLiteral(exponent)\n            )\n          }\n        }\n        else if (statement.cheapCompilerOptions.defined.WASM_64) {\n          return statement.context.factory.createCallExpression(\n            statement.context.factory.createIdentifier('Number'),\n            undefined,\n            [\n              statement.context.factory.createBinaryExpression(\n                visitorLeft(node.left, visitor, node.operatorToken.kind) as ts.Expression,\n                node.operatorToken.kind,\n                visitorRight(node.right, visitor, node.operatorToken.kind) as ts.Expression\n              )\n            ]\n          )\n        }\n      }\n      else {\n        reportError(statement.currentFile, node, 'The operation between two pointer types only allowed subtraction')\n      }\n    }\n  }\n\n  if (statement.cheapCompilerOptions.defined.WASM_64) {\n    const type1 = statement.typeChecker.getTypeAtLocation(node.left)\n    if (typeUtils.isPointerType(type1, node.left)\n      && (!ts.isIdentifier(node.right)\n        || node.right.escapedText === constant.enumPointer\n          && !statement.lookupLocal(constant.enumPointer)\n      )\n    ) {\n      if (node.operatorToken.kind === ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken\n        || node.operatorToken.kind === ts.SyntaxKind.PercentToken\n      ) {\n        const right = visitorRight(node.right, visitor, node.operatorToken.kind) as ts.Expression\n        return statement.context.factory.createBinaryExpression(\n          visitorLeft(node.left, visitor, node.operatorToken.kind) as ts.Expression,\n          node.operatorToken.kind === ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken\n            ? ts.SyntaxKind.GreaterThanGreaterThanToken\n            : node.operatorToken.kind,\n          ts.isNumericLiteral(right)\n            ? nodeUtils.createPointerOperand(+right.text)\n            : nodeUtils.createPointerOperand(right)\n        )\n      }\n    }\n  }\n  return ts.visitEachChild(node, visitor, statement.context)\n}\n\nfunction computeVisitor(node: ts.BinaryExpression): ts.Node {\n  if (ts.isBinaryExpression(node)) {\n    if (ts.isNumericLiteral(node.left) && ts.isNumericLiteral(node.right)) {\n      const r = compute(+node.left.text, +node.right.text, node.operatorToken.kind)\n      if (is.number(r)) {\n        return statement.context.factory.createNumericLiteral(r)\n      }\n    }\n    if (nodeUtils.isBigIntNode(node.left) && nodeUtils.isBigIntNode(node.right)) {\n      const r = compute(nodeUtils.getBigIntValue(node.left as any), nodeUtils.getBigIntValue(node.right as any), node.operatorToken.kind)\n      if (is.bigint(r) && r <= Number.MAX_SAFE_INTEGER && r >= Number.MIN_SAFE_INTEGER) {\n        if (statement.cheapCompilerOptions.defined.BIGINT_LITERAL) {\n          return statement.context.factory.createBigIntLiteral(r.toString() + 'n')\n        }\n        else {\n          return statement.context.factory.createCallExpression(\n            statement.context.factory.createIdentifier('BigInt'),\n            undefined,\n            [\n              statement.context.factory.createNumericLiteral(r.toString())\n            ]\n          )\n        }\n      }\n    }\n    if (node.operatorToken.kind === ts.SyntaxKind.PlusToken) {\n      if (ts.isNumericLiteral(node.right) && node.right.text === '0') {\n        return node.left\n      }\n      else if (ts.isNumericLiteral(node.left) && node.left.text === '0') {\n        return node.right\n      }\n    }\n    if (node.operatorToken.kind === ts.SyntaxKind.MinusToken) {\n      if (ts.isNumericLiteral(node.right) && node.right.text === '0') {\n        return node.left\n      }\n    }\n    if (node.operatorToken.kind === ts.SyntaxKind.AsteriskToken) {\n      if (ts.isNumericLiteral(node.right) && node.right.text === '1') {\n        return node.left\n      }\n      else if (ts.isNumericLiteral(node.left) && node.left.text === '1') {\n        return node.right\n      }\n      if (ts.isNumericLiteral(node.right) && node.right.text === '0') {\n        return node.right\n      }\n      else if (ts.isNumericLiteral(node.left) && node.left.text === '0') {\n        return node.left\n      }\n    }\n    if (node.operatorToken.kind === ts.SyntaxKind.SlashToken) {\n      if (ts.isNumericLiteral(node.right) && node.right.text === '1') {\n        return node.left\n      }\n      if (ts.isNumericLiteral(node.left) && node.left.text === '0') {\n        return node.left\n      }\n    }\n  }\n  return ts.visitEachChild(node, computeVisitor as ts.Visitor, statement.context)\n}\n\nexport default function (node: ts.BinaryExpression, visitor: ts.Visitor): ts.Node {\n  let result = handle(node, visitor)\n  result = ts.isBinaryExpression(result) ? computeVisitor(result) : result\n  return result\n}\n","\nimport ts from 'typescript'\nimport statement from '../statement'\nimport { isPointerNode } from '../util/nodeutil'\nimport reportError from '../function/reportError'\nimport { BuiltinBigInt } from '../defined'\nimport * as typeUtils from '../util/typeutil'\nimport { toString, array } from '@libmedia/common'\n\nexport default function (node: ts.UnaryExpression, visitor: ts.Visitor): ts.Node {\n\n  if (ts.isPrefixUnaryExpression(node) && isPointerNode(node.operand)) {\n\n    const type = statement.typeChecker.getTypeAtLocation(node.operand)\n\n    let step = 1\n\n    // if (typeUtils.isPointerType(type)) {\n    //   if (typeUtils.isPointerBuiltinType(type)) {\n    //     step = CTypeEnum2Bytes[typeUtils.getPointerBuiltinByType(type)]\n    //   }\n    //   else if (typeUtils.isPointerStructType(type)) {\n    //     const struct = typeUtils.getPointerStructByType(type)\n    //     step = struct.length\n    //   }\n    // }\n\n    const stepNode = array.has(BuiltinBigInt, type.aliasSymbol?.escapedName as string)\n      ? statement.context.factory.createBigIntLiteral({\n        negative: false,\n        base10Value: toString(step)\n      })\n      : statement.context.factory.createNumericLiteral(step)\n\n    if (node.operator === ts.SyntaxKind.PlusPlusToken) {\n      if (ts.isExpressionStatement(node.parent)) {\n        return ts.visitNode(\n          statement.context.factory.createBinaryExpression(\n            node.operand,\n            ts.SyntaxKind.PlusEqualsToken,\n            stepNode\n          ),\n          visitor\n        )\n      }\n      return ts.visitNode(\n        statement.context.factory.createBinaryExpression(\n          statement.context.factory.createBinaryExpression(\n            node.operand,\n            ts.SyntaxKind.PlusEqualsToken,\n            stepNode\n          ),\n          ts.SyntaxKind.CommaToken,\n          node.operand\n        ),\n        visitor\n      )\n    }\n    else if (node.operator === ts.SyntaxKind.MinusMinusToken) {\n      if (ts.isExpressionStatement(node.parent)) {\n        return ts.visitNode(\n          statement.context.factory.createBinaryExpression(\n            node.operand,\n            ts.SyntaxKind.MinusEqualsToken,\n            stepNode\n          ),\n          visitor\n        )\n      }\n      return ts.visitNode(\n        statement.context.factory.createBinaryExpression(\n          statement.context.factory.createBinaryExpression(\n            node.operand,\n            ts.SyntaxKind.MinusEqualsToken,\n            stepNode\n          ),\n          ts.SyntaxKind.CommaToken,\n          node.operand\n        ),\n        visitor\n      )\n    }\n    else if (node.operator !== ts.SyntaxKind.ExclamationToken) {\n      reportError(statement.currentFile, node, 'The unary operation width pointer only allowed ++ -- !')\n      return node\n    }\n  }\n  else if (ts.isPostfixUnaryExpression(node) && isPointerNode(node.operand)) {\n\n    const type = statement.typeChecker.getTypeAtLocation(node.operand)\n\n    let step = 1\n\n    // if (typeUtils.isPointerType(type)) {\n    //   if (typeUtils.isPointerBuiltinType(type)) {\n    //     step = CTypeEnum2Bytes[typeUtils.getPointerBuiltinByType(type)]\n    //   }\n    //   else if (typeUtils.isPointerStructType(type)) {\n    //     const struct = typeUtils.getPointerStructByType(type)\n    //     step = struct.length\n    //   }\n    // }\n\n    const stepNode = array.has(BuiltinBigInt, typeUtils.getBuiltinNameByType(type))\n      ? statement.context.factory.createBigIntLiteral({\n        negative: false,\n        base10Value: toString(step)\n      })\n      : statement.context.factory.createNumericLiteral(step)\n\n    if (node.operator === ts.SyntaxKind.PlusPlusToken) {\n\n      if (ts.isExpressionStatement(node.parent)) {\n        return ts.visitNode(\n          statement.context.factory.createBinaryExpression(\n            node.operand,\n            ts.SyntaxKind.PlusEqualsToken,\n            stepNode\n          ),\n          visitor\n        )\n      }\n\n      return ts.visitNode(\n        statement.context.factory.createBinaryExpression(\n          statement.context.factory.createBinaryExpression(\n            node.operand,\n            ts.SyntaxKind.PlusEqualsToken,\n            stepNode\n          ),\n          ts.SyntaxKind.CommaToken,\n          statement.context.factory.createBinaryExpression(\n            node.operand,\n            ts.SyntaxKind.MinusToken,\n            stepNode\n          )\n        ),\n        visitor\n      )\n    }\n    else if (node.operator === ts.SyntaxKind.MinusMinusToken) {\n\n      if (ts.isExpressionStatement(node.parent)) {\n        return ts.visitNode(\n          statement.context.factory.createBinaryExpression(\n            node.operand,\n            ts.SyntaxKind.MinusEqualsToken,\n            stepNode\n          ),\n          visitor\n        )\n      }\n\n      return ts.visitNode(\n        statement.context.factory.createBinaryExpression(\n          statement.context.factory.createBinaryExpression(\n            node.operand,\n            ts.SyntaxKind.MinusEqualsToken,\n            stepNode\n          ),\n          ts.SyntaxKind.CommaToken,\n          statement.context.factory.createBinaryExpression(\n            node.operand,\n            ts.SyntaxKind.PlusToken,\n            stepNode\n          )\n        ),\n        visitor\n      )\n    }\n  }\n  return ts.visitEachChild(node, visitor, statement.context)\n}\n","import ts from 'typescript'\nimport statement from '../statement'\nimport reportError from '../function/reportError'\nimport { CTypeEnum2Bytes } from '../../typedef'\nimport { StructType } from '../struct'\nimport relativePath from '../function/relativePath'\nimport * as constant from '../constant'\nimport * as nodeUtils from '../util/nodeutil'\nimport * as typeUtils from '../util/typeutil'\n\n\nexport default function (node: ts.ElementAccessExpression, visitor: ts.Visitor): ts.Node {\n  const type = statement.typeChecker.getTypeAtLocation(node.expression)\n  // pointer[]\n  if (nodeUtils.isPointerElementAccess(node)\n    && (!type.aliasSymbol || type.aliasSymbol.escapedName !== constant.typeArray)\n  ) {\n    return ts.visitNode(\n      statement.context.factory.createCallExpression(\n        statement.context.factory.createIdentifier(constant.accessof),\n        undefined,\n        [\n          statement.context.factory.createBinaryExpression(\n            node.expression,\n            ts.SyntaxKind.PlusToken,\n            node.argumentExpression\n          )\n        ]\n      ),\n      visitor\n    )\n  }\n  else if (nodeUtils.isSmartPointerElementAccess(node)) {\n    reportError(statement.currentFile, node, 'smart pointer not support [] operate')\n    return node\n  }\n  // array[]\n  else if (ts.isPropertyAccessExpression(node.expression)\n      && nodeUtils.isPointerNode(node.expression.expression)\n    || ts.isElementAccessExpression(node.expression)\n      && nodeUtils.isPointerNode(node.expression)\n  ) {\n    const type = statement.typeChecker.getTypeAtLocation(node)\n    const expressionType = statement.typeChecker.getTypeAtLocation(node.expression)\n\n    if (typeUtils.isArrayType(expressionType) && ts.isNumericLiteral(node.argumentExpression)) {\n      const index = +node.argumentExpression.text\n      const max = +(expressionType.aliasTypeArguments[1] as ts.NumberLiteralType).value\n      if (index < 0 || index >= max) {\n        reportError(statement.currentFile, node, `type array access invalid index ${index}, range [0, ${max - 1}]`)\n        return node\n      }\n    }\n\n    let tree = ts.visitNode(\n      statement.context.factory.createCallExpression(\n        statement.context.factory.createIdentifier(constant.addressof),\n        undefined,\n        [\n          node.expression\n        ]\n      ),\n      visitor\n    )\n\n    if (typeUtils.isStructType(type)) {\n\n      let targetStruct = typeUtils.getStructByType(type)\n\n      let targetSymbol = targetStruct.symbol.deref()\n      let targetPath = ''\n\n      if (targetStruct.structType === StructType.INLINE_OBJECT) {\n        targetSymbol = targetStruct.definedClassParent.symbol.deref()\n        targetPath = targetStruct.definedClassParent.inlineStructPathMap.get(targetStruct.symbol.deref())\n      }\n\n      if (!(ts.isNumericLiteral(node.argumentExpression) && (+node.argumentExpression.text) === 0)) {\n        tree = statement.context.factory.createBinaryExpression(\n          tree as ts.Expression,\n          ts.SyntaxKind.PlusToken,\n          ts.isNumericLiteral(node.argumentExpression)\n            ? nodeUtils.createPointerOperand(targetStruct.length * (+node.argumentExpression.text))\n            : nodeUtils.createPointerOperand(statement.context.factory.createBinaryExpression(\n              statement.context.factory.createNumericLiteral(targetStruct.length),\n              ts.SyntaxKind.AsteriskToken,\n              statement.context.factory.createParenthesizedExpression(node.argumentExpression)\n            ))\n        )\n      }\n\n      const targetSource = targetSymbol.valueDeclaration?.getSourceFile()\n      if (targetSource) {\n        let key: ts.Expression\n        if (targetSource !== statement.currentFile) {\n          // addressof(array[]) 不需要导入\n          if (node.parent\n            && ts.isCallExpression(node.parent)\n            && ts.isIdentifier(node.parent.expression)\n            && node.parent.expression.escapedText === constant.addressof\n            && !statement.lookupFunc(constant.addressof)\n          ) {\n            key = statement.context.factory.createIdentifier('undefined')\n          }\n          else {\n            key = statement.addStructImport(\n              targetSymbol,\n              targetSource\n            )\n          }\n        }\n        else {\n          key = statement.context.factory.createIdentifier(targetSymbol.escapedName as string)\n        }\n        const args = [\n          tree as ts.Expression,\n          key\n        ]\n        if (targetPath) {\n          args.push(statement.context.factory.createStringLiteral(targetPath))\n        }\n        return statement.context.factory.createCallExpression(\n          statement.addIdentifierImport(constant.structAccess, constant.RootPath, false),\n          undefined,\n          args\n        )\n      }\n    }\n    else if (typeUtils.isBuiltinType(type, node)) {\n\n      if (!(ts.isNumericLiteral(node.argumentExpression) && (+node.argumentExpression.text) === 0)) {\n        tree = statement.context.factory.createBinaryExpression(\n          tree as ts.Expression,\n          ts.SyntaxKind.PlusToken,\n          ts.isNumericLiteral(node.argumentExpression)\n            ? nodeUtils.createPointerOperand(CTypeEnum2Bytes[typeUtils.getBuiltinByType(type, node)] * (+node.argumentExpression.text))\n            : nodeUtils.createPointerOperand(statement.context.factory.createBinaryExpression(\n              statement.context.factory.createNumericLiteral(CTypeEnum2Bytes[typeUtils.getBuiltinByType(type, node)]),\n              ts.SyntaxKind.AsteriskToken,\n              statement.context.factory.createParenthesizedExpression(node.argumentExpression)\n            ))\n        )\n      }\n\n      return statement.context.factory.createCallExpression(\n        statement.context.factory.createElementAccessExpression(\n          statement.addMemoryImport(constant.ctypeEnumRead) as ts.Expression,\n          typeUtils.getBuiltinByType(type, node)\n        ),\n        undefined,\n        [\n          tree as ts.Expression\n        ]\n      )\n    }\n    else {\n      reportError(statement.currentFile, node, 'struct type mismatch')\n      return node\n    }\n  }\n\n  return ts.visitEachChild(node, visitor, statement.context)\n}\n","\nimport { execSync } from 'child_process'\nimport statement from '../../statement'\nimport ts from 'typescript'\nimport reportError from '../../function/reportError'\nimport { array } from '@libmedia/common'\nimport * as errorType from '../../error'\nimport * as fs from 'fs'\n\nconst input = '__cheap__transformer_tmp.wat'\nconst output = '__cheap__transformer_tmp.wasm'\n\n\nexport default function processAsm(template: ts.TemplateExpression | ts.NoSubstitutionTemplateLiteral, node: ts.TaggedTemplateExpression, wasm64: boolean) {\n\n  let text = ''\n  let startPos = node.template.getStart()\n\n  if (ts.isNoSubstitutionTemplateLiteral(template)) {\n    text = template.text\n  }\n  else {\n    if (template.head) {\n      text += template.head.text\n    }\n\n    for (let i = 0; i < template.templateSpans.length; i++) {\n      const span = template.templateSpans[i]\n      if (ts.isStringLiteral(span.expression)\n        || ts.isNumericLiteral(span.expression)\n      ) {\n        text += span.expression.text\n        text += span.literal.text\n      }\n      else {\n        reportError(statement.currentFile, span.expression, `expression ${span.expression.getText()} not support in asm`)\n        return statement.context.factory.createStringLiteral('compile asm error')\n      }\n    }\n  }\n\n  const distPath = `${statement.options.tmpPath ? `${statement.options.tmpPath}/` : ''}`\n\n  if (distPath && !ts.sys.directoryExists(distPath)) {\n    ts.sys.createDirectory(distPath)\n  }\n\n  const inputPath = `${distPath}${input}`\n  const outputPath = `${distPath}${output}`\n\n  const cmd = `${statement.options.wat2wasm} ${inputPath} --enable-all -o ${outputPath}`\n\n  const source = `\n    (module\n      (import \"env\" \"memory\" (memory${wasm64 ? ' i64 ' : ' '}1 65536 shared))\n      ${text}\n    )\n  `\n\n  ts.sys.writeFile(inputPath, source)\n\n  try {\n    execSync(cmd, {\n      stdio: 'pipe'\n    })\n    const buffer = fs.readFileSync(outputPath)\n    return statement.context.factory.createStringLiteral(buffer.toString('base64'))\n  }\n  catch (error) {\n    let messages: string[] = error.message.split('\\n')\n    messages.shift()\n\n    let errorMessage = ''\n    let line = 0\n\n    function getPos(line: number) {\n      let pos = 0\n\n      while (line && pos < text.length) {\n        if (text[pos++] === '\\n') {\n          line--\n        }\n      }\n\n      while (pos < text.length) {\n        if (!/\\s/.test(text[pos])) {\n          break\n        }\n        pos++\n      }\n\n      const start = startPos + pos\n\n      while (pos < text.length) {\n        if (text[pos] === '\\n') {\n          break\n        }\n        pos++\n      }\n      const end = startPos + pos\n\n      return {\n        start, end\n      }\n    }\n\n    array.each(messages, (message) => {\n      const match = message.match(/__cheap__transformer_tmp.wat:(\\d+)/)\n      if (match) {\n        if (errorMessage) {\n          const { start, end } = getPos(line)\n          reportError(statement.currentFile, node, errorMessage, errorType.SYNTAX_ERROR, start, end)\n        }\n        errorMessage = `${message.split('error: ').pop()}`\n        line = +match[1] - 4\n      }\n      else if (message) {\n        errorMessage += `\\n${message}`\n      }\n    })\n\n    if (errorMessage) {\n      const { start, end } = getPos(line)\n      reportError(statement.currentFile, node, errorMessage, errorType.SYNTAX_ERROR, start, end)\n    }\n\n    return statement.context.factory.createStringLiteral('compile asm error')\n  }\n}\n","\nimport ts from 'typescript'\nimport statement from '../statement'\nimport * as constant from '../constant'\nimport processAsm from './function/processAsm'\n\nexport default function (node: ts.TaggedTemplateExpression, visitor: ts.Visitor): ts.Node {\n  if (ts.isIdentifier(node.tag) && (node.tag.escapedText === constant.tagAsm || node.tag.escapedText === constant.tagAsm64)) {\n    const template = ts.visitNode(node.template, visitor) as ts.TemplateExpression\n    return processAsm(template, node, node.tag.escapedText === constant.tagAsm64)\n  }\n  return ts.visitEachChild(node, visitor, statement.context)\n}\n","\nimport ts from 'typescript'\nimport statement from '../statement'\nimport * as nodeUtil from '../util/nodeutil'\nimport * as typeUtil from '../util/typeutil'\n\nexport default function (node: ts.ConditionalExpression, visitor: ts.Visitor): ts.Node {\n  if (ts.visitNode(node.condition, nodeUtil.hasDefined) && ts.visitNode(node.condition, nodeUtil.checkConditionCompile)) {\n    if (nodeUtil.checkBool(node.condition, visitor)) {\n      if (statement.cheapCompilerOptions.defined.WASM_64) {\n        const type = statement.typeChecker.getTypeAtLocation(node.whenFalse)\n        if (typeUtil.isSizeType(type)) {\n          return nodeUtil.createPointerOperand(ts.visitNode(node.whenTrue, visitor) as ts.Expression)\n        }\n      }\n      return ts.visitNode(node.whenTrue, visitor)\n    }\n    else {\n      if (statement.cheapCompilerOptions.defined.WASM_64) {\n        const type = statement.typeChecker.getTypeAtLocation(node.whenTrue)\n        if (typeUtil.isSizeType(type)) {\n          return nodeUtil.createPointerOperand(ts.visitNode(node.whenFalse, visitor) as ts.Expression)\n        }\n      }\n      return ts.visitNode(node.whenFalse, visitor)\n    }\n  }\n  if (statement.cheapCompilerOptions.defined.WASM_64) {\n    const type1 = statement.typeChecker.getTypeAtLocation(node.whenTrue)\n    const type2 = statement.typeChecker.getTypeAtLocation(node.whenFalse)\n    if (typeUtil.isSizeType(type1) && !typeUtil.isSizeType(type2)) {\n      return statement.context.factory.createConditionalExpression(\n        ts.visitNode(node.condition, statement.visitor) as ts.Expression,\n        node.questionToken,\n        ts.visitNode(node.whenTrue, statement.visitor) as ts.Expression,\n        node.colonToken,\n        nodeUtil.createPointerOperand(ts.visitNode(node.whenFalse, statement.visitor) as ts.Expression)\n      )\n    }\n    else if (!typeUtil.isSizeType(type1) && typeUtil.isSizeType(type2)) {\n      return statement.context.factory.createConditionalExpression(\n        ts.visitNode(node.condition, statement.visitor) as ts.Expression,\n        node.questionToken,\n        nodeUtil.createPointerOperand(ts.visitNode(node.whenTrue, statement.visitor) as ts.Expression),\n        node.colonToken,\n        ts.visitNode(node.whenFalse, statement.visitor) as ts.Expression\n      )\n    }\n  }\n  return ts.visitEachChild(node, visitor, statement.context)\n}\n","import ts from 'typescript'\nimport statement from '../statement'\nimport * as nodeUtils from '../util/nodeutil'\n\nimport callVisitor from './callVisitor'\nimport propertyAccessExpressionVisitor from './propertyAccessExpressionVisitor'\nimport binaryExpressionVisitor from './binaryExpressionVisitor'\nimport unaryExpressionVisitor from './unaryExpressionVisitor'\nimport elementAccessExpressionVisitor from './elementAccessExpressionVisitor'\nimport taggedTemplateExpressionVisitor from './taggedTemplateExpressionVisitor'\nimport conditionalExpressionVisitor from './conditionalExpressionVisitor'\n\nexport default function (node: ts.Expression, visitor: ts.Visitor): ts.Node {\n  if (ts.isBinaryExpression(node)) {\n    return binaryExpressionVisitor(node, visitor)\n  }\n  else if (ts.isPrefixUnaryExpression(node) || ts.isPostfixUnaryExpression(node)) {\n    return unaryExpressionVisitor(node, visitor)\n  }\n  else if (ts.isCallExpression(node)) {\n    return callVisitor(node, visitor)\n  }\n  else if (ts.isPropertyAccessExpression(node)) {\n    return propertyAccessExpressionVisitor(node, visitor)\n  }\n  else if (ts.isElementAccessExpression(node)) {\n    return elementAccessExpressionVisitor(node, visitor)\n  }\n  else if (statement.cheapCompilerOptions.defined.ENABLE_SYNCHRONIZE_API\n    && ts.isAwaitExpression(node)\n    && node.expression\n    && ts.isCallExpression(node.expression)\n    && (statement.lookupSynchronized()\n      || nodeUtils.isSynchronizeFunction(statement.typeChecker.getSymbolAtLocation(ts.isPropertyAccessExpression(node.expression.expression)\n        ? node.expression.expression.name\n        : node.expression.expression)?.valueDeclaration as ts.FunctionDeclaration)\n    )\n  ) {\n    return ts.visitEachChild(node.expression, visitor, statement.context)\n  }\n  else if (ts.isTaggedTemplateExpression(node)) {\n    return taggedTemplateExpressionVisitor(node, visitor)\n  }\n  else if (ts.isConditionalExpression(node)) {\n    return conditionalExpressionVisitor(node, visitor)\n  }\n\n  return ts.visitEachChild(node, visitor, statement.context)\n}\n","\nimport ts from 'typescript'\nimport statement from '../statement'\nimport * as typeUtils from '../util/typeutil'\nimport * as nodeUtils from '../util/nodeutil'\nimport reportError from '../function/reportError'\nimport * as error from '../error'\n\nexport default function (node: ts.PropertyDeclaration, visitor: ts.Visitor): ts.Node | ts.Node[] {\n  if (node.initializer && node.type && node.pos > -1) {\n    const type = statement.typeChecker.getTypeAtLocation(node.type)\n    const initType = statement.typeChecker.getTypeAtLocation(node.initializer)\n    if (typeUtils.isPointerType(type, null)\n      && (typeUtils.isBuiltinType(initType, node.initializer) || initType.flags & ts.TypeFlags.NumberLike)\n      && !typeUtils.isPointerType(initType, node.initializer)\n      && !typeUtils.isNullPointer(initType, node.initializer)\n    ) {\n      reportError(statement.currentFile, node, `type ${typeUtils.getBuiltinNameByType(initType) || 'number'} is not assignable to property declaration of type ${typeUtils.getBuiltinNameByType(type)}`, error.TYPE_MISMATCH)\n      return node\n    }\n    else if (typeUtils.isSizeType(type)) {\n      return ts.visitNode(statement.context.factory.createPropertyDeclaration(\n        node.modifiers,\n        node.name,\n        node.questionToken || node.exclamationToken,\n        node.type,\n        nodeUtils.createPointerOperand(node.initializer)\n      ), statement.visitor)\n    }\n  }\n  return ts.visitEachChild(node, visitor, statement.context)\n}\n","\nimport ts from 'typescript'\nimport statement from '../statement'\nimport * as typeUtils from '../util/typeutil'\nimport * as nodeUtils from '../util/nodeutil'\nimport reportError from '../function/reportError'\nimport * as error from '../error'\n\nexport default function (node: ts.PropertyAssignment, visitor: ts.Visitor): ts.Node | ts.Node[] {\n  if (node.initializer && node.pos > -1) {\n    const type = statement.typeChecker.getTypeAtLocation(node.name)\n    const initType = statement.typeChecker.getTypeAtLocation(node.initializer)\n    if (typeUtils.isPointerType(type, node.name)\n      && (typeUtils.isBuiltinType(initType, node.initializer) || initType.flags & ts.TypeFlags.NumberLike)\n      && !typeUtils.isPointerType(initType, node.initializer)\n      && !typeUtils.isNullPointer(initType, node.initializer)\n    ) {\n      reportError(statement.currentFile, node, `type ${typeUtils.getBuiltinNameByType(initType) || 'number'} is not assignable to property assignment of type ${typeUtils.getBuiltinNameByType(type)}`, error.TYPE_MISMATCH)\n      return node\n    }\n    else if (typeUtils.isSizeType(type, true)) {\n      return statement.context.factory.createPropertyAssignment(\n        node.name,\n        ts.visitNode(nodeUtils.createPointerOperand(node.initializer), statement.visitor) as ts.Expression\n      )\n    }\n  }\n  return ts.visitEachChild(node, visitor, statement.context)\n}\n","\nimport ts from 'typescript'\nimport statement from '../statement'\nimport * as typeUtils from '../util/typeutil'\nimport * as nodeUtils from '../util/nodeutil'\n\nexport default function (node: ts.BindingElement, visitor: ts.Visitor): ts.Node | ts.Node[] {\n  if (node.initializer && node.pos > -1) {\n    const type = statement.typeChecker.getTypeAtLocation(node.name)\n    if (typeUtils.isSizeType(type, true)) {\n      return statement.context.factory.createBindingElement(\n        node.dotDotDotToken,\n        node.propertyName,\n        node.name,\n        ts.visitNode(nodeUtils.createPointerOperand(node.initializer), statement.visitor) as ts.Expression\n      )\n    }\n  }\n  return ts.visitEachChild(node, visitor, statement.context)\n}\n","import { dirname as pathDirname } from 'path'\nimport { fileURLToPath } from 'url'\n\nexport default function getDirname(meta: string) {\n  if (typeof __dirname !== 'undefined') {\n    // CJS 环境\n    return __dirname\n  }\n  return pathDirname(fileURLToPath(meta))\n}\n","import ts from 'typescript'\nimport statement from './statement'\nimport blockVisitor from './visitor/blockVisitor'\nimport identifierVisitor from './visitor/identifierVisitor'\nimport decoratorVisitor, { asyncVisitor } from './visitor/decoratorVisitor'\nimport classDeclarationVisitor from './visitor/classDeclarationVisitor'\nimport ifStatementVisitor from './visitor/ifStatementVisitor'\nimport parameterVisitor from './visitor/parameterVisitor'\nimport variableDeclarationVisitor from './visitor/variableDeclarationVisitor'\nimport functionDeclarationVisitor from './visitor/functionDeclarationVisitor'\nimport type { TransformerOptions } from './type'\nimport expressionStatementVisitor from './visitor/expressionStatementVisitor'\nimport bigIntLiteralVisitor from './visitor/bigIntLiteralVisitor'\nimport expressionVisitor from './visitor/expressionVisitor'\nimport propertyDeclarationVisitor from './visitor/propertyDeclarationVisitor'\nimport propertyAssignmentVisitor from './visitor/propertyAssignmentVisitor'\nimport bindingElementVisitor from './visitor/bindingElementVisitor'\nimport * as constant from './constant'\nimport { getStructFileIdentifiers, clearStructCache } from './struct'\nimport * as typedef from '../typedef'\nimport * as definedConstant from './defined'\nimport { is, object, array } from '@libmedia/common'\nimport path from 'path'\nimport os from 'os'\nimport getDirname from './function/getDirname'\n\nconst importUrl = import.meta.url\n\nconst createNumericLiteralSymbol = Symbol('createNumericLiteral')\n\nconst DefaultDefined = {\n  ENV_NODE: false,\n  ENV_CSP: false,\n  ENV_CJS: false,\n  ENABLE_THREADS: true,\n  ENABLE_THREADS_SPLIT: false,\n  DEBUG: false,\n  BIGINT_LITERAL: true,\n  CHEAP_HEAP_INITIAL: 256,\n  ENABLE_SYNCHRONIZE_API: false,\n  ENABLE_LOG_PATH: true,\n  ENV_WEBPACK: false,\n  WASM_64: false,\n  USE_WORKER_SELF_URL: false\n}\nexport function before(program: ts.Program): ts.TransformerFactory<ts.SourceFile>\nexport function before(program: ts.Program, getProgram: () => ts.Program): ts.TransformerFactory<ts.SourceFile>\nexport function before(program: ts.Program, options: TransformerOptions): ts.TransformerFactory<ts.SourceFile>\nexport function before(program: ts.Program, options: TransformerOptions, getProgram: () => ts.Program): ts.TransformerFactory<ts.SourceFile>\nexport function before(program: ts.Program, options?: TransformerOptions | (() => ts.Program), getProgram?: () => ts.Program): ts.TransformerFactory<ts.SourceFile> {\n\n  if (is.func(options)) {\n    getProgram = options\n    options = {}\n  }\n  if (!options) {\n    options = {}\n  }\n\n  if (!options.projectPath) {\n    options.projectPath = program.getCurrentDirectory()\n  }\n  if (!options.wat2wasm) {\n    let wat2wasmPath = path.resolve(getDirname(importUrl), './asm/ubuntu') + '/wat2wasm'\n    if (os.platform() === 'win32') {\n      wat2wasmPath = path.resolve(getDirname(importUrl), './asm/win') + '/wat2wasm.exe'\n    }\n    else if (os.platform() === 'darwin') {\n      wat2wasmPath = path.resolve(getDirname(importUrl), './asm/macos') + '/wat2wasm'\n    }\n    options.wat2wasm = wat2wasmPath\n  }\n\n  const configFileName = ts.findConfigFile(options.projectPath, ts.sys.fileExists, 'tsconfig.json')\n  const configFile = configFileName && ts.readConfigFile(configFileName, ts.sys.readFile)\n\n  let compilerOptions = {\n    defined: {},\n    structPaths: {}\n  }\n\n  const defined = object.extend({}, DefaultDefined)\n  const structPaths = {}\n  if (configFile?.config?.cheap) {\n    object.extend(defined, configFile.config.cheap.defined || {})\n    if (configFile.config.cheap.structPaths) {\n      object.each(configFile.config.cheap.structPaths, (value, key) => {\n        structPaths[path.resolve(path.dirname(configFileName), key)] = value\n      })\n    }\n    compilerOptions = object.extend(compilerOptions, configFile.config['cheap'] || {})\n  }\n\n  if (options.defined) {\n    object.extend(defined, options.defined)\n  }\n  if (defined.ENV_CSP) {\n    defined.ENABLE_THREADS_SPLIT = true\n  }\n  compilerOptions.defined = defined\n  compilerOptions.structPaths = structPaths\n\n  statement.options = options\n  statement.cheapCompilerOptions = compilerOptions\n  statement.compilerOptions = program.getCompilerOptions()\n\n  const excludes = is.array(options.exclude)\n    ? options.exclude\n    : (options.exclude\n      ? [options.exclude]\n      : []\n    )\n\n  constant.setPacketName(options.cheapPacketName ?? '@libmedia/cheap')\n\n  if (statement.cheapCompilerOptions.defined.WASM_64) {\n    typedef.CTypeEnum2Bytes[typedef.CTypeEnum.pointer] = 8\n    typedef.CTypeEnumPointerShiftMap[typedef.CTypeEnum.pointer] = 3\n    typedef.CTypeEnum2Bytes[typedef.CTypeEnum.size] = 8\n    typedef.CTypeEnumPointerShiftMap[typedef.CTypeEnum.size] = 3\n    definedConstant.BuiltinBigInt.push(constant.typeSize)\n    statement.cheapCompilerOptions.defined.BIGINT_LITERAL = true\n  }\n  else {\n    typedef.CTypeEnum2Bytes[typedef.CTypeEnum.pointer] = 4\n    typedef.CTypeEnumPointerShiftMap[typedef.CTypeEnum.pointer] = 3\n    typedef.CTypeEnum2Bytes[typedef.CTypeEnum.size] = 4\n    typedef.CTypeEnumPointerShiftMap[typedef.CTypeEnum.size] = 3\n    array.remove(definedConstant.BuiltinBigInt, constant.typeSize)\n    if (defined.BIGINT_LITERAL === false) {\n      statement.cheapCompilerOptions.defined.BIGINT_LITERAL = false\n    }\n  }\n\n  clearStructCache()\n\n  return (context: ts.TransformationContext) => {\n\n    statement.context = context\n\n    const options = context.getCompilerOptions()\n    statement.moduleType = options.module\n    statement.esModuleInterop = options.esModuleInterop\n\n    const createNumericLiteral = context.factory.createNumericLiteral\n    if (!createNumericLiteral[createNumericLiteralSymbol]) {\n      // @ts-ignore\n      context.factory.createNumericLiteral = (value: string | number, numericLiteralFlags?: ts.TokenFlags) => {\n        if (is.number(value) && value < 0) {\n          return statement.context.factory.createPrefixUnaryExpression(\n            ts.SyntaxKind.MinusToken,\n            statement.context.factory.createNumericLiteral(Math.abs(value))\n          )\n        }\n        return createNumericLiteral(value, numericLiteralFlags)\n      }\n      context.factory.createNumericLiteral[createNumericLiteralSymbol] = true\n    }\n\n    return (file: ts.SourceFile) => {\n\n      if (excludes.some((exclude) => {\n        return exclude.test(file.fileName)\n      })) {\n        return file\n      }\n\n      if (getProgram) {\n        statement.program = getProgram()\n        statement.typeChecker = statement.program.getTypeChecker()\n      }\n      else {\n        statement.program = program\n        statement.typeChecker = program.getTypeChecker()\n      }\n\n      statement.start(file)\n\n      statement.visitor = (node: ts.Node): ts.Node | ts.Node[] => {\n        if (ts.isPropertyDeclaration(node)) {\n          return propertyDeclarationVisitor(node, statement.visitor)\n        }\n        else if (ts.isPropertyAssignment(node)) {\n          return propertyAssignmentVisitor(node, statement.visitor)\n        }\n        else if (ts.isBindingElement(node)) {\n          return bindingElementVisitor(node, statement.visitor)\n        }\n        else if (ts.isBlock(node)) {\n          return blockVisitor(node, statement.visitor)\n        }\n        else if (ts.isIdentifier(node)) {\n          return identifierVisitor(node, statement.visitor)\n        }\n        else if (ts.isDecorator(node)) {\n          return decoratorVisitor(node, statement.visitor)\n        }\n        else if (node.kind === ts.SyntaxKind.AsyncKeyword) {\n          return asyncVisitor(node as ts.AsyncKeyword, statement.visitor)\n        }\n        else if (ts.isClassDeclaration(node) && node.name && ts.isIdentifier(node.name)) {\n          return classDeclarationVisitor(node, statement.visitor)\n        }\n        else if (ts.isIfStatement(node)) {\n          return ifStatementVisitor(node, statement.visitor)\n        }\n        else if (ts.isParameter(node)) {\n          return parameterVisitor(node, statement.visitor)\n        }\n        else if (ts.isVariableDeclaration(node)) {\n          return variableDeclarationVisitor(node, statement.visitor)\n        }\n        else if (ts.isFunctionDeclaration(node)) {\n          return functionDeclarationVisitor(node, statement.visitor)\n        }\n        else if (ts.isExpressionStatement(node)) {\n          return expressionStatementVisitor(node, statement.visitor)\n        }\n        else if (ts.isBigIntLiteral(node)) {\n          return bigIntLiteralVisitor(node, statement.visitor)\n        }\n        else if (ts.isExpression(node)) {\n          return expressionVisitor(node, statement.visitor)\n        }\n        return ts.visitEachChild(node, statement.visitor, context)\n      }\n\n      return statement.end(ts.visitEachChild(file, statement.visitor, statement.context))\n    }\n  }\n}\n\nexport function after(program: ts.Program): ts.TransformerFactory<ts.SourceFile>\nexport function after(program: ts.Program, getProgram: () => ts.Program): ts.TransformerFactory<ts.SourceFile>\nexport function after(program: ts.Program, options: TransformerOptions): ts.TransformerFactory<ts.SourceFile>\nexport function after(program: ts.Program, options: TransformerOptions, getProgram: () => ts.Program): ts.TransformerFactory<ts.SourceFile>\nexport function after(program: ts.Program, options?: TransformerOptions | (() => ts.Program), getProgram?: () => ts.Program): ts.TransformerFactory<ts.SourceFile> {\n\n  if (is.func(options)) {\n    getProgram = options\n    options = {}\n  }\n  if (!options) {\n    options = {}\n  }\n\n  const excludes = is.array(options.exclude)\n    ? options.exclude\n    : (options.exclude\n      ? [options.exclude]\n      : []\n    )\n\n  return (context: ts.TransformationContext) => {\n    return (file: ts.SourceFile) => {\n      if (excludes.some((exclude) => {\n        return exclude.test(file.fileName)\n      })) {\n        return file\n      }\n      const visitor = (node: ts.Node): ts.Node | ts.Node[] => {\n        return ts.visitEachChild(node, visitor, context)\n      }\n      return ts.visitEachChild(file, visitor, context)\n    }\n  }\n}\n\nexport function afterDeclarations(program: ts.Program): ts.TransformerFactory<ts.SourceFile>\nexport function afterDeclarations(program: ts.Program, getProgram: () => ts.Program): ts.TransformerFactory<ts.SourceFile>\nexport function afterDeclarations(program: ts.Program, options: TransformerOptions): ts.TransformerFactory<ts.SourceFile>\nexport function afterDeclarations(program: ts.Program, options: TransformerOptions, getProgram: () => ts.Program): ts.TransformerFactory<ts.SourceFile>\nexport function afterDeclarations(program: ts.Program, options?: TransformerOptions | (() => ts.Program), getProgram?: () => ts.Program): ts.TransformerFactory<ts.SourceFile> {\n\n  if (is.func(options)) {\n    getProgram = options\n    options = {}\n  }\n  if (!options) {\n    options = {}\n  }\n\n  const excludes = is.array(options.exclude)\n    ? options.exclude\n    : (options.exclude\n      ? [options.exclude]\n      : []\n    )\n\n  return (context: ts.TransformationContext) => {\n\n    return (file: ts.SourceFile) => {\n\n      if (excludes.some((exclude) => {\n        return exclude.test(file.fileName)\n      })) {\n        return file\n      }\n\n      const structFileIdentifiers = getStructFileIdentifiers(file.fileName)\n\n      const visitor = (node: ts.Node): ts.Node | ts.Node[] => {\n        if (ts.isClassDeclaration(node) && node.name && ts.isIdentifier(node.name)) {\n          let name = node.name.escapedText as string\n          if (node.modifiers && node.modifiers.some((modifier) => {\n            return modifier.kind === ts.SyntaxKind.DefaultKeyword\n          })) {\n            name = 'default'\n          }\n          if (structFileIdentifiers && array.has(structFileIdentifiers, name)) {\n            const modifiers = node.modifiers ? [...node.modifiers] : []\n            modifiers.unshift(context.factory.createDecorator(context.factory.createIdentifier(constant.typeStruct)))\n            return context.factory.createClassDeclaration(\n              modifiers,\n              node.name,\n              node.typeParameters,\n              node.heritageClauses,\n              node.members\n            )\n          }\n        }\n        return ts.visitEachChild(node, visitor, context)\n      }\n      return ts.visitEachChild(file, visitor, context)\n    }\n  }\n}\n"],"names":["path","symbolStructMaxBaseTypeByteLength","symbolStructLength","regExpEscape","qmark","star","array","constant.RootPath","constant.InternalPath","constant.PACKET_NAME","constant.importDefault","constant.importStar","constant.ctypeEnumRead","constant.ctypeEnumReadPath","constant.ctypeEnumWrite","constant.ctypeEnumWritePath","constant.Allocator","constant.AllocatorPath","constant.makeSharedPtr","constant.makeSharedPtrPath","constant.definedMetaProperty","constant.definedMetaPropertyPath","constant.make","constant.makePath","constant.unmake","constant.unmakePath","constant.sizeof","constant.sizeofPath","constant.structAccess","constant.structAccessPath","constant.memoryPath","constant.symbolPath","object","constant.cstruct","constant.cunion","constant.cignore","constant.ctype","constant.cpointer","constant.carray","constant.cbitField","constant.cinline","constant.cdeasync","is","isLittleEndian","nodeUtil.checkBool","constant.typeArray","constant.typeBit","constant.typePointer","constant.typeStruct","constant.typeUnion","constant.typeAnyptr","constant.typeMultiPointer","constant.typeProperty","constant.levelProperty","constant.structProperty","constant.typeNullptr","constant.typeSize","constant.sharedPtr","typeUtils.isPointerType","typeUtils.isSmartPointerType","constant.indexOf","typeUtils.isSizeType","constant.defined","nodeUtils.isSynchronizeFunction","nodeUtil.createBitInt","definedMetaProperty","symbolStruct","constant.symbolStruct","constant.symbolStructMaxBaseTypeByteLength","constant.symbolStructLength","symbolStructKeysMeta","constant.symbolStructKeysMeta","constant.prototype","typeUtils.getStructByType","nodeUtil.hasDefined","nodeUtil.checkConditionCompile","nodeUtils.createPointerOperand","typeUtils.isBuiltinType","typeUtils.isNullPointer","typeUtils.getBuiltinNameByType","error.TYPE_MISMATCH","constant.assert","constant.LINE","constant.LINE_2","constant.FILE","constant.FILE_2","isDef","toString","args","constant.args","constant.enableArgs","typeUtils.getBuiltinByType","cheapThreadPath","constant.cheapThreadPath","constant.createThreadFromClass","constant.createThreadFromFunction","constant.createThreadFromModule","typeUtils.isStructType","nodeUtils.getParseTreeNode","nodeUtils.getContainerNode","nodeUtils.getParameterDefaultValue","nodeUtils.isAtomicCallExpression","typeUtils.getPointerBuiltinByType","constant.staticCast","constant.addressof","constant.accessof","constant.symbolStructAddress","nodeUtils.isPointerIndexOfCall","typeUtils.isArrayType","nodeUtils.getPointerExpressionType","typeUtils.isPointerStructType","typeUtils.getPointerStructByType","typeUtils.isPointerBuiltinType","constant.offsetof","nodeUtils.getBinaryBuiltinTypeName","constant.reinterpretCast","nodeUtils.isBigIntNode","nodeUtils.getBigIntValue","constant.move","constant.malloc","constant.calloc","constant.realloc","constant.alignedAlloc","constant.free","error.INVALID_OPERATE","constant.makeSharedPtrImportName","nodeUtils.createBitInt","nodeUtils.isPointerNode","constant.smartPointerProperty","nodeUtils.isSmartPointerNode","nodeUtils.getPropertyAccessExpressionRootNode","typeUtils.getSmartPointerStructByType","nodeUtils.isPointerElementAccess","typeUtils.isTypeEquals","constant.memcpy","nodeUtils.isExpressionPointer","nodeUtils.getTypeAtLocation","constant.enumPointer","nodeUtils.isSmartPointerElementAccess","execSync","fs","errorType.SYNTAX_ERROR","constant.tagAsm","constant.tagAsm64","typeUtil.isSizeType","nodeUtil.createPointerOperand","pathDirname","fileURLToPath","constant.setPacketName","typedef.CTypeEnum2Bytes","definedConstant.BuiltinBigInt"],"mappings":"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","x_google_ignoreList":[6,7,8,9,10,11,12,13]}